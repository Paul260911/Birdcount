<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>BirdCount – Professionelles Beobachtungssystem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes, viewport-fit=cover" />
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#0f1724" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="BirdCount" />
  <meta name="description" content="Professionelles Vogelbeobachtungssystem - Erfasse, verwalte und analysiere deine Vogelbeobachtungen" />
  
  <!-- Content Security Policy (Sicherheit - deaktiviert für Entwicklung) -->
  <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: 'unsafe-inline' 'unsafe-eval';"> -->
  
  <!-- Touch Icons für iOS -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%230f1724'/><text y='75' font-size='70' text-anchor='middle' x='50' fill='%2306b6d4' font-family='Arial,sans-serif' font-weight='bold'>BC</text></svg>" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#94a3b8; --accent:#06b6d4; --accent-2:#7c3aed;
      --glass: rgba(255,255,255,0.04);
      --success:#10b981; --danger:#ef4444; --surface:#0b1220;
      --text:#e6eef6; --soft:#cbd5e1; --light-text:#f8fafc;
      --radius:12px;
    }
    [data-theme="light"]{
      --bg:#f6f8fb; --card:#ffffff; --muted:#6b7280; --accent:#0ea5a4; --accent-2:#7c3aed;
      --glass: rgba(15,23,36,0.03);
      --success:#10b981; --danger:#ef4444; --surface:#ffffff;
      --text:#0f1724; --soft:#475569; --light-text:#1e293b;
    }
    /* NEU: Natur-Theme (Wald/Grün) */
    [data-theme="nature"]{
      --bg:#0a1f0f; --card:#0d2818; --muted:#86a695; --accent:#22c55e; --accent-2:#16a34a;
      --glass: rgba(34,197,94,0.04);
      --success:#4ade80; --danger:#f87171; --surface:#0d2818;
      --text:#e6f4ec; --soft:#86efac; --light-text:#dcfce7;
    }
    /* NEU: Ozean-Theme (Wasser/Blau) */
    [data-theme="ocean"]{
      --bg:#0a1929; --card:#0c1e33; --muted:#7ba5c7; --accent:#0ea5e9; --accent-2:#0284c7;
      --glass: rgba(14,165,233,0.04);
      --success:#22d3ee; --danger:#f87171; --surface:#0c1e33;
      --text:#e0f2fe; --soft:#7dd3fc; --light-text:#f0f9ff;
    }
    /* NEU: Sonnenuntergang-Theme (Orange/Rosa) */
    [data-theme="sunset"]{
      --bg:#1f1012; --card:#2d1315; --muted:#d4a5ab; --accent:#f97316; --accent-2:#ec4899;
      --glass: rgba(249,115,22,0.04);
      --success:#fb923c; --danger:#f43f5e; --surface:#2d1315;
      --text:#fff1f2; --soft:#fecdd3; --light-text:#ffe4e6;
    }
    /* NEU: Mitternacht-Theme (Tiefschwarz) */
    [data-theme="midnight"]{
      --bg:#000000; --card:#0a0a0a; --muted:#737373; --accent:#3b82f6; --accent-2:#8b5cf6;
      --glass: rgba(255,255,255,0.02);
      --success:#10b981; --danger:#ef4444; --surface:#0a0a0a;
      --text:#f5f5f5; --soft:#a3a3a3; --light-text:#ffffff;
    }


    html,body{height:100%; margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,var(--bg),#071022); color:var(--text); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; scroll-behavior:smooth; -webkit-overflow-scrolling:touch;}
    
    /* Touch-friendly improvements */
    * {
      -webkit-tap-highlight-color: rgba(6,182,212,0.1);
      /* Eliminiere Touch-Delay komplett */
      touch-action: manipulation;
    }
    
    button, a, .small-btn, .btn {
      touch-action: manipulation;
      /* Sofortige Reaktion - KEINE Transitions */
      transition: none !important;
      user-select: none;
      -webkit-user-select: none;
      /* Hardware-Beschleunigung */
      transform: translateZ(0);
      will-change: auto; /* Nur bei Bedarf */
      /* Anti-Aliasing */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Verhindere Flackern */
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    
    /* Instant Hover - KEINE Transition */
    button:hover, a:hover, .small-btn:hover, .btn:hover {
      transition: none !important;
    }
    
    /* Instant Active State */
    button:active, .btn:active, .small-btn:active {
      transform: scale(0.97) translateZ(0);
      transition: none !important;
    }
    
    /* GPU-Beschleunigung für Cards */
    .card {
      transform: translateZ(0);
      will-change: auto;
    }
    
    /* Instant Navigation-Buttons */
    .nav button {
      transform: translateZ(0);
      transition: none !important;
    }
    
    .nav button:active {
      transform: translateX(2px) translateZ(0);
      transition: none !important;
    }
    
    /* Instant Input Response */
    input, select, textarea {
      transition: none !important;
    }
    
    input:focus, select:focus, textarea:focus {
      transition: none !important;
    }
    .app { display:flex; min-height:100vh; gap:24px; padding:28px; box-sizing:border-box; }

    /* Sidebar - Desktop Standard */
    .sidebar {
      width:280px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:16px; padding:18px; box-shadow:0 6px 24px rgba(2,6,23,0.6); flex-shrink:0;
      display:flex; flex-direction:column; gap:12px;
      border:1px solid rgba(255,255,255,0.03);
      position: relative; /* Standard für Desktop */
    }
    .brand { display:flex; gap:12px; align-items:center; }
    .logo { width:44px; height:44px; border-radius:10px; background:linear-gradient(135deg,var(--accent),var(--accent-2)); display:flex; align-items:center; justify-content:center; font-weight:700; color:white; box-shadow:0 6px 18px rgba(12,18,30,0.6); }
    .brand h1{ font-size:16px; margin:0; letter-spacing:-0.2px; }
    .brand p{ margin:0; font-size:12px; color:var(--muted); }

    .nav { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .nav button { background:transparent; border:none; color:var(--soft); text-align:left; padding:10px 12px; border-radius:10px; cursor:pointer; display:flex; gap:10px; align-items:center; font-weight:600; }
    .nav button:hover { background:var(--glass); color:var(--text); transform:translateY(-1px); }
    .nav button.active { background:linear-gradient(90deg, rgba(124,58,237,0.12), rgba(6,182,212,0.06)); color:var(--text); box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02); }

    .sidebar .actions { margin-top:auto; display:flex; gap:8px; align-items:center; }
    .btn { background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
    .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--soft); }

    /* Main content */
    .main {
      flex:1; display:flex; flex-direction:column; gap:18px;
    }
    .topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .search { flex:1; display:flex; gap:8px; align-items:center; background:var(--glass); padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.02); }
    .search input { background:transparent; border:none; outline:none; color:var(--text); width:100%; font-size:14px; }
    .controls { display:flex; gap:8px; align-items:center; }

    /* Grid */
    .grid { display:grid; grid-template-columns: 1fr 420px; gap:18px; align-items:start; transition: all 240ms ease; }
    .card { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:16px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); box-shadow:0 6px 18px rgba(2,6,23,0.5); }
    .card h2 { margin:0 0 8px 0; font-size:16px; }
    .muted { color:var(--muted); font-size:13px; }

    /* Map */
    #map { height:420px; border-radius:10px; overflow:hidden; border:1px solid rgba(255,255,255,0.03); }
    #mapCard { padding:0; overflow:visible; }

    /* When map-full is active */
    .map-full .grid { grid-template-columns: 1fr; }
    .map-full .main > .grid > div:first-child { display:none; }
    .map-full aside { grid-column: 1 / -1; }
    .map-full #map { height: calc(100vh - 180px); }
    /* Sidebar bleibt sichtbar */

    /* Forms */
    .form-row { display:flex; gap:8px; margin-top:8px; }
    .input, input[type="text"], input[type="date"], select { background:transparent; border:1px solid rgba(255,255,255,0.04); padding:8px 10px; border-radius:8px; color:var(--text); outline:none; min-width:0; }
    .small-btn { padding:6px 8px; border-radius:8px; border:none; cursor:pointer; background:var(--accent-2); color:white; font-weight:600; }

    /* Marker list */
    .marker-list { max-height:220px; overflow:auto; margin-top:8px; display:flex; flex-direction:column; gap:8px; }
    .marker-item { display:flex; justify-content:space-between; gap:8px; align-items:center; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border:1px solid rgba(255,255,255,0.02); }
    .marker-meta { color:var(--muted); font-size:13px; }

    /* === NEUE FEATURES: Tutorial, Tooltips, Enhanced Stats === */
    
    /* Tutorial System */
    .tutorial-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(12px);
      z-index: 10000; display: flex; align-items: center; justify-content: center;
      padding: 20px; animation: fadeIn 0.3s ease;
    }
    .tutorial-box {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.08); border-radius: 20px;
      max-width: 600px; width: 100%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden; animation: slideUp 0.4s ease;
    }
    @keyframes slideUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .tutorial-header {
      padding: 24px 28px; border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex; justify-content: space-between; align-items: center;
      background: linear-gradient(90deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
    }
    .tutorial-header h3 {
      margin: 0; font-size: 22px; font-weight: 700;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .tutorial-close {
      background: transparent; border: none; color: var(--muted);
      font-size: 28px; cursor: pointer; width: 36px; height: 36px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 8px; transition: all 0.2s ease;
    }
    .tutorial-close:hover {
      background: rgba(255,255,255,0.06); color: var(--text);
      transform: rotate(90deg);
    }
    .tutorial-content {
      padding: 32px 28px; min-height: 280px;
    }
    .tutorial-content p {
      font-size: 16px; line-height: 1.6; color: var(--soft);
      margin: 0 0 20px 0;
    }
    .tutorial-image {
      margin-top: 24px; text-align: center; font-size: 80px;
      animation: bounce 2s infinite;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    .tutorial-footer {
      padding: 20px 28px; border-top: 1px solid rgba(255,255,255,0.06);
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0,0,0,0.2);
    }
    .tutorial-progress {
      color: var(--muted); font-size: 14px; font-weight: 600;
    }
    .tutorial-buttons {
      display: flex; gap: 10px;
    }
    .tutorial-highlight {
      position: relative; z-index: 10001;
      box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.5), 0 0 60px rgba(6, 182, 212, 0.4);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.5), 0 0 60px rgba(6, 182, 212, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(6, 182, 212, 0.3), 0 0 80px rgba(6, 182, 212, 0.6); }
    }
    
    /* Tooltips */
    .tooltip-container {
      position: fixed; background: linear-gradient(135deg, rgba(6,182,212,0.95), rgba(124,58,237,0.95));
      color: white; padding: 8px 12px; border-radius: 8px;
      font-size: 13px; font-weight: 500; z-index: 10000;
      pointer-events: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 250px; animation: tooltipFadeIn 0.2s ease;
    }
    @keyframes tooltipFadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Enhanced Stats */
    .enhanced-stats-modal {
      max-width: 1000px;
    }
    .stats-tabs {
      display: flex; gap: 8px; margin-bottom: 24px;
      border-bottom: 2px solid rgba(255,255,255,0.04);
      overflow-x: auto; padding-bottom: 8px;
    }
    .stats-tab {
      background: transparent; border: none; color: var(--muted);
      padding: 12px 20px; border-radius: 8px 8px 0 0;
      cursor: pointer; font-weight: 600; font-size: 14px;
      white-space: nowrap; transition: all 0.2s ease;
    }
    .stats-tab:hover {
      background: var(--glass); color: var(--text);
    }
    .stats-tab.active {
      background: linear-gradient(180deg, rgba(6,182,212,0.12), transparent);
      color: var(--text); border-bottom: 2px solid var(--accent);
    }
    .stats-tab-content {
      animation: fadeInUp 0.3s ease;
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .stats-grid {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px; margin-bottom: 32px;
    }
    .stat-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
      border: 1px solid rgba(255,255,255,0.06); border-radius: 12px;
      padding: 20px; text-align: center; transition: transform 0.2s ease;
    }
    .stat-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(6,182,212,0.2);
    }
    .stat-icon { font-size: 36px; margin-bottom: 12px; }
    .stat-value {
      font-size: 32px; font-weight: 700; color: var(--text);
      margin-bottom: 8px;
    }
    .stat-label {
      font-size: 13px; color: var(--muted);
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    
    /* Bulk Edit */
    .bulk-edit-modal { max-width: 700px; }
    .bulk-action-grid {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px; margin-top: 16px;
    }
    .bulk-action-btn {
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
      border: 1px solid rgba(255,255,255,0.06); border-radius: 12px;
      padding: 20px 16px; cursor: pointer; color: var(--text);
      font-size: 13px; font-weight: 600; text-align: center;
      transition: all 0.2s ease; line-height: 1.4;
    }
    .bulk-action-btn:hover {
      background: linear-gradient(135deg, rgba(6,182,212,0.15), rgba(124,58,237,0.15));
      transform: translateY(-2px); box-shadow: 0 4px 12px rgba(6,182,212,0.2);
    }
    .bulk-action-btn.danger {
      background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(220,38,38,0.1));
      border-color: rgba(239,68,68,0.3);
    }
    .bulk-selected-list {
      max-height: 300px; overflow-y: auto;
      display: flex; flex-direction: column; gap: 8px; margin-top: 12px;
    }
    .bulk-selected-item {
      background: var(--glass); border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px; padding: 12px; display: flex;
      justify-content: space-between; align-items: center;
    }
    .obs-checkbox {
      width: 18px; height: 18px; cursor: pointer;
      accent-color: var(--accent); margin-right: 8px;
    }
    
    /* Filter Label Hover Effects */
    #tickableFilterLabel:hover,
    #selffoundFilterLabel:hover,
    #newSpeciesFilterLabel:hover {
      background: rgba(255,255,255,0.05);
      transform: translateY(-1px);
    }
    
    #newSpeciesFilterLabel {
      position: relative;
    }
    
    #newSpeciesFilterLabel:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(6,182,212,0.95);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      margin-bottom: 6px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    /* Milestones */
    .milestone-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.06), rgba(124,58,237,0.06));
      border: 1px solid rgba(255,255,255,0.06); border-radius: 12px;
      padding: 20px; display: flex; align-items: center; gap: 20px;
      transition: all 0.2s ease; margin-bottom: 16px;
    }
    .milestone-card:hover {
      transform: translateX(4px); box-shadow: 0 4px 16px rgba(6,182,212,0.15);
    }
    .milestone-card.achieved {
      background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(34,197,94,0.1));
      border-color: rgba(16,185,129,0.3);
    }
    .milestone-icon {
      font-size: 48px; width: 70px; height: 70px;
      display: flex; align-items: center; justify-content: center;
      background: rgba(255,255,255,0.04); border-radius: 50%; flex-shrink: 0;
    }
    .milestone-card.achieved .milestone-icon {
      background: rgba(16,185,129,0.15);
    }
    .milestone-info { flex: 1; }
    .milestone-info h4 {
      margin: 0 0 8px 0; font-size: 16px; color: var(--text);
    }
    .milestone-info p {
      margin: 0; font-size: 13px; color: var(--muted);
    }
    .milestone-progress {
      font-size: 14px; color: var(--accent);
      font-weight: 600; margin-top: 8px;
    }
    .milestone-card.achieved .milestone-progress {
      color: var(--success);
    }
    .milestone-badge {
      background: var(--accent); color: white;
      padding: 4px 12px; border-radius: 12px;
      font-size: 11px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .milestone-card.achieved .milestone-badge {
      background: var(--success);
    }
    .progress-bar-container {
      width: 100%; height: 32px; background: rgba(0,0,0,0.3);
      border-radius: 16px; overflow: hidden; position: relative;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .progress-bar {
      height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-2));
      border-radius: 16px; transition: width 1s ease;
      display: flex; align-items: center; justify-content: flex-end;
      padding-right: 12px; color: white; font-weight: 700; font-size: 14px;
      box-shadow: 0 0 20px rgba(6,182,212,0.5);
    }

    /* Diagram canvas container */
    #canvasContainer { 
      width:100%; 
      display:flex; 
      justify-content:center; 
      margin-top:8px; 
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); 
      padding:20px; 
      border-radius:12px; 
      border:1px solid rgba(255,255,255,0.02);
      min-height: 400px;
      position: relative;
    }
    #chartCanvas {
      width: 100% !important;
      height: 380px !important;
    }

    /* Mobile Sidebar */
    @media (min-width:701px){
      /* Desktop: Sidebar normal sichtbar */
      .sidebar {
        position: relative !important;
        transform: translateX(0) !important;
        width: 280px;
        left: auto !important;
        height: auto !important;
      }
      
      /* Desktop: Hamburger-Button versteckt */
      .mobile-menu-btn {
        display: none !important;
      }
      
      /* Desktop: Mobile-Overlay versteckt */
      .mobile-overlay {
        display: none !important;
      }
      
      /* Desktop: Main ohne extra Padding */
      .main {
        padding-top: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }
      
      /* Desktop: App normales Layout */
      .app {
        display: flex !important;
        padding: 28px !important;
      }
      
      /* Desktop: Body normal scrollbar */
      body {
        overflow: auto !important;
      }
    }
    
    @media (max-width:1000px){
      .app{ padding:18px; }
      .grid{ grid-template-columns: 1fr; }
    }
    
    /* NEU: Hamburger Menu Button */
    .mobile-menu-btn {
      display: none !important; /* Explizit auf Desktop verstecken */
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10001; /* HÖHER als Sidebar (z-index: 1000) und Overlay (z-index: 999) */
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      border: none;
      border-radius: 12px;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      pointer-events: auto;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* Wenn Sidebar offen ist, ändert sich der Button zu X */
    .mobile-menu-btn.menu-open {
      background: linear-gradient(135deg, var(--danger), #dc2626);
    }
    
    .mobile-menu-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(6,182,212,0.4);
    }
    
    .mobile-menu-btn:active {
      transform: scale(0.95);
    }
    
    .mobile-menu-btn svg {
      width: 24px;
      height: 24px;
      stroke: white;
      stroke-width: 2.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      pointer-events: none;
      transition: all 0.3s ease;
    }
    
    /* Hamburger Lines */
    .mobile-menu-btn svg line {
      transition: all 0.3s ease;
      transform-origin: center;
    }
    
    /* Wenn geöffnet: Erste Linie wird zur oberen X-Linie */
    .mobile-menu-btn.menu-open svg line:nth-child(1) {
      transform: rotate(45deg) translate(5px, 5px);
    }
    
    /* Wenn geöffnet: Mittlere Linie verschwindet */
    .mobile-menu-btn.menu-open svg line:nth-child(2) {
      opacity: 0;
      transform: scaleX(0);
    }
    
    /* Wenn geöffnet: Dritte Linie wird zur unteren X-Linie */
    .mobile-menu-btn.menu-open svg line:nth-child(3) {
      transform: rotate(-45deg) translate(5px, -5px);
    }
    
    /* Mobile Overlay */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      z-index: 999;
      opacity: 0;
      transition: opacity 0.3s ease;
      -webkit-backdrop-filter: blur(4px);
      cursor: pointer;
      pointer-events: none; /* Standardmäßig nicht klickbar */
    }
    
    .mobile-overlay.active {
      display: block;
      opacity: 1;
      pointer-events: auto; /* Wenn aktiv, dann klickbar */
    }
    
    @media (max-width:700px){
      /* Mobile Menu Button anzeigen */
      .mobile-menu-btn {
        display: flex !important;
        align-items: center;
        justify-content: center;
        /* Sicherstellen dass Button immer klickbar ist */
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Sidebar als Overlay auf Mobile */
      .sidebar { 
        position: fixed !important;
        top: 0;
        left: 0;
        height: 100vh;
        z-index: 1000;
        width: 280px;
        max-width: 70vw;
        overflow-y: auto;
        overflow-x: hidden; /* WICHTIG: Verhindert horizontales Scrollen */
        transform: translateX(-110%) !important; /* -110% für 100% sicher versteckt */
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Shadow auch animieren */
        box-shadow: none; /* Kein Shadow wenn versteckt */
        background: linear-gradient(180deg, var(--card), rgba(11,18,32,0.98));
        /* Verbessertes Touch-Scrolling */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        touch-action: pan-y; /* NUR vertikales Scrollen erlaubt */
        border-radius: 0;
        margin: 0;
        padding: 12px;
        pointer-events: none; /* Nicht klickbar wenn versteckt */
        visibility: hidden; /* Versteckt für Screen Reader */
        opacity: 0; /* Zusätzlich unsichtbar */
      }
      
      .sidebar.mobile-visible {
        transform: translateX(0) !important; /* Sidebar wird sichtbar */
        pointer-events: auto; /* Klickbar wenn sichtbar */
        visibility: visible; /* Sichtbar für Screen Reader */
        opacity: 1; /* Vollständig sichtbar */
        box-shadow: 4px 0 24px rgba(0,0,0,0.6); /* Shadow nur wenn sichtbar */
      }
      
      /* WICHTIG: Verhindere versehentliche Klicks beim Scrollen in Sidebar */
      .sidebar button,
      .sidebar a,
      .sidebar .section,
      .sidebar [onclick] {
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* MOBILE: Kompaktere Brand-Section */
      .sidebar .brand {
        margin-bottom: 8px;
      }
      
      .sidebar .brand .logo {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }
      
      .sidebar .brand h1 {
        font-size: 14px;
      }
      
      .sidebar .brand p {
        font-size: 11px;
      }
      
      /* MOBILE: Kompaktere Navigation */
      .sidebar .nav {
        gap: 4px;
        margin-top: 8px;
      }
      
      .sidebar .nav button {
        padding: 8px 10px;
        font-size: 14px;
        min-height: auto;
        /* Verhindere versehentliche Klicks beim Scrollen */
        touch-action: manipulation; /* Optimiert Touch-Events */
        user-select: none; /* Verhindert Text-Selection beim Scrollen */
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent; /* Entfernt Flash-Effekt */
      }
      
      .sidebar .nav button span:first-child {
        font-size: 18px;
      }
      
      /* MOBILE: Actions kompakter */
      .sidebar .actions {
        margin-top: 8px;
        padding-top: 8px;
      }
      
      .sidebar .actions .btn {
        font-size: 12px;
        padding: 8px 10px;
      }
      
      /* Verhindere Scrollen wenn Sidebar offen */
      body.sidebar-open {
        overflow: hidden;
      }
      
      /* Dimme den Hauptinhalt wenn Sidebar offen */
      .sidebar.mobile-visible ~ .mobile-overlay {
        display: block;
        opacity: 1;
      }
      
      /* Main wird verschoben wenn Sidebar offen */
      .app {
        position: relative;
        padding: 8px;
        gap: 12px;
      }
      
      /* Main Content Anpassungen */
      .main {
        padding-top: 70px;
        padding-left: 4px;
        padding-right: 4px;
      }
      
      /* NEU: Verstecke Karte (aside) auf Mobile, außer wenn map-full aktiv ist */
      .main aside {
        display: none;
      }
      
      .map-full .main aside {
        display: block;
      }
      
      /* NEU: Stelle sicher, dass Sections auf Mobile die volle Breite haben */
      .grid {
        grid-template-columns: 1fr !important;
        gap: 12px;
      }
      
      /* NEU: Bessere Lesbarkeit auf Mobile */
      body {
        font-size: 15px;
      }
      
      /* NEU: Größere Touch-Targets für Buttons */
      button, .btn, .small-btn {
        min-height: 44px;
        min-width: 44px;
        padding: 10px 14px;
        font-size: 14px;
      }
      
      /* NEU: Input-Felder größer */
      input, select, textarea {
        font-size: 16px;
        min-height: 44px;
        padding: 10px;
      }
      
      /* NEU: Navigation Buttons größer */
      .nav button {
        min-height: 48px;
        font-size: 15px;
        padding: 12px;
      }
      
      /* NEU: Card Padding anpassen */
      .card {
        padding: 14px;
      }
      
      /* NEU: Headline-Größen anpassen */
      h1 {
        font-size: 22px;
      }
      
      h2 {
        font-size: 18px;
      }
      
      h3 {
        font-size: 16px;
      }
      
      /* Topbar kompakter und vertikal auf Mobile */
      .topbar {
        position: relative;
        z-index: 1;
        flex-direction: column;
        gap: 10px;
      }
      
      .search {
        width: 100%;
      }
      
      .controls {
        width: 100%;
        flex-wrap: wrap;
        gap: 8px;
      }
      
      .controls select,
      .controls input {
        flex: 1 1 calc(50% - 4px);
        min-width: 120px;
        font-size: 14px;
      }
      
      /* Dashboard-Bereich auf Mobile */
      section[id="home"] {
        margin-top: 0;
      }
      
      /* Button-Container im Dashboard */
      section[id="home"] > div:first-child .card {
        margin-bottom: 12px;
      }
      
      /* Import/Export/Gruppe Buttons Grid auf Mobile */
      section[id="home"] > div:first-child > div:first-child {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }
      
      /* Alle Buttons volle Breite auf Mobile */
      section[id="home"] .btn,
      section[id="home"] .small-btn {
        width: 100%;
        text-align: center;
        justify-content: center;
      }
      
      /* Grid auf Mobile - immer einspaltig */
      .grid {
        grid-template-columns: 1fr !important;
        gap: 12px;
      }
      
      /* Filter Buttons */
      .small-btn {
        padding: 10px 14px;
        font-size: 13px;
        min-height: 44px; /* Touch-friendly */
        white-space: nowrap;
      }
      
      /* Buttons größer auf Mobile */
      .btn {
        min-height: 48px;
        padding: 12px 16px;
        font-size: 16px;
      }
      
      /* Cards auf Mobile */
      .card {
        padding: 14px;
      }
      
      .list-card {
        padding: 16px;
      }
      
      /* Map auf Mobile */
      #map {
        height: 350px;
      }
      
      /* Modals auf Mobile */
      .edit-modal-content {
        width: 95%;
        max-width: 100%;
        max-height: 90vh;
        margin: 5vh auto;
        overflow-y: auto;
      }
      
      /* Formulare auf Mobile */
      input[type="text"],
      input[type="date"],
      input[type="time"],
      input[type="number"],
      select,
      textarea {
        font-size: 16px; /* Verhindert Zoom auf iOS */
        min-height: 44px;
        padding: 10px 12px;
      }
      
      /* Form rows auf Mobile */
      .form-row {
        flex-direction: column;
        gap: 8px;
      }
      
      .form-row > * {
        flex: 1 1 100% !important;
        width: 100%;
      }
      
      /* GRUPPENVERGLEICH auf Mobile optimieren */
      #group-compare {
        padding: 8px !important;
      }
      
      /* Header kompakter */
      #group-compare > div:first-child {
        padding: 12px !important;
        margin-bottom: 12px !important;
      }
      
      #group-compare > div:first-child h2 {
        font-size: 18px !important;
      }
      
      #group-compare > div:first-child .muted,
      #group-compare > div:first-child p {
        font-size: 11px !important;
      }
      
      /* Tab-Buttons auf Mobile - einzeilig scrollbar */
      #group-compare > div:nth-child(2) {
        flex-wrap: nowrap !important;
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch !important;
        padding: 8px !important;
        gap: 6px !important;
        margin-bottom: 12px !important;
      }
      
      #group-compare .small-btn {
        min-width: 100px !important;
        flex-shrink: 0 !important;
        padding: 8px 10px !important;
        font-size: 12px !important;
        white-space: nowrap !important;
      }
      
      /* Grid Layouts auf Mobile - immer 1 Spalte */
      #group-compare [style*="grid-template-columns"] {
        grid-template-columns: 1fr !important;
      }
      
      /* Leaderboard Cards kompakter */
      #group-compare .card {
        padding: 12px !important;
        margin-bottom: 12px !important;
      }
      
      #group-compare .card h3 {
        font-size: 16px !important;
      }
      
      #group-compare .card h4 {
        font-size: 14px !important;
      }
      
      /* User/Member Cards im Leaderboard */
      #group-compare .card > div > div {
        padding: 10px !important;
        font-size: 13px !important;
      }
      

      /* Observation Manager auf Mobile */
      .person-accordion-header {
        padding: 12px;
      }
      
      /* Active Filters auf Mobile */
      .active-filters-container {
        padding: 10px;
      }
      
      .filter-badge {
        font-size: 11px;
        padding: 6px 10px;
      }
      
      /* Listen-Grid auf Mobile */
      #listsGrid {
        grid-template-columns: 1fr !important;
      }
      
      /* Species Database auf Mobile */
      #speciesDatabase > div {
        grid-template-columns: 1fr !important;
      }
      
      /* GRUPPENVERGLEICH - Mobile Optimierungen */
      
      /* Gruppenvergleich Header kompakter */
      #group-compare > div:first-child {
        padding: 16px !important;
        margin-bottom: 16px !important;
      }
      
      #group-compare h2 {
        font-size: 20px !important;
      }
      
      /* Tab Navigation auf Mobile - scrollbar statt wrap */
      #group-compare > div:nth-child(2) {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        flex-wrap: nowrap !important;
        padding: 8px !important;
        gap: 6px !important;
      }
      
      #group-compare > div:nth-child(2)::-webkit-scrollbar {
        height: 4px;
      }
      
      #group-compare > div:nth-child(2)::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 2px;
      }
      
      /* Tab Buttons kompakter auf Mobile */
      #group-compare .small-btn {
        flex: 0 0 auto !important;
        min-width: 120px !important;
        padding: 8px 12px !important;
        font-size: 12px !important;
        white-space: nowrap;
      }
      
      /* Leaderboards auf Mobile */
      #compareObservationsView > div:first-child {
        grid-template-columns: 1fr !important;
      }
      
      /* Leaderboard Einträge kompakter */
      .card > div > div:first-child {
        flex-direction: column;
        align-items: flex-start !important;
      }
      
      /* Member comparison grid */
      #memberComparisonGrid {
        grid-template-columns: 1fr !important;
      }
      
      /* Rarität-Challenge auf Mobile */
      #compareRarity2026View > div:first-child {
        padding: 16px !important;
      }
      
      #compareRarity2026View h2 {
        font-size: 22px !important;
      }
      
      /* Punktesystem Box scrollbar */
      #compareRarity2026View > div:first-child > div:last-child {
        max-width: 100% !important;
        overflow-x: auto;
      }
      
      /* Jahr-Auswahl zentriert */
      #compareRarity2026View select {
        font-size: 14px !important;
        padding: 8px 12px !important;
      }
      
      /* Statistik-Karten auf Mobile */
      #compareStatsView > div:last-child {
        grid-template-columns: 1fr !important;
      }
      
      /* Stats Grid kompakter */
      #rarityDetailedStats2026 > div:first-child {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 8px !important;
      }
      
      /* Details-Buttons volle Breite */
      button[onclick*="toggleRarityDetails"] {
        width: 100% !important;
        margin-top: 10px !important;
      }
      
      /* Observation Card Buttons kompakter */
      .card button.small-btn {
        font-size: 10px !important;
        padding: 6px 8px !important;
        white-space: nowrap;
      }
      
      /* Photo preview responsive */
      .edit-photo-preview img,
      .observation-popup-photo,
      img[style*="border-radius"] {
        max-width: 100% !important;
        height: auto !important;
      }
      
      /* Observation Details kompakter */
      .card[style*="border-left"] > div > div:nth-child(2) > div:nth-child(2) {
        font-size: 11px !important;
      }
      
      /* Observation Details auf Mobile */
      .observation-species {
        font-size: 15px !important;
      }
      
      /* Marker List auf Mobile */
      .marker-list {
        max-height: 200px;
      }
      
      /* Icons etwas kleiner auf Mobile */
      #group-compare [style*="font-size:28px"],
      #group-compare [style*="font-size: 28px"] {
        font-size: 24px !important;
      }
      
      #group-compare [style*="font-size:56px"],
      #group-compare [style*="font-size: 56px"] {
        font-size: 48px !important;
      }
      
      /* Challenge Cards auf Mobile */
      #availableChallengesGrid {
        grid-template-columns: 1fr !important;
      }
      
      /* Tabellen scrollbar auf Mobile */
      table {
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        white-space: nowrap;
      }
      
      table thead {
        display: table;
        width: 100%;
        table-layout: fixed;
      }
      
      table tbody {
        display: table;
        width: 100%;
        table-layout: fixed;
      }
      
      /* Tabellenzeilen kleiner auf Mobile */
      table td, table th {
        padding: 8px 6px !important;
        font-size: 12px !important;
      }
      
      /* Overflow Container für Statistiken */
      #rarityDetailedStats2026 > div:last-child,
      #detailedObservationComparison,
      #detailedAchievementComparison {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Canvas Container auf Mobile */
      #canvasContainer {
        min-height: 300px;
        padding: 12px;
      }
      
      #chartCanvas {
        height: 280px !important;
      }
      
      /* Aside (Karte & Filter) auf Mobile */
      aside {
        order: -1; /* Karte nach oben auf Mobile */
        width: 100%;
      }
      
      /* Filter System kompakter */
      .filter-system .filter-group {
        margin-bottom: 10px;
      }
      
      .filter-system label {
        font-size: 13px;
        margin-bottom: 4px;
      }
      
      /* Quick Stats kompakter */
      #quickStats {
        font-size: 12px;
      }
      
      /* Marker List Items kompakter */
      .marker-item {
        font-size: 12px;
        padding: 8px;
      }
      
      /* Karten-Buttons scrollbar */
      #mapCard .form-row {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        flex-wrap: nowrap;
        gap: 6px;
      }
      
      #mapCard .small-btn {
        flex-shrink: 0;
        min-width: auto;
      }
      
      /* Floating Action Button auf Mobile */
      .fab-quick-add {
        bottom: 80px; /* Höher wegen Mobile Navigation */
        right: 16px;
        width: 56px;
        height: 56px;
        font-size: 24px;
      }
      
      .fab-quick-add::after {
        display: none; /* Kein Tooltip auf Mobile */
      }
      
      /* Quick Add Modal auf Mobile */
      #quickAddModal > div {
        width: 95% !important;
        max-width: 95vw !important;
        padding: 20px !important;
      }
      
      #quickAddModal h3 {
        font-size: 18px !important;
      }
      
      #quickAddModal input {
        font-size: 16px !important; /* Verhindert iOS Zoom */
      }
      
      /* Toast Notifications auf Mobile */
      .toast {
        bottom: 90px;
        right: 16px;
        left: 16px;
        font-size: 14px;
      }
    }
    
    /* Extra kleine Bildschirme */
    
    /* NEU: Spezielle Anpassungen für Portrait-Modus (Hochformat) auf Smartphones */
    @media (max-width: 480px) and (orientation: portrait) {
      /* Noch kompaktere Schriften im Portrait */
      body {
        font-size: 14px;
      }
      
      h1 {
        font-size: 20px;
      }
      
      h2 {
        font-size: 17px;
      }
      
      h3 {
        font-size: 15px;
      }
      
      .brand h1 {
        font-size: 15px;
      }
      
      .brand p {
        font-size: 11px;
      }
      
      /* Kompaktere Cards */
      .card {
        padding: 12px;
      }
      
      /* Kompaktere Buttons */
      button, .btn, .small-btn {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      /* Navigation noch kompakter */
      .nav button {
        padding: 10px;
        font-size: 14px;
      }
      
      /* App-Padding reduzieren */
      .app {
        padding: 6px;
        gap: 10px;
      }
      
      .main {
        padding-top: 65px;
      }
      
      /* Hamburger-Button kleiner */
      .mobile-menu-btn {
        width: 44px;
        height: 44px;
        top: 12px;
        left: 12px;
      }
      
      /* Grid-Gap reduzieren */
      .grid {
        gap: 10px;
      }
      
      /* Topbar kompakter */
      .topbar {
        gap: 8px;
      }
      
      /* Input-Felder kompakter aber noch touch-freundlich */
      input, select, textarea {
        font-size: 16px;
        padding: 8px;
        min-height: 42px;
      }
      
      /* Logo kleiner */
      .logo {
        width: 38px;
        height: 38px;
        font-size: 16px;
      }
      
      /* Controls kompakter */
      .controls select,
      .controls input {
        font-size: 13px;
        padding: 8px;
      }
      
      /* Formulare kompakter */
      .form-row {
        gap: 6px;
      }
      
      /* Statistik-Karten anpassen */
      .stat-grid {
        gap: 8px;
      }
      
      /* Beobachtungsliste kompakter */
      .obs-list-item {
        padding: 10px;
        font-size: 13px;
      }
      
      /* Tabellen scrollbar und kompakt */
      table {
        font-size: 12px;
      }
      
      table th,
      table td {
        padding: 8px 6px;
      }
      
      /* Modal-Inhalte anpassen */
      .modal-content {
        padding: 16px;
        max-width: 95%;
      }
      
      /* Chart-Container anpassen */
      #chartCanvas {
        max-height: 250px;
      }
      
      /* Karten-Container */
      #map {
        height: 300px !important;
      }
    }
    
    @media (max-width:400px){
      .app {
        padding: 8px;
        gap: 12px;
      }
      
      /* SIDEBAR - Extra kompakt für sehr kleine Bildschirme */
      .sidebar {
        max-width: 65vw !important; /* Noch schmaler auf sehr kleinen Screens */
        padding: 10px !important;
      }
      
      .sidebar .brand .logo {
        width: 32px !important;
        height: 32px !important;
        font-size: 14px !important;
      }
      
      .sidebar .brand h1 {
        font-size: 13px !important;
      }
      
      .sidebar .brand p {
        font-size: 10px !important;
      }
      
      .sidebar .nav {
        gap: 2px !important;
      }
      
      .sidebar .nav button {
        padding: 6px 8px !important;
        font-size: 13px !important;
      }
      
      .sidebar .nav button span:first-child {
        font-size: 16px !important;
      }
      
      .mobile-menu-btn {
        top: 12px;
        left: 12px;
        width: 44px;
        height: 44px;
      }
      
      .brand h1 {
        font-size: 14px;
      }
      
      .controls select,
      .controls input {
        flex: 1 1 100%;
      }
      
      /* Cards noch kompakter */
      .card {
        padding: 10px;
      }
      
      /* Buttons kompakter */
      .small-btn {
        padding: 8px 10px;
        font-size: 11px;
      }
      
      /* Gruppenvergleich kompakter */
      #group-compare h2 {
        font-size: 18px !important;
      }
      
      #group-compare h3 {
        font-size: 16px !important;
      }
      
      /* Tab Buttons noch kleiner */
      #group-compare .small-btn {
        min-width: 100px !important;
        padding: 6px 10px !important;
        font-size: 11px !important;
      }
      
      /* Raritäten Challenge Titel */
      #compareRarity2026View h2 {
        font-size: 20px !important;
      }
      
      /* Stats Grid einspaltig auf sehr kleinen Screens */
      #rarityDetailedStats2026 > div:first-child {
        grid-template-columns: 1fr !important;
      }
      
      /* Form rows einzeln */
      .form-row {
        gap: 6px;
      }
      
      /* Map kleiner */
      #map {
        height: 280px;
      }
    }
    
    /* Mobile Landscape Optimierung - Querformat */
    @media (max-width: 900px) and (orientation: landscape) {
      .sidebar {
        max-width: 50vw !important; /* Im Querformat noch schmaler */
        padding: 10px !important;
      }
      
      .sidebar .brand .logo {
        width: 32px !important;
        height: 32px !important;
      }
      
      .sidebar .brand h1 {
        font-size: 13px !important;
      }
      
      .sidebar .brand p {
        display: none; /* Untertitel verstecken im Querformat */
      }
      
      .sidebar .nav {
        gap: 2px !important;
      }
      
      .sidebar .nav button {
        padding: 6px 8px !important;
        font-size: 13px !important;
      }
      
      .sidebar .actions {
        margin-top: 6px !important;
      }
    }

    /* Tiny helpers */
    .kpi { display:flex; gap:12px; align-items:center; }
    .kpi .value { font-size:20px; font-weight:700; }
    .footer-note { color:var(--muted); font-size:13px; margin-top:8px; }
    
    /* NEU: Active Filters Display */
    .active-filters-container {
      margin-bottom: 12px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(6,182,212,0.08), rgba(124,58,237,0.04));
      border-radius: 10px;
      border: 1px solid rgba(6,182,212,0.2);
      display: none;
    }
    
    .active-filters-container.has-filters {
      display: block;
    }
    
    .active-filters-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .active-filters-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .clear-all-filters-btn {
      background: rgba(239,68,68,0.1);
      color: var(--danger);
      border: 1px solid rgba(239,68,68,0.2);
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .clear-all-filters-btn:hover {
      background: rgba(239,68,68,0.2);
      transform: scale(1.05);
    }
    
    .filter-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    
    .filter-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, rgba(6,182,212,0.15), rgba(124,58,237,0.1));
      color: var(--light-text);
      padding: 6px 10px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      border: 1px solid rgba(6,182,212,0.3);
      cursor: default;
      transition: all 0.2s;
    }
    
    .filter-badge:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(6,182,212,0.3);
    }
    
    .filter-badge-remove {
      background: rgba(255,255,255,0.1);
      border: none;
      color: var(--light-text);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
      padding: 0;
      transition: all 0.2s;
    }
    
    .filter-badge-remove:hover {
      background: var(--danger);
      transform: scale(1.1);
    }
    
    /* Enhanced Seen/Unseen Species Indicators */
    .species-seen-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      box-shadow: 0 4px 12px rgba(16,185,129,0.4);
      display: flex;
      align-items: center;
      gap: 4px;
      animation: seenPulse 2s ease-in-out infinite;
    }
    
    @keyframes seenPulse {
      0%, 100% { box-shadow: 0 4px 12px rgba(16,185,129,0.4); }
      50% { box-shadow: 0 4px 16px rgba(16,185,129,0.6); }
    }
    
    .species-unseen-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      border: 1px solid rgba(255,255,255,0.06);
    }
    
    .species-card-seen {
      border: 2px solid rgba(16,185,129,0.5) !important;
      background: linear-gradient(135deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03)) !important;
      box-shadow: 0 4px 16px rgba(16,185,129,0.15) !important;
    }
    
    .species-card-unseen {
      border: 1px solid rgba(255,255,255,0.04) !important;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) !important;
      opacity: 0.7;
    }
    
    .species-card-unseen:hover {
      opacity: 0.85;
    }
    
    .species-count-seen {
      background: linear-gradient(90deg, rgba(16,185,129,0.15), rgba(5,150,105,0.1));
      color: #10b981;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 700;
      border: 1px solid rgba(16,185,129,0.3);
    }
    
    .species-count-unseen {
      color: var(--muted);
      font-weight: 500;
      font-style: italic;
    }
    
    /* Group Member Badges */
    .group-members-seen {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.04);
    }
    
    .member-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      background: linear-gradient(135deg, rgba(124,58,237,0.2), rgba(6,182,212,0.2));
      color: var(--text);
      border: 1px solid rgba(124,58,237,0.3);
    }
    
    .member-badge.me {
      background: linear-gradient(135deg, rgba(16,185,129,0.3), rgba(5,150,105,0.2));
      border-color: rgba(16,185,129,0.4);
      color: #10b981;
      font-weight: 700;
    }
    
    .all-members-badge {
      background: linear-gradient(135deg, rgba(251,191,36,0.3), rgba(245,158,11,0.2));
      border: 1px solid rgba(251,191,36,0.4);
      color: #fbbf24;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* Observation Manager Filter Buttons */
    .obs-filter-btn {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      transition: all 0.2s;
    }
    
    .obs-filter-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    
    .obs-filter-btn:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.12);
    }
    
    /* Status Filter Labels */
    #tickableFilterLabel:hover {
      background: rgba(16,185,129,0.15);
      border-color: rgba(16,185,129,0.3) !important;
    }
    
    #selffoundFilterLabel:hover {
      background: rgba(239,68,68,0.15);
      border-color: rgba(239,68,68,0.3) !important;
    }
    
    /* List View Toggle Buttons */
    .list-view-btn:hover {
      background: rgba(255,255,255,0.05);
    }
    
    .list-view-btn.active {
      background: var(--accent);
      color: white;
    }

    /* Import Progress Bar */
    .import-progress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    
    .import-progress-overlay.active {
      display: flex;
    }
    
    .import-progress-content {
      background: var(--card);
      border-radius: 16px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .import-progress-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .import-progress-subtitle {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 24px;
    }
    
    .import-progress-bar-container {
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    
    .import-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .import-progress-text {
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }
    
    .import-progress-details {
      text-align: center;
      font-size: 12px;
      color: var(--muted);
    }
    
    .import-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Bearbeitungs-Modal */
    .edit-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
      overflow-y: auto;
    }
    
    .edit-modal.active {
      display: flex;
    }
    
    .edit-modal-content {
      background: var(--card);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      max-width: 700px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      animation: modalSlideIn 0.3s ease;
    }
    
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .edit-modal-header {
      padding: 24px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, rgba(124,58,237,0.08), rgba(6,182,212,0.05));
    }
    
    .edit-modal-header h2 {
      margin: 0;
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .edit-modal-close {
      background: transparent;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: var(--muted);
      transition: all 0.2s ease;
      padding: 4px 8px;
      line-height: 1;
    }
    
    .edit-modal-close:hover {
      color: var(--text);
      transform: scale(1.1);
    }
    
    .edit-modal-body {
      padding: 24px;
    }
    
    .edit-form-group {
      margin-bottom: 16px;
    }
    
    .edit-form-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .edit-form-input {
      width: 100%;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 10px 12px;
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    .edit-form-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(255,255,255,0.04);
    }
    
    .edit-photo-preview {
      margin-top: 12px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
    }
    
    .edit-photo-preview img {
      width: 100%;
      height: 200px;
      object-fit: contain;
      background: rgba(0,0,0,0.2);
    }
    
    .edit-photo-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    
    .edit-modal-footer {
      padding: 20px 24px;
      border-top: 1px solid rgba(255,255,255,0.05);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    /* Zusammenklappbare Personen-Bereiche */
    .person-accordion {
      margin-bottom: 16px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.05);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .person-accordion:hover {
      border-color: rgba(255,255,255,0.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .person-accordion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      cursor: pointer;
      background: linear-gradient(90deg, rgba(124,58,237,0.08), rgba(6,182,212,0.05));
      border-bottom: 1px solid rgba(255,255,255,0.03);
      transition: all 0.2s ease;
    }
    
    .person-accordion-header:hover {
      background: linear-gradient(90deg, rgba(124,58,237,0.12), rgba(6,182,212,0.08));
    }
    
    .person-accordion-header.collapsed {
      border-bottom: none;
    }
    
    .person-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    
    .person-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 700;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .person-details {
      flex: 1;
    }
    
    .person-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 2px;
    }
    
    .person-stats {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      gap: 12px;
    }
    
    .person-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
      transition: all 0.2s ease;
    }
    
    .person-toggle-icon {
      font-size: 20px;
      transition: transform 0.3s ease;
    }
    
    .person-toggle-icon.expanded {
      transform: rotate(180deg);
    }
    
    .person-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease;
    }
    
    .person-accordion-content.expanded {
      max-height: 10000px;
    }
    
    .person-observations {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Vergleichsmodus Styles */
    .comparison-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .comparison-container {
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      max-width: 1400px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    }
    
    @media (max-width: 480px) {
      .comparison-modal {
        padding: 10px;
      }
      
      .comparison-container {
        padding: 16px;
        border-radius: 12px;
        max-height: 95vh;
      }
      
      .comparison-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .comparison-header h2 {
        font-size: 20px !important;
      }
      
      .comparison-header p {
        font-size: 13px !important;
      }
    }
    .comparison-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .comparison-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(100%, 280px), 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    
    /* Mobile-specific grid layout for member comparison */
    #memberComparisonGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(100%, 280px), 1fr));
      gap: 12px;
    }
    .member-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 16px;
      min-width: 0; /* Allow card to shrink below content width */
      overflow: hidden; /* Prevent content overflow */
    }
    .member-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }
    .member-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: white;
      font-size: 20px;
    }
    .comparison-stats {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
    }
    .stat-label {
      color: var(--muted);
      font-size: 13px;
    }
    .stat-value {
      font-weight: 600;
      font-size: 16px;
      word-break: break-word;
      overflow-wrap: break-word;
      max-width: 100%;
    }
    
    /* XP Badge */
    .xp-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }
    .xp-notification {
      position: fixed;
      top: 80px;
      right: 20px;
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
      z-index: 3000;
      animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s;
      font-weight: 600;
    }
    @keyframes slideIn {
      from { transform: translateX(400px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(400px); opacity: 0; }
    }
    
    /* Challenge Creator Modal */
    .challenge-creator-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
    }
    .challenge-creator-container {
      background: var(--card);
      border-radius: 16px;
      padding: 28px;
      max-width: 700px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    }
    .challenge-creator-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .form-group {
      margin-bottom: 20px;
    }
    .form-group label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }
    .form-group .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
    .icon-selector {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .icon-option {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      background: rgba(255,255,255,0.02);
      border: 2px solid rgba(255,255,255,0.05);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .icon-option:hover {
      background: rgba(255,255,255,0.05);
      transform: scale(1.05);
    }
    .icon-option.selected {
      border-color: var(--accent);
      background: rgba(6,182,212,0.1);
    }
    .color-selector {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .color-option {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.2s;
    }
    .color-option:hover {
      transform: scale(1.1);
    }
    .color-option.selected {
      border-color: white;
      box-shadow: 0 0 0 2px var(--card), 0 0 0 4px white;
    }
    .tier-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    .tier-option {
      padding: 12px;
      text-align: center;
      background: rgba(255,255,255,0.02);
      border: 2px solid rgba(255,255,255,0.05);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 13px;
    }
    .tier-option:hover {
      background: rgba(255,255,255,0.05);
    }
    .tier-option.selected {
      border-color: var(--accent);
      background: rgba(6,182,212,0.1);
    }
    .range-input {
      width: 100%;
    }
    .range-value {
      display: inline-block;
      margin-left: 12px;
      font-weight: 600;
      color: var(--accent);
      min-width: 50px;
    }
    .condition-builder {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 16px;
      margin-top: 8px;
    }
    .condition-row {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 8px;
      margin-bottom: 8px;
    }
    .add-condition-btn {
      width: 100%;
      margin-top: 8px;
    }
    
    /* Gruppen-Marker Legende */
    .group-legend {
      background: var(--card);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .group-legend-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      font-size: 12px;
      border-radius: 4px;
      margin-bottom: 4px;
    }
    .legend-item:hover {
      background: rgba(255,255,255,0.02);
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .legend-name {
      flex: 1;
      color: var(--text);
    }
    .legend-count {
      color: var(--muted);
      font-size: 11px;
    }
    
    /* Listen-Vergleichs-System */
    .comparison-folder-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.05), rgba(124,58,237,0.03));
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(255,255,255,0.06);
      margin-bottom: 16px;
      transition: all 0.3s;
    }
    .comparison-folder-card:hover {
      border-color: var(--accent);
      box-shadow: 0 4px 12px rgba(6,182,212,0.2);
    }
    .comparison-folder-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .comparison-folder-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }
    .comparison-folder-stats {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--muted);
    }
    .list-comparison-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .compared-list-card {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 14px;
      border: 2px solid rgba(255,255,255,0.04);
      position: relative;
      transition: all 0.2s;
    }
    .compared-list-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    .compared-list-card.winner {
      border-color: #ffd700;
      background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.02));
    }
    .winner-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #000;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      box-shadow: 0 2px 8px rgba(255,215,0,0.4);
    }
    .list-owner-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: rgba(124,58,237,0.15);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-2);
    }

    /* Tooltip label styling */
    .leaflet-tooltip.marker-label {
      background: rgba(255,255,255,0.95);
      color: #0f172a;
      border: 1px solid rgba(0,0,0,0.08);
      padding: 4px 8px;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
      font-weight: 600;
      white-space: nowrap;
    }

    /* Popup styling for detailed observation info */
    .leaflet-popup-content-wrapper {
      background: var(--card);
      color: var(--text);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      padding: 0;
      min-width: 280px;
    }
    .leaflet-popup-content {
      margin: 0;
      width: auto !important;
    }
    .leaflet-popup-tip {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.06);
    }
    .observation-popup {
      padding: 16px;
    }
    .observation-popup-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .observation-popup-icon {
      width: 48px;
      height: 48px;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
    }
    .observation-popup-title {
      flex: 1;
    }
    .observation-popup-title h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
      color: var(--light-text);
    }
    .observation-popup-title .date {
      margin: 2px 0 0 0;
      font-size: 12px;
      color: var(--muted);
    }
    .observation-popup-section {
      margin-top: 12px;
    }
    .observation-popup-section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--muted);
      margin-bottom: 6px;
      font-weight: 600;
    }
    .observation-popup-value {
      font-size: 14px;
      color: var(--text);
      padding: 6px 10px;
      background: var(--glass);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .observation-popup-photo {
      width: 100%;
      border-radius: 8px;
      margin-top: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      max-height: 500px;
      height: auto;
      object-fit: contain;
      background: rgba(0,0,0,0.3);
      cursor: pointer;
      transition: transform 0.2s;
    }
    .observation-popup-photo:hover {
      transform: scale(1.02);
    }
    .observation-popup-coords {
      display: flex;
      gap: 8px;
      margin-top: 6px;
    }
    .observation-popup-coord {
      flex: 1;
      background: var(--glass);
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.02);
      font-size: 13px;
      text-align: center;
    }
    .observation-popup-coord-label {
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 2px;
    }
    .observation-popup-coord-value {
      font-weight: 600;
      color: var(--text);
    }

    /* Eingabetabelle */
    .input-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    .input-table th, .input-table td {
      padding: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
      text-align: left;
    }
    .input-table th {
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
    }
    .map-point-indicator {
      color: var(--accent);
      cursor: pointer;
      font-size: 16px;
    }

    /* Chart Info */
    .chart-info {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .chart-stat {
      background: var(--glass);
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.02);
      font-size: 13px;
    }
    .chart-stat .value {
      font-weight: 700;
      color: var(--accent);
    }

    /* Chart Controls */
    .chart-controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 16px;
      padding: 16px;
      background: var(--glass);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      color: var(--text);
    }
    .slider-label .value {
      font-weight: 600;
      color: var(--accent);
      min-width: 80px;
      text-align: right;
    }
    .slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255,255,255,0.05);
      border-radius: 3px;
      outline: none;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--card);
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--card);
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .aggregation-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .agg-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      color: var(--soft);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }
    .agg-btn:hover {
      background: rgba(255,255,255,0.04);
      color: var(--text);
    }
    .agg-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .preset-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .preset-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      color: var(--soft);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }
    .preset-btn:hover {
      background: rgba(255,255,255,0.04);
      color: var(--text);
    }
    .preset-btn.active {
      background: var(--accent-2);
      color: white;
      border-color: var(--accent-2);
    }

    /* Neue Features - Allgemein */
    .feature-section {
      margin-top: 20px;
      border-top: 1px solid rgba(255,255,255,0.02);
      padding-top: 16px;
    }
    
    /* Arten-Datenbank */
    .species-info {
      background: var(--glass);
      padding: 12px;
      border-radius: 8px;
      margin-top: 8px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    .species-details {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    .species-detail {
      font-size: 13px;
    }
    .species-detail .label {
      color: var(--muted);
      font-size: 12px;
    }
    
    /* Wetter Anzeige */
    .weather-info {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--glass);
      border-radius: 8px;
      margin-top: 8px;
    }
    .weather-icon {
      font-size: 24px;
    }
    
    /* Filter System */
    .filter-system {
      background: var(--glass);
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .filter-group {
      margin-bottom: 12px;
    }
    .filter-group label {
      display: block;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    /* Heatmap Controls */
    .heatmap-controls {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    
    /* Import/Export */
    .import-export {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    
    /* Top Arten Liste */
    .top-species-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }
    .top-species-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: var(--glass);
      border-radius: 8px;
    }
    .top-species-item span.rare,
    .top-species-item span.very-rare,
    .top-species-item span.escape {
      font-weight: 600;
    }
    .top-species-item span.rare {
      color: #ef4444;
    }
    .top-species-item span.very-rare {
      color: #dc2626;
    }
    .top-species-item span.escape {
      color: #3b82f6;
    }
    .species-count {
      background: var(--accent);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }
    
    /* Bild Upload - OPTIMIERT */
    .image-upload {
      margin-top: 8px;
      max-width: 100%;
      overflow: hidden;
    }
    .image-preview {
      width: 100%;
      max-height: 300px;
      object-fit: contain;
      border-radius: 8px;
      margin-top: 8px;
      display: none;
      background: var(--glass);
      padding: 8px;
      box-sizing: border-box;
    }
    
    /* Notification System */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card);
      color: var(--text);
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10000;
      font-size: 14px;
      max-width: 300px;
      opacity: 1;
      transition: opacity 0.3s;
    }
    
    /* KI-Assistent - ENTFERNT */
    .ai-assistant {
      display: none !important;
    }
    .ai-suggestion {
      display: none !important;
    }
    
    /* Druckoptimierung */
    @media print {
      .no-print { display: none !important; }
      .print-only { display: block !important; }
      body { background: white !important; color: black !important; }
      .card { box-shadow: none !important; border: 1px solid #ddd !important; }
    }
    
    /* Progress Bar */
    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.05);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }
    .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }
    
    /* Checkbox für leere Tage */
    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    .checkbox-container input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    /* Ordner Farb-Indikator */
    .folder-color-indicator {
      transition: all 0.2s;
      border: 2px solid rgba(255,255,255,0.1);
      cursor: pointer;
    }
    .folder-color-indicator:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .folder {
      transition: border-left-color 0.3s;
    }

    /* Listen-Sektion - Modernes Design */
    .lists-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .lists-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }
    
    .list-card {
      background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 16px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.03);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .list-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      border-radius: 4px 0 0 4px;
    }
    
    .list-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(2,6,23,0.4);
      border-color: rgba(255,255,255,0.05);
    }
    
    /* NEU: Angepinnte Listen */
    .list-card.pinned-list {
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.05));
      animation: pinGlow 3s ease-in-out infinite;
    }
    
    @keyframes pinGlow {
      0%, 100% {
        box-shadow: 0 8px 24px rgba(6,182,212,0.3);
      }
      50% {
        box-shadow: 0 8px 32px rgba(6,182,212,0.5);
      }
    }
    
    .pin-indicator {
      position: absolute;
      top: 12px;
      right: 12px;
      font-size: 24px;
      opacity: 0.8;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
      z-index: 1;
      animation: pinBounce 2s ease-in-out infinite;
    }
    
    @keyframes pinBounce {
      0%, 100% {
        transform: translateY(0) rotate(-15deg);
      }
      50% {
        transform: translateY(-4px) rotate(-20deg);
      }
    }
    
    .pinned-btn {
      transition: all 0.2s ease;
    }
    
    .pinned-btn:hover {
      transform: scale(1.1) rotate(15deg);
    }
    
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }
    
    .list-title {
      font-size: 18px;
      font-weight: 700;
      margin: 0;
      color: var(--text);
      line-height: 1.3;
    }
    
    .list-badge {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .list-description {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 16px;
      min-height: 40px;
    }
    
    .list-stats {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }
    
    .stat-value {
      font-size: 20px;
      font-weight: 700;
      color: var(--accent);
    }
    
    .stat-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .list-actions {
      display: flex;
      gap: 8px;
      margin-top: auto;
    }
    
    .list-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
    }
    
    .list-tag {
      background: rgba(255,255,255,0.03);
      color: var(--soft);
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    
    .empty-state {
      text-align: center;
      padding: 60px 20px;
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    .empty-state-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }
    
    .empty-state-description {
      color: var(--muted);
      font-size: 14px;
      max-width: 400px;
      margin: 0 auto 24px;
    }
    
    /* Neue Liste Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(2,6,23,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    
    .modal-content {
      background: var(--card);
      border-radius: 20px;
      padding: 32px;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 20px 40px rgba(2,6,23,0.6);
    }
    
    .modal-header {
      margin-bottom: 24px;
    }
    
    .modal-title {
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 8px 0;
      color: var(--text);
    }
    
    .modal-subtitle {
      color: var(--muted);
      font-size: 14px;
      margin: 0;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }
    
    .form-hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
    
    .tag-input {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px;
      min-height: 44px;
    }
    
    .tag-input input {
      flex: 1;
      min-width: 100px;
      background: transparent;
      border: none;
      color: var(--text);
      outline: none;
      font-size: 14px;
    }
    
    .tag-pill {
      background: linear-gradient(135deg, var(--accent-2), var(--accent));
      color: white;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .tag-remove {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 0;
      font-size: 16px;
      line-height: 1;
    }
    
    .checkbox-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 8px;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .checkbox-item:hover {
      background: rgba(255,255,255,0.03);
      border-color: rgba(255,255,255,0.05);
    }
    
    .checkbox-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    
    .checkbox-label {
      font-size: 14px;
      color: var(--text);
      font-weight: 500;
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 32px;
      padding-top: 24px;
      border-top: 1px solid rgba(255,255,255,0.03);
    }
    
    /* Listen Detail View */
    .list-detail-view {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 9999;
      overflow-y: auto;
    }
    
    .list-detail-header {
      background: linear-gradient(135deg, var(--card), rgba(11,18,32,0.9));
      padding: 28px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .list-detail-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 20px;
    }
    
    .list-observations-table {
      padding: 28px;
    }
    
    .observation-row {
      display: flex;
      align-items: center;
      padding: 16px;
      background: rgba(255,255,255,0.01);
      border-radius: 12px;
      margin-bottom: 8px;
      border: 1px solid rgba(255,255,255,0.02);
      transition: all 0.2s;
    }
    
    .observation-row:hover {
      background: rgba(255,255,255,0.02);
      transform: translateX(4px);
      border-color: rgba(255,255,255,0.04);
    }
    
    .observation-species {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      flex: 2;
    }
    
    /* Seltenheits-Indikatoren */
    .rarity-indicator {
      display: inline-block;
      margin-right: 6px;
      vertical-align: middle;
      width: 18px;
      height: 18px;
    }
    
    .rarity-indicator svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .observation-species.rare,
    .marker-item strong.rare {
      color: #ef4444 !important; /* Rot für seltene Arten */
      font-weight: 600;
    }
    
    .observation-species.very-rare,
    .marker-item strong.very-rare {
      color: #dc2626 !important; /* Dunkelrot für sehr seltene Arten */
      font-weight: 700;
    }
    
    .observation-species.escape,
    .marker-item strong.escape {
      color: #3b82f6 !important; /* Blau für Escape-Arten */
      font-weight: 600;
    }
    
    .detail-value.rare {
      color: #ef4444 !important;
      font-weight: 600;
    }
    
    .detail-value.very-rare {
      color: #dc2626 !important;
      font-weight: 700;
    }
    
    .detail-value.escape {
      color: #3b82f6 !important;
      font-weight: 600;
    }
    
    /* Eigenständige Klassen für Arten-DB */
    .rare {
      color: #ef4444 !important; /* Rot für seltene Arten */
      font-weight: 600;
    }
    
    .very-rare {
      color: #dc2626 !important; /* Dunkelrot für sehr seltene Arten */
      font-weight: 700;
    }
    
    .escape {
      color: #3b82f6 !important; /* Blau für Escape-Arten */
      font-weight: 600;
    }
    
    /* Toggle Buttons für Tickbar und Selffound */
    .obs-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.03);
      font-size: 16px;
    }
    
    .obs-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .obs-toggle.tickable {
      border-color: #10b981;
    }
    
    .obs-toggle.tickable.active {
      background: #10b981;
      color: white;
      border-color: #10b981;
    }
    
    .obs-toggle.selffound {
      border-color: #ef4444;
    }
    
    .obs-toggle.selffound.active {
      background: #ef4444;
      color: white;
      border-color: #ef4444;
    }
    
    .obs-toggle-container {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .observation-scientific {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }
    
    .observation-date {
      color: var(--muted);
      font-size: 14px;
      flex: 1;
    }
    
    .observation-location {
      color: var(--accent);
      font-size: 14px;
      flex: 1;
    }
    
    .observation-actions {
      display: flex;
      gap: 8px;
    }
    
    /* Beobachtungsübersicht */
    .observations-overview {
      margin-top: 20px;
    }

    .observation-card {
      background: var(--glass);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      border: 1px solid rgba(255,255,255,0.02);
      transition: all 0.2s;
      cursor: pointer;
    }

    .observation-card:hover {
      background: rgba(255,255,255,0.04);
      transform: translateX(4px);
      border-color: rgba(255,255,255,0.05);
    }

    .observation-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .observation-species {
      font-weight: 600;
      font-size: 16px;
      color: var(--text);
    }

    .observation-scientific {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .observation-date {
      font-size: 14px;
      color: var(--muted);
    }

    .observation-meta {
      display: flex;
      gap: 16px;
      margin-top: 8px;
      font-size: 13px;
    }

    .observation-meta-item {
      display: flex;
      align-items: center;
      gap: 4px;
      color: var(--soft);
    }

    .observation-meta-item.has-photo {
      cursor: pointer;
      color: var(--accent);
    }

    .observation-meta-item.has-photo:hover {
      color: var(--accent-2);
    }

    .observation-meta-item .icon {
      font-size: 14px;
    }

    /* Detail Map */
    #detailMap {
      width: 100%;
      height: 300px;
    }

    /* Beobachtungsdetails im Modal */
    .detail-row {
      display: flex;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
    }

    .detail-label {
      min-width: 120px;
      color: var(--muted);
      font-size: 14px;
    }

    .detail-value {
      flex: 1;
      font-weight: 500;
      font-size: 14px;
    }

    /* Filter für Beobachtungen */
    .observation-filters {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .observation-filter-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      color: var(--soft);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .observation-filter-btn:hover {
      background: rgba(255,255,255,0.04);
      color: var(--text);
    }

    .observation-filter-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Stelle sicher, dass Modals scrollbar sind für große Inhalte */
    #speciesGuideModal > div,
    #weatherModal > div,
    #createListModal .modal-content {
      max-height: 90vh;
      overflow-y: auto;
    }
    
    /* Speziell für das Wetter-Modal, das Bilder enthalten könnte */
    #weatherData {
      max-height: 400px;
      overflow-y: auto;
    }

    /* Responsive Optimierungen für Bildvorschau */
    @media (max-width: 768px) {
      .image-preview {
        max-height: 300px;
      }
      
      .observation-popup-photo {
        max-height: 400px;
      }
      
      /* Leaderboard Einträge auf Tablets */
      .card > div > div:first-child > div:first-child {
        font-size: 28px !important;
        width: 36px !important;
      }
      
      /* Punkte-Anzeige kompakter */
      .card > div > div:last-child > div:first-child {
        font-size: 32px !important;
      }
    }

    @media (max-width: 480px) {
      .image-preview {
        max-height: 250px;
      }
      
      .observation-popup-photo {
        max-height: 300px;
      }
      
      /* Leaderboard Medal/Number kompakter */
      .card > div > div:first-child > div:first-child {
        font-size: 24px !important;
        width: 32px !important;
        margin-top: 2px !important;
      }
      
      /* Namen und Stats untereinander statt nebeneinander */
      .card[style*="border-left"] > div {
        flex-direction: column !important;
        align-items: stretch !important;
      }
      
      /* Punkte-Box volle Breite auf Mobile */
      .card > div > div:last-child {
        width: 100% !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        text-align: left !important;
        margin-top: 12px !important;
        padding: 10px 12px !important;
        border-radius: 8px !important;
      }
      
      /* Punkte-Zahl kleiner auf Mobile */
      .card > div > div:last-child > div:first-child {
        font-size: 28px !important;
      }
      
      /* Stats Grid responsive */
      .card > div > div:nth-child(2) > div:nth-child(2) {
        grid-template-columns: 1fr 1fr !important;
      }
    }

    /* NEU: Ordnerauswahl Styling */
    #folderSelect option {
      padding: 8px;
      background: var(--card);
    }

    #folderSelect option:checked {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
    }

    .folder-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 6px;
      vertical-align: middle;
    }
    
    /* NEU: Flexbox für Ordnerauswahl-Container */
    .folder-select-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .folder-select-container select {
      flex: 1;
    }
    
    /* NEU: Farboptionen für Ordnererstellung */
    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .color-option:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    /* NEU: Foto-Lightbox Styling */
    .photo-lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10001;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    .photo-lightbox.active {
      display: flex;
    }
    
    .lightbox-photo {
      max-width: 90%;
      max-height: 80%;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
    
    .lightbox-caption {
      color: white;
      margin-top: 20px;
      text-align: center;
      font-size: 16px;
      max-width: 80%;
      padding: 0 20px;
    }
    
    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }
    
    .lightbox-close:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    
    .photo-thumbnail {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 6px;
      margin-left: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    
    .photo-thumbnail:hover {
      border-color: var(--accent);
      transform: scale(1.1);
    }
    
    .observation-meta-item.has-photo {
      cursor: pointer;
    }
    
    .observation-meta-item.has-photo:hover {
      color: var(--accent);
    }

    /* Detailansicht Foto klickbar */
    #detailPhoto {
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #detailPhoto:hover {
      transform: scale(1.02);
    }

    /* Polygon Styling */
    .polygon-creation {
      background: var(--glass);
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    
    .polygon-instructions {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 12px;
    }
    
    .polygon-points {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 12px;
      padding: 8px;
      background: rgba(255,255,255,0.01);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.02);
    }
    
    .polygon-point {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
      margin-bottom: 4px;
      font-size: 13px;
    }
    
    .polygon-point .coords {
      font-family: monospace;
      color: var(--accent);
    }
    
    .polygon-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    
    .polygon-status {
      font-size: 13px;
      color: var(--accent);
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .polygon-summary {
      background: rgba(6,182,212,0.1);
      border-left: 3px solid var(--accent);
      padding: 8px 12px;
      border-radius: 6px;
      margin-top: 12px;
      font-size: 13px;
    }
    
    /* Polygon auf Karte */
    .leaflet-polygon {
      stroke-width: 2;
      stroke: var(--accent);
      fill: rgba(6,182,212,0.1);
      fill-opacity: 0.3;
    }
    
    .leaflet-polygon:hover {
      stroke-width: 3;
      fill-opacity: 0.4;
    }
    
    /* Polygon in Listen-Detailansicht */
    .polygon-display {
      margin-top: 16px;
      padding: 12px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      border: 1px dashed rgba(255,255,255,0.1);
    }
    
    .polygon-display h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .polygon-coordinates {
      font-family: monospace;
      font-size: 11px;
      color: var(--muted);
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 100px;
      overflow-y: auto;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      margin-top: 8px;
    }
    
    /* Hybrid Map Labels - verbesserte Lesbarkeit */
    .leaflet-tile-pane .hybrid-labels {
      filter: invert(100%) contrast(1.2) brightness(0.9);
      mix-blend-mode: normal;
    }
    
    [data-theme="light"] .leaflet-tile-pane .hybrid-labels {
      filter: none;
      opacity: 0.45 !important;
    }
    
    /* Animationen für neue Challenges */
    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.05);
      }
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(30px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes bounceIn {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        transform: scale(0.9);
      }
      100% {
        transform: scale(1);
      }
    }
    
    @keyframes shimmer {
      0% {
        background-position: -1000px 0;
      }
      100% {
        background-position: 1000px 0;
      }
    }
    
    /* Skeleton Loader Styles */
    .skeleton {
      background: linear-gradient(
        90deg,
        rgba(255,255,255,0.02) 0%,
        rgba(255,255,255,0.08) 50%,
        rgba(255,255,255,0.02) 100%
      );
      background-size: 1000px 100%;
      animation: shimmer 2s infinite;
      border-radius: 8px;
    }
    
    .skeleton-text {
      height: 16px;
      margin-bottom: 8px;
    }
    
    .skeleton-title {
      height: 24px;
      width: 60%;
      margin-bottom: 12px;
    }
    
    .skeleton-card {
      height: 120px;
      margin-bottom: 12px;
    }
    
    /* Micro-interactions for buttons */
    .btn,
    .small-btn {
      position: relative;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .btn:active,
    .small-btn:active {
      transform: scale(0.96);
    }
    
    .btn::before,
    .small-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn:active::before,
    .small-btn:active::before {
      width: 300px;
      height: 300px;
    }
    
    /* Card hover effects */
    .card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(2,6,23,0.7);
    }
    
    /* Smooth transitions for theme switching */
    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    
    button,
    input,
    select,
    textarea {
      transition: all 0.2s ease !important;
    }
    
    /* Loading spinner */
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(6,182,212,0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Success/Error toast animations */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      z-index: 10002;
      animation: slideInFromRight 0.3s ease;
    }
    
    .toast.success {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }
    
    .toast.error {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }
    
    .toast.info {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
    }
    
    /* Enhanced focus states */
    input:focus,
    select:focus,
    textarea:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(6,182,212,0.1);
    }
    
    /* Floating Action Button for Quick Add */
    .fab-quick-add {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
      border: none;
      font-size: 28px;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(6,182,212,0.4);
      z-index: 1000;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .fab-quick-add:hover {
      transform: scale(1.1) rotate(90deg);
      box-shadow: 0 12px 32px rgba(6,182,212,0.5);
    }
    
    .fab-quick-add:active {
      transform: scale(0.95) rotate(90deg);
    }
    
    /* Tooltip for FAB */
    .fab-quick-add::after {
      content: 'Schnelleingabe (Strg+Q)';
      position: absolute;
      right: 72px;
      background: rgba(15,23,36,0.95);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .fab-quick-add:hover::after {
      opacity: 1;
    }
    
    /* Progress bar for loading states */
    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .progress-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 40%;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      animation: progress 1.5s infinite;
    }
    
    @keyframes progress {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(350%); }
    }
    
    /* Empty state illustrations */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      animation: fadeIn 0.5s ease;
    }
    
    .empty-state-icon {
      font-size: 72px;
      margin-bottom: 20px;
      animation: bounceIn 0.6s ease;
    }
    
    .empty-state-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }
    
    .empty-state-description {
      font-size: 14px;
      color: var(--muted);
      max-width: 400px;
      margin: 0 auto 24px;
      line-height: 1.6;
    }
    
    /* Notification badge */
    .notification-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: var(--danger);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      animation: pulse 2s infinite;
    }

    /* ==================== NEUE VERBESSERUNGEN ==================== */
    
    /* ULTRA-PERFORMANCE MODE: Instant Response */
    html {
      /* Snap scroll deaktivieren für instant response */
      scroll-behavior: auto;
    }
    
    /* Verhindere Layout Shifts */
    * {
      /* Kein Layout-Reflow bei Hover/Focus */
      box-sizing: border-box;
    }
    
    /* Optimiere Paint Performance */
    .card, .btn, button, .nav button {
      /* Browser kann früher mit Rendering beginnen */
      content-visibility: auto;
    }
    
    /* Verhindere unnötige Repaints */
    img, video {
      /* Images blockieren nicht Layout */
      content-visibility: auto;
      contain-intrinsic-size: 300px 200px;
    }
    
    /* Accessibility: Bessere Fokus-Indikatoren */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    select:focus-visible,
    textarea:focus-visible {
      outline: 3px solid var(--accent);
      outline-offset: 2px;
      transition: outline-offset 0.2s ease;
    }
    
    /* Skip to main content link für Screen Reader */
    .skip-to-main {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--accent);
      color: white;
      padding: 8px 16px;
      text-decoration: none;
      z-index: 10000;
      border-radius: 0 0 8px 0;
      font-weight: 600;
    }
    
    .skip-to-main:focus {
      top: 0;
    }
    
    /* ==================== LOADING STATES ==================== */
    .skeleton-loader {
      padding: 20px;
    }
    
    .skeleton-line {
      height: 20px;
      background: linear-gradient(
        90deg,
        rgba(255,255,255,0.05) 25%,
        rgba(255,255,255,0.15) 50%,
        rgba(255,255,255,0.05) 75%
      );
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s ease-in-out infinite;
      border-radius: 8px;
      margin: 12px 0;
    }
    
    .skeleton-line:first-child {
      width: 80%;
    }
    
    .skeleton-line:nth-child(2) {
      width: 60%;
    }
    
    .skeleton-line:nth-child(3) {
      width: 90%;
    }
    
    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    /* ==================== EMPTY STATES ==================== */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }
    
    .empty-icon {
      font-size: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    .empty-state h3 {
      font-size: 20px;
      color: var(--text);
      margin: 16px 0 8px 0;
    }
    
    .empty-state p {
      font-size: 14px;
      margin-bottom: 24px;
    }
    
    .empty-state button {
      margin-top: 16px;
    }
    
    /* ==================== ERROR STATES ==================== */
    .error-card {
      background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(239,68,68,0.05));
      border: 2px solid var(--danger);
      border-radius: var(--radius);
      padding: 24px;
      text-align: center;
      margin: 20px 0;
    }
    
    .error-card h3 {
      color: var(--danger);
      margin: 0 0 12px 0;
      font-size: 20px;
    }
    
    .error-card p {
      color: var(--text);
      margin: 12px 0;
      font-size: 14px;
    }
    
    .error-card button {
      margin: 8px 4px;
    }
    
    /* ==================== SMOOTH TRANSITIONS ==================== */
    /* PERFORMANCE MODE: Transitions deaktiviert für instant response */
    /* WICHTIG: Falls du Animationen wieder aktivieren möchtest: */
    /* Suche nach "transition: none !important" und ändere zu z.B. "transition: all 0.2s ease" */
    
    .card {
      transition: none !important;
      /* CSS Containment für bessere Performance */
      contain: layout style paint;
    }
    
    .card:hover {
      transform: translateY(-2px) translateZ(0); /* Hardware-beschleunigt */
      box-shadow: 0 8px 24px rgba(2,6,23,0.6);
      transition: none !important;
    }
    
    .nav button {
      transition: none !important;
      contain: layout style paint;
    }
    
    /* Page transitions - instant für maximale Performance */
    .page-enter {
      animation: none !important; /* Keine Animation */
      opacity: 1 !important;
      transform: none !important;
    }
    
    .page-exit {
      animation: none !important;
      display: none !important;
    }
    
    /* Performance-Optimierung für häufig animierte Elemente */
    .mobile-menu-btn,
    .sidebar,
    .mobile-overlay {
      will-change: auto;
      transform: translateZ(0);
    }
    
    /* Sidebar ohne Transition für instant response */
    .sidebar {
      transition: none !important;
    }
    
    /* Mobile Sidebar Transitions deaktiviert */
    @media (max-width: 700px) {
      .sidebar {
        transition: none !important;
      }
    }
    
    /* ==================== PULL TO REFRESH ==================== */
    .pull-to-refresh {
      position: fixed;
      top: -60px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: white;
      padding: 12px 24px;
      border-radius: 0 0 12px 12px;
      font-size: 14px;
      font-weight: 600;
      z-index: 999;
      transition: top 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .pull-to-refresh.active {
      top: 0;
    }
    
    /* ==================== DATE SHORTCUTS ==================== */
    .date-shortcuts {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 12px 0;
    }
    
    .date-shortcuts button {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--soft);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .date-shortcuts button:hover {
      background: rgba(6,182,212,0.1);
      border-color: var(--accent);
      color: var(--text);
      transform: translateY(-1px);
    }
    
    .date-shortcuts button.active {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      border-color: transparent;
      color: white;
    }
    
    /* ==================== KEYBOARD SHORTCUTS MODAL ==================== */
    .shortcuts-modal {
      background: var(--card);
      border-radius: var(--radius);
      padding: 24px;
      max-width: 500px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 12px 48px rgba(0,0,0,0.8);
    }
    
    .shortcuts-modal h2 {
      margin: 0 0 20px 0;
      font-size: 24px;
      color: var(--text);
    }
    
    .shortcuts-modal table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .shortcuts-modal td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    
    .shortcuts-modal td:first-child {
      font-family: 'Courier New', monospace;
      background: var(--glass);
      border-radius: 6px;
      font-weight: 600;
      color: var(--accent);
      text-align: center;
      width: 120px;
    }
    
    .shortcuts-modal td:last-child {
      color: var(--soft);
    }
    
    .shortcuts-modal tr:last-child td {
      border-bottom: none;
    }
    
    /* ==================== TUTORIAL SYSTEM ==================== */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(12px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      animation: fadeIn 0.3s ease;
    }
    
    .tutorial-box {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      overflow: hidden;
      animation: slideUp 0.4s ease;
    }
    
    @keyframes slideUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .tutorial-header {
      padding: 24px 28px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
    }
    
    .tutorial-header h3 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .tutorial-close {
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 28px;
      cursor: pointer;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    
    .tutorial-close:hover {
      background: rgba(255,255,255,0.06);
      color: var(--text);
      transform: rotate(90deg);
    }
    
    .tutorial-content {
      padding: 32px 28px;
      min-height: 280px;
    }
    
    .tutorial-content p {
      font-size: 16px;
      line-height: 1.6;
      color: var(--soft);
      margin: 0 0 20px 0;
    }
    
    .tutorial-image {
      margin-top: 24px;
      text-align: center;
      font-size: 80px;
      animation: bounce 2s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    .tutorial-footer {
      padding: 20px 28px;
      border-top: 1px solid rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.2);
    }
    
    .tutorial-progress {
      color: var(--muted);
      font-size: 14px;
      font-weight: 600;
    }
    
    .tutorial-buttons {
      display: flex;
      gap: 10px;
    }
    
    .tutorial-buttons .btn {
      padding: 10px 20px;
      font-size: 14px;
    }
    
    .tutorial-highlight {
      position: relative;
      z-index: 10001;
      box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.5), 0 0 60px rgba(6, 182, 212, 0.4);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.5), 0 0 60px rgba(6, 182, 212, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(6, 182, 212, 0.3), 0 0 80px rgba(6, 182, 212, 0.6); }
    }
    
    /* ==================== TOOLTIPS ==================== */
    .tooltip-container {
      position: fixed;
      background: linear-gradient(135deg, rgba(6,182,212,0.95), rgba(124,58,237,0.95));
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      z-index: 10000;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 250px;
      animation: tooltipFadeIn 0.2s ease;
    }
    
    @keyframes tooltipFadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .tooltip-container::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid rgba(124,58,237,0.95);
    }
    
    /* ==================== BULK EDIT ==================== */
    .obs-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--accent);
    }
    
    .bulk-edit-modal {
      max-width: 700px;
    }
    
    .bulk-action-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .bulk-action-btn {
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 20px 16px;
      cursor: pointer;
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s ease;
      line-height: 1.4;
    }
    
    .bulk-action-btn:hover {
      background: linear-gradient(135deg, rgba(6,182,212,0.15), rgba(124,58,237,0.15));
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(6,182,212,0.2);
    }
    
    .bulk-action-btn.danger {
      background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(220,38,38,0.1));
      border-color: rgba(239,68,68,0.3);
    }
    
    .bulk-action-btn.danger:hover {
      background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(220,38,38,0.2));
    }
    
    .bulk-selected-list {
      max-height: 300px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }
    
    .bulk-selected-item {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .bulk-selected-item strong {
      color: var(--text);
    }
    
    .bulk-selected-item small {
      color: var(--muted);
      font-size: 12px;
    }
    
    /* ==================== ENHANCED STATISTICS ==================== */
    .enhanced-stats-modal {
      max-width: 1000px;
    }
    
    .stats-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      border-bottom: 2px solid rgba(255,255,255,0.04);
      overflow-x: auto;
      padding-bottom: 8px;
    }
    
    .stats-tab {
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 12px 20px;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      white-space: nowrap;
      transition: all 0.2s ease;
    }
    
    .stats-tab:hover {
      background: var(--glass);
      color: var(--text);
    }
    
    .stats-tab.active {
      background: linear-gradient(180deg, rgba(6,182,212,0.12), transparent);
      color: var(--text);
      border-bottom: 2px solid var(--accent);
    }
    
    .stats-tab-content {
      animation: fadeInUp 0.3s ease;
    }
    
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 32px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.08));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: transform 0.2s ease;
    }
    
    .stat-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(6,182,212,0.2);
    }
    
    .stat-icon {
      font-size: 36px;
      margin-bottom: 12px;
    }
    
    .stat-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 8px;
    }
    
    .stat-label {
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
    }
    
    .chart-container h3 {
      margin: 0 0 20px 0;
      font-size: 16px;
      color: var(--text);
    }
    
    .chart-container canvas {
      max-height: 400px;
    }
    
    .year-selector {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 24px;
    }
    
    .year-selector button {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--text);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .year-selector button:hover {
      background: var(--accent);
      transform: scale(1.1);
    }
    
    .year-selector span {
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
      min-width: 100px;
      text-align: center;
    }
    
    .year-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 16px;
    }
    
    .year-stat-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.06), rgba(124,58,237,0.06));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 20px;
    }
    
    .year-stat-card h4 {
      margin: 0 0 16px 0;
      font-size: 18px;
      color: var(--text);
    }
    
    .year-stat-card p {
      margin: 8px 0;
      font-size: 14px;
      color: var(--soft);
    }
    
    .year-stat-card strong {
      color: var(--accent);
      font-size: 20px;
    }
    
    .year-comparison {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.04);
      font-size: 13px;
      color: var(--muted);
    }
    
    .year-comparison.positive {
      color: var(--success);
    }
    
    .year-comparison.negative {
      color: var(--danger);
    }
    
    .heatmap-controls {
      display: flex;
      gap: 20px;
      margin-bottom: 24px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .heatmap-controls label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 8px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      transition: all 0.2s ease;
    }
    
    .heatmap-controls label:hover {
      background: rgba(6,182,212,0.1);
      border-color: var(--accent);
    }
    
    .heatmap-controls input[type="radio"] {
      accent-color: var(--accent);
    }
    
    .heatmap-container {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 400px;
    }
    
    .heatmap-container canvas {
      max-width: 100%;
      height: auto;
    }
    
    .heatmap-legend {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 16px;
      font-size: 13px;
      color: var(--muted);
    }
    
    .legend-gradient {
      width: 200px;
      height: 20px;
      border-radius: 10px;
      background: linear-gradient(90deg, 
        rgba(6,182,212,0.1), 
        rgba(6,182,212,0.3), 
        rgba(6,182,212,0.6), 
        rgba(6,182,212,1)
      );
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .milestones-container {
      display: grid;
      gap: 16px;
      margin-bottom: 32px;
    }
    
    .milestone-card {
      background: linear-gradient(135deg, rgba(6,182,212,0.06), rgba(124,58,237,0.06));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      transition: all 0.2s ease;
    }
    
    .milestone-card:hover {
      transform: translateX(4px);
      box-shadow: 0 4px 16px rgba(6,182,212,0.15);
    }
    
    .milestone-card.achieved {
      background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(34,197,94,0.1));
      border-color: rgba(16,185,129,0.3);
    }
    
    .milestone-icon {
      font-size: 48px;
      width: 70px;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.04);
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    .milestone-card.achieved .milestone-icon {
      background: rgba(16,185,129,0.15);
    }
    
    .milestone-info {
      flex: 1;
    }
    
    .milestone-info h4 {
      margin: 0 0 8px 0;
      font-size: 16px;
      color: var(--text);
    }
    
    .milestone-info p {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }
    
    .milestone-progress {
      font-size: 14px;
      color: var(--accent);
      font-weight: 600;
      margin-top: 8px;
    }
    
    .milestone-card.achieved .milestone-progress {
      color: var(--success);
    }
    
    .milestone-badge {
      background: var(--accent);
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .milestone-card.achieved .milestone-badge {
      background: var(--success);
    }
    
    .progress-section {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 24px;
    }
    
    .progress-section h3 {
      margin: 0 0 16px 0;
      font-size: 16px;
      color: var(--text);
    }
    
    .progress-bar-container {
      width: 100%;
      height: 32px;
      background: rgba(0,0,0,0.3);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.06);
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      border-radius: 16px;
      transition: width 1s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 12px;
      color: white;
      font-weight: 700;
      font-size: 14px;
      box-shadow: 0 0 20px rgba(6,182,212,0.5);
    }
    
    .progress-text {
      margin-top: 12px;
      text-align: center;
      font-size: 14px;
      color: var(--soft);
    }
    
    /* ==================== PRIVACY BANNER ==================== */
    .privacy-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card);
      border-top: 2px solid var(--accent);
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      z-index: 9999;
      box-shadow: 0 -4px 24px rgba(0,0,0,0.6);
      animation: slideUpBanner 0.4s ease;
    }
    
    @keyframes slideUpBanner {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .privacy-banner p {
      margin: 0;
      font-size: 14px;
      color: var(--text);
      flex: 1;
    }
    
    .privacy-banner a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    
    .privacy-banner a:hover {
      text-decoration: underline;
    }
    
    .privacy-banner button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
    }
    
    .privacy-banner button:hover {
      background: var(--accent-2);
      transform: scale(1.05);
    }
    
    @media (max-width: 600px) {
      .privacy-banner {
        flex-direction: column;
        text-align: center;
      }
      
      .privacy-banner button {
        width: 100%;
      }
    }
    
    /* ==================== IMPROVED CONTRAST FOR ACCESSIBILITY ==================== */
    [data-theme="dark"] .muted {
      color: #cbd5e1; /* Höherer Kontrast */
    }
    
    [data-theme="light"] .muted {
      color: #475569; /* Höherer Kontrast */
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
      .card {
        border: 2px solid var(--text);
      }
      
      button {
        border: 2px solid currentColor;
      }
      
      .muted {
        color: var(--text);
      }
    }
    
    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* Mobile Date Shortcuts anpassen */
    @media (max-width: 768px) {
      .date-shortcuts {
        justify-content: center;
      }
      
      .shortcuts-modal {
        margin: 20px;
        max-width: calc(100vw - 40px);
      }
      
      .shortcuts-modal table {
        font-size: 13px;
      }
      
      .shortcuts-modal td {
        padding: 8px;
      }
      
      .shortcuts-modal td:first-child {
        width: 80px;
        font-size: 12px;
      }
    }
    
    /* Enhanced mobile portrait mode optimizations */
    @media (max-width: 480px) {
      .member-card {
        padding: 12px;
      }
      
      .member-avatar {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .stat-value {
        font-size: 14px;
      }
      
      .stat-label {
        font-size: 12px;
      }
      
      .comparison-stats {
        gap: 6px;
      }
      
      .stat-row {
        padding: 6px 8px;
      }
      
      /* Make top species text wrap better on narrow screens */
      .stat-row .stat-value {
        font-size: 12px;
        max-width: calc(100vw - 200px);
        text-align: right;
      }
      
      /* Force single column for member comparison grid */
      #memberComparisonGrid {
        grid-template-columns: 1fr !important;
      }
      
      .comparison-grid {
        grid-template-columns: 1fr !important;
      }
      
      /* Force all inline grids with auto-fit/auto-fill to single column on very narrow screens */
      [style*="grid-template-columns"][style*="auto-fit"],
      [style*="grid-template-columns"][style*="auto-fill"] {
        grid-template-columns: 1fr !important;
      }
    }
    
    /* Also force single column on slightly wider mobile devices in portrait */
    @media (max-width: 700px) {
      #memberComparisonGrid {
        grid-template-columns: 1fr !important;
      }
    }
    
    /* ULTRA-AGGRESSIVE: Force ALL grids to single column on mobile */
    @media (max-width: 700px) {
      /* Target all divs with grid display */
      div[style*="display:grid"],
      div[style*="display: grid"],
      [style*="grid-template-columns"] {
        grid-template-columns: 1fr !important;
      }
      
      /* Specific IDs */
      #memberComparisonGrid,
      #observationLeaderboard,
      #speciesLeaderboard,
      #availableChallengesGrid,
      #rarityLeaderboard2026,
      #achievementLeaderboard,
      #speciesDatabase,
      #listsGrid {
        grid-template-columns: 1fr !important;
      }
      
      /* Any element with a class that contains 'grid' */
      [class*="grid"] {
        grid-template-columns: 1fr !important;
      }
      
      .comparison-grid,
      .stats-grid,
      .card-grid {
        grid-template-columns: 1fr !important;
      }
    }
    
  </style>
<!-- External Libraries für erweiterte Features -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

<!-- Optional: Mapbox für 3D (benötigt kostenlosen Account) -->
<link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
<script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
</head>
<body data-theme="dark">

<!-- Skip to main content (Accessibility) -->
<a href="#main-content" class="skip-to-main">Zum Hauptinhalt springen</a>

<!-- NEU: Mobile Menu Button -->
<button class="mobile-menu-btn" 
        id="mobileMenuBtn" 
        onclick="toggleMobileMenu()" 
        aria-label="Menü öffnen"
        aria-expanded="false">
  <svg viewBox="0 0 24 24" fill="none">
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
  </svg>
</button>

<!-- NEU: Mobile Overlay -->
<div class="mobile-overlay" id="mobileOverlay" onclick="closeMobileMenu()" role="presentation"></div>

  <div class="app">
    <aside class="sidebar" aria-label="Navigation">
      <div class="brand">
        <div class="logo">BC</div>
        <div>
          <h1>BirdCount</h1>
          <p>Professionelles Beobachtungssystem</p>
        </div>
      </div>

      <nav class="nav" role="navigation" aria-label="Hauptnavigation">
        <button class="active" data-page="home">🏠 Dashboard</button>
        <button data-page="beobachtungen">📝 Beobachtungen</button>
        <button data-page="eingabe">✍️ Eingabe</button>
        <button data-page="diagramme">📊 Analyse</button>
        <button data-page="statistiken">📈 Statistiken</button>
        <button data-page="karte">🗺 Karte</button>
        <button data-page="listen">📋 Listen</button>
        <button data-page="arten">🐦 Arten-DB</button>
        <button data-page="challenges">🏆 Challenges</button>
        <button data-page="group-compare" id="groupCompareNav" style="display:none;">👥 Gruppenvergleich</button>
        <button data-page="tools">🛠️ Tools</button>
      </nav>

      <div class="actions">
        <button class="btn" id="btnEnhancedStats" onclick="EnhancedStatsManager.open()" title="Erweiterte Statistiken mit Jahresvergleichen, Heatmaps und Meilensteinen">📊 Erweiterte Stats</button>
        <button class="btn" id="btnBulkEdit" onclick="BulkEditManager.open()" style="display: none;" title="Mehrere Beobachtungen gleichzeitig bearbeiten">📦 Mehrfachbearbeitung (<span id="bulkCountBadge">0</span>)</button>
        <button class="btn ghost" id="addFolderBtn">Neuer Ordner</button>
        <button class="btn ghost" id="exportAllBtn">Export All</button>
        <button class="btn ghost" onclick="TutorialManager.reset()" title="Tutorial neu starten">🎓 Tutorial</button>
      </div>

      <div class="feature-section">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <div class="muted">Theme</div>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:12px;">
          <button class="small-btn theme-btn" data-theme="dark" title="Standard Dunkel">🌙 Dark</button>
          <button class="small-btn theme-btn" data-theme="light" title="Hell">☀️ Light</button>
          <button class="small-btn theme-btn" data-theme="nature" title="Natur/Wald">🌲 Natur</button>
          <button class="small-btn theme-btn" data-theme="ocean" title="Ozean/Wasser">🌊 Ozean</button>
          <button class="small-btn theme-btn" data-theme="sunset" title="Sonnenuntergang">🌅 Sunset</button>
          <button class="small-btn theme-btn" data-theme="midnight" title="Mitternacht">🌃 Midnight</button>
        </div>
        
        <div style="margin-top:12px;">
          <div class="muted">Offline-Modus</div>
          <div class="progress-bar">
            <div class="progress-fill" id="storageProgress" style="width: 0%"></div>
          </div>
          <div style="font-size:11px;color:var(--muted);margin-top:4px;" id="storageInfo">Lade...</div>
        </div>
        
        <p class="footer-note">Daten werden lokal gespeichert</p>
      </div>
    </aside>

    <main class="main" id="main-content">
      <div class="topbar">
        <div class="search card" style="max-width:760px;">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="opacity:0.8"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <input id="globalSearch" placeholder="Suche Vogelart, Datum, Ort oder Merkmale..." />
        </div>
        <div class="controls">
          <button id="btnEnhancedStats" class="btn" onclick="EnhancedStatsManager.open()" title="Erweiterte Statistiken">📊 Statistiken+</button>
          <button id="btnBulkEdit" class="btn" onclick="BulkEditManager.open()" style="display:none;" title="Mehrfachbearbeitung">📦 Bulk-Edit</button>
          <button id="importBtn" class="btn ghost">📥 Import</button>
          <button id="exportBtn" class="btn">📤 Export</button>
          <button id="printBtn" class="btn ghost no-print">🖨️ Drucken</button>
          <button id="helpBtn" class="btn" onclick="showKeyboardShortcuts()" aria-label="Hilfe und Keyboard-Shortcuts anzeigen">❓ Hilfe</button>
          <button class="btn ghost" onclick="TutorialManager.start()" title="Tutorial neu starten">🎓</button>
        </div>
      </div>

      <div class="grid">
        <div>
          <!-- Dashboard -->
          <section id="home" class="card active">
            <h2>Dashboard</h2>
            <p class="muted">Willkommen zu deinem Vogelbeobachtungs-System. Hier findest du alle wichtigen Informationen auf einen Blick.</p>
            
            <!-- NEU: Datums-Filter Shortcuts -->
            <div class="date-shortcuts" role="toolbar" aria-label="Datums-Filter">
              <button data-range="today" onclick="applyDateFilter('today')" aria-label="Heute anzeigen">
                📅 Heute
              </button>
              <button data-range="yesterday" onclick="applyDateFilter('yesterday')" aria-label="Gestern anzeigen">
                📅 Gestern
              </button>
              <button data-range="week" onclick="applyDateFilter('week')" aria-label="Letzte Woche anzeigen">
                📅 Letzte Woche
              </button>
              <button data-range="month" onclick="applyDateFilter('month')" aria-label="Letzter Monat anzeigen">
                📅 Letzter Monat
              </button>
              <button data-range="thisYear" onclick="applyDateFilter('thisYear')" aria-label="Dieses Jahr anzeigen">
                📅 Dieses Jahr
              </button>
              <button data-range="all" onclick="applyDateFilter('all')" class="active" aria-label="Alle anzeigen">
                📅 Alle
              </button>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:12px;margin-top:12px;">
              <div class="card">
                <div class="kpi"><div class="value" id="kpiTotal">0</div><div class="muted">Gesamtbeobachtungen</div></div>
              </div>
              <div class="card">
                <div class="kpi"><div class="value" id="kpiSpecies">0</div><div class="muted">Vogelarten</div></div>
              </div>
              <div class="card">
                <div class="kpi"><div class="value" id="kpiDays">0</div><div class="muted">Beobachtungstage</div></div>
              </div>
              <div class="card">
                <div class="kpi"><div class="value" id="kpiAvg">0.0</div><div class="muted">Ø pro Tag</div></div>
              </div>
            </div>
            
            <div class="feature-section">
              <h3 style="margin-top:0;">Top 5 Vogelarten</h3>
              <div class="top-species-list" id="topSpeciesList">
                <div class="muted">Keine Beobachtungen</div>
              </div>
            </div>
            
            <div class="feature-section">
              <h3 style="margin-top:0;">Schnellzugriff</h3>
              <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="small-btn" onclick="document.querySelector('button[data-page=\"eingabe\"]').click()">➕ Neue Beobachtung</button>
                <button class="small-btn" onclick="document.querySelector('button[data-page=\"karte\"]').click()">🗺️ Karte öffnen</button>
                <button class="small-btn" onclick="showQuickReport()">📋 Schnellbericht</button>
                <button class="small-btn" onclick="checkSeasonalBirds()">🌱 Saison-Tipps</button>
              </div>
            </div>
          </section>

          <!-- Beobachtungen Verwaltung -->
          <section id="beobachtungen" class="card" style="display:none;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
              <div>
                <h2 style="margin:0;">Beobachtungen verwalten</h2>
                <p class="muted" style="margin:4px 0 0 0;">Alle deine Beobachtungen an einem Ort</p>
              </div>
              <button class="btn" onclick="document.querySelector('.nav button[data-page=\\'eingabe\\']').click()">➕ Neue Beobachtung</button>
            </div>
            
            <!-- NEU: Datums-Filter Shortcuts (gleich wie im Dashboard) -->
            <div class="date-shortcuts" role="toolbar" aria-label="Datums-Filter" style="margin-bottom:16px;">
              <button data-range="today" onclick="applyDateFilter('today')" aria-label="Heute anzeigen">
                📅 Heute
              </button>
              <button data-range="yesterday" onclick="applyDateFilter('yesterday')" aria-label="Gestern anzeigen">
                📅 Gestern
              </button>
              <button data-range="week" onclick="applyDateFilter('week')" aria-label="Letzte Woche anzeigen">
                📅 Letzte Woche
              </button>
              <button data-range="month" onclick="applyDateFilter('month')" aria-label="Letzter Monat anzeigen">
                📅 Letzter Monat
              </button>
              <button data-range="thisYear" onclick="applyDateFilter('thisYear')" aria-label="Dieses Jahr anzeigen">
                📅 Dieses Jahr
              </button>
              <button data-range="all" onclick="applyDateFilter('all')" class="active" aria-label="Alle anzeigen">
                📅 Alle
              </button>
            </div>
            
            <!-- Filter und Suche -->
            <div class="card" style="background:rgba(255,255,255,0.02);margin-bottom:16px;">
              <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                <div>
                  <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">Suche</label>
                  <input type="text" id="obsManagerSearch" placeholder="Vogelart, Ort..." style="width:100%;" oninput="filterObservationManager()">
                </div>
                <div>
                  <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">Von Datum</label>
                  <input type="date" id="obsManagerDateFrom" onchange="filterObservationManager()" style="width:100%;">
                </div>
                <div>
                  <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">Bis Datum</label>
                  <input type="date" id="obsManagerDateTo" onchange="filterObservationManager()" style="width:100%;">
                </div>
              </div>
              
              <!-- NEU: Benutzerfilter (nur im Gruppenmodus) -->
              <div id="obsManagerUserFilterContainer" style="display:none;margin-bottom:12px;">
                <label style="font-size:12px;color:var(--muted);display:block;margin-bottom:4px;">👤 Benutzer filtern (Admin)</label>
                <select id="obsManagerUserFilter" onchange="filterObservationManager()" class="input" style="width:100%;">
                  <option value="all">Alle Benutzer</option>
                </select>
              </div>
              
              <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="small-btn obs-filter-btn active" onclick="setObsManagerFilter('all')">Alle</button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('rare')">Selten</button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('very-rare')">Sehr selten</button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('selffound')">Selffound 🔴</button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('tickable')">Tickbar ✓</button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('with-photo')">Mit Foto 📸</button>
              </div>
              
              <!-- NEU: Gruppenfilter (nur sichtbar im Gruppenmodus) -->
              <div id="obsManagerGroupFilters" style="display:none;gap:8px;flex-wrap:wrap;margin-top:12px;padding-top:12px;border-top:1px solid rgba(124,58,237,0.2);">
                <div style="width:100%;font-size:11px;color:var(--muted);font-weight:600;margin-bottom:4px;">👥 Gruppenfilter:</div>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('others-not-me')" style="background:rgba(124,58,237,0.1);border-color:rgba(124,58,237,0.3);">
                  👀 Von anderen gesehen (ich nicht)
                </button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('only-me')" style="background:rgba(16,185,129,0.1);border-color:rgba(16,185,129,0.3);">
                  ✨ Nur ich gesehen
                </button>
                <button class="small-btn obs-filter-btn" onclick="setObsManagerFilter('all-members')" style="background:rgba(251,191,36,0.1);border-color:rgba(251,191,36,0.3);">
                  🌟 Von allen gesehen
                </button>
                
                <!-- NEU: Spezifisches Mitglied auswählen -->
                <div style="width:100%;display:flex;gap:8px;align-items:center;margin-top:8px;padding-top:8px;border-top:1px solid rgba(124,58,237,0.15);">
                  <label style="font-size:11px;color:var(--muted);white-space:nowrap;">🔍 Arten von bestimmtem Mitglied:</label>
                  <select id="obsManagerMemberFilter" onchange="setObsManagerMemberFilter()" class="input" style="flex:1;padding:6px 10px;font-size:12px;">
                    <option value="">-- Mitglied auswählen --</option>
                  </select>
                  <button class="small-btn" onclick="clearObsManagerMemberFilter()" style="padding:6px 10px;background:rgba(239,68,68,0.2);border-color:rgba(239,68,68,0.3);">
                    ✕ Zurücksetzen
                  </button>
                </div>
              </div>
              
              <div style="display:flex;gap:8px;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.05);">
                <span style="font-size:12px;color:var(--muted);">Sortierung:</span>
                <button class="small-btn" onclick="setObsManagerSort('date-desc')" id="sortDateDesc">Datum ↓</button>
                <button class="small-btn" onclick="setObsManagerSort('date-asc')" id="sortDateAsc">Datum ↑</button>
                <button class="small-btn" onclick="setObsManagerSort('species')" id="sortSpecies">Art A-Z</button>
              </div>
            </div>
            
            <!-- NEU: Aktive Filter Anzeige -->
            <div id="activeFiltersContainer" class="active-filters-container">
              <div class="active-filters-header">
                <span class="active-filters-title">🎯 Aktive Filter</span>
                <button class="clear-all-filters-btn" onclick="clearAllObsManagerFilters()">Alle löschen</button>
              </div>
              <div id="activeFilterBadges" class="filter-badges">
                <!-- Filter badges will be added here dynamically -->
              </div>
            </div>
            
            <!-- NEU: Buttons zum Auf-/Zuklappen aller Bereiche -->
            <div style="display:flex;gap:8px;margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;">
              <button class="small-btn" onclick="toggleAllPersonAccordions(true)" style="flex:1;">
                📂 Alle öffnen
              </button>
              <button class="small-btn" onclick="toggleAllPersonAccordions(false)" style="flex:1;">
                📁 Alle schließen
              </button>
            </div>
            
            <!-- Statistik-Übersicht -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-bottom:16px;">
              <div class="card" style="background:rgba(6,182,212,0.1);">
                <div style="font-size:11px;color:var(--muted);margin-bottom:4px;">Angezeigt</div>
                <div style="font-size:24px;font-weight:700;" id="obsManagerCount">0</div>
              </div>
              <div class="card" style="background:rgba(124,58,237,0.1);">
                <div style="font-size:11px;color:var(--muted);margin-bottom:4px;">Arten</div>
                <div style="font-size:24px;font-weight:700;" id="obsManagerSpecies">0</div>
              </div>
              <div class="card" style="background:rgba(234,179,8,0.1);">
                <div style="font-size:11px;color:var(--muted);margin-bottom:4px;">Selten</div>
                <div style="font-size:24px;font-weight:700;" id="obsManagerRare">0</div>
              </div>
              <div class="card" style="background:rgba(239,68,68,0.1);">
                <div style="font-size:11px;color:var(--muted);margin-bottom:4px;">Sehr selten</div>
                <div style="font-size:24px;font-weight:700;" id="obsManagerVeryRare">0</div>
              </div>
            </div>
            
            <!-- Beobachtungen Liste -->
            <div id="obsManagerList">
              <!-- Wird dynamisch gefüllt -->
            </div>
          </section>

          <!-- Eingabe -->
          <section id="eingabe" class="card" style="display:none;">
            <h2>Beobachtung eingeben</h2>
            <p class="muted" style="margin-bottom:12px;">Erfasse eine neue Vogelbeobachtung mit allen Details.</p>
            
            <div class="filter-system">
              <h3 style="margin-top:0;font-size:14px;">Intelligente Eingabe</h3>
              <div class="form-row">
                <input type="text" id="birdSpeciesInput" list="birdSpeciesList" placeholder="Vogelart (beginne zu tippen)" style="flex:1;">
                <datalist id="birdSpeciesList"></datalist>
                <button class="small-btn" onclick="openSpeciesGuide()">🐦 Bestimmungshilfe</button>
              </div>
              
              <div class="species-info" id="speciesInfo" style="display:none;">
                <div id="speciesName"></div>
                <div class="species-details" id="speciesDetails"></div>
              </div>
              
              <div class="form-row" style="margin-top:12px;">
                <input type="date" id="obsDate" value="" style="flex:1;">
                <input type="time" id="obsTime" value="" style="width:120px;">
                <button class="small-btn" onclick="document.getElementById('obsDate').valueAsDate = new Date(); document.getElementById('obsTime').value = new Date().toTimeString().substr(0,5);">Jetzt</button>
              </div>
              
              <div class="form-row">
                <input type="number" id="obsCount" placeholder="Anzahl (optional)" style="width:120px;" min="1">
                <input type="text" id="obsBehavior" placeholder="Verhalten (optional)" style="flex:1;">
              </div>
              
              <div class="form-row">
                <input type="text" id="obsWeather" placeholder="Wetter (automatisch)" style="flex:1;" readonly>
                <button class="small-btn" onclick="getCurrentWeather()">🌤️ Wetter abrufen</button>
              </div>
              
              <!-- Seltenheits-Regler -->
              <div class="form-row" style="margin-top:8px;">
                <div style="flex:1; display:flex; flex-direction:column; gap:8px; padding:10px; background:rgba(255,255,255,0.02); border-radius:8px; border:1px solid rgba(255,255,255,0.04);">
                  <label style="font-size:13px; color:var(--muted); font-weight:600;">Seltenheit (optional)</label>
                  <input type="range" id="inputRarity" min="0" max="3" value="0" step="1" 
                         style="width:100%; accent-color:var(--accent);" 
                         oninput="updateInputRarityLabel(this.value)">
                  <div style="display:flex; justify-content:space-between; font-size:11px; color:var(--muted);">
                    <span>Häufig</span>
                    <span>Selten</span>
                    <span>Sehr selten</span>
                    <span>Escape</span>
                  </div>
                  <div id="inputRarityLabel" style="text-align:center; font-size:13px; color:var(--text); font-weight:600;">
                    Standard (aus Datenbank)
                  </div>
                </div>
              </div>
              
              <!-- NEU: Ordnerauswahl -->
              <div class="form-row">
                <div class="folder-select-container">
                  <span id="folderIndicator" class="folder-indicator" style="display:none;"></span>
                  <select id="folderSelect" style="flex:1;">
                    <option value="">Ordner wählen...</option>
                  </select>
                  <button class="small-btn" onclick="createNewFolderFromInput()" style="background:var(--accent-2);">➕</button>
                </div>
              </div>
              
              <!-- NEU: Versteckte Inputs für Koordinaten -->
              <input type="hidden" id="tempLat">
              <input type="hidden" id="tempLng">
              
              <!-- NEU: Anzeige für gesetzte Koordinaten -->
              <div id="coordDisplay" style="display:none; margin-top:8px;">
                <div style="display:flex; align-items:center; gap:8px; padding:8px; background:var(--glass); border-radius:8px;">
                  <span style="color:var(--accent);">🗺️</span>
                  <span style="font-size:13px;" id="coordText">Keine Koordinaten gesetzt</span>
                  <button class="small-btn" onclick="clearMapCoordinates()" style="margin-left:auto; background:var(--danger);">❌</button>
                </div>
              </div>
              
              <div class="image-upload">
                <input type="file" id="obsImage" accept="image/*" capture="environment" style="display:none;">
                <button class="small-btn" onclick="document.getElementById('obsImage').click()">📸 Foto hinzufügen</button>
                <button class="small-btn" onclick="testPhotoUpload()" style="margin-left:8px;">🔄 Foto testen</button>
                <img id="imagePreview" class="image-preview" alt="Vorschaubild">
                <!-- Verstecktes Input für Foto-Daten -->
                <input type="hidden" id="obsPhotoData">
              </div>
              
              <div class="form-row" style="margin-top:12px;">
                <button class="btn" onclick="saveNewObservation()" style="flex:1;">💾 Beobachtung speichern</button>
                <button class="btn ghost" onclick="setMapPointForNew()">🗺️ Auf Karte setzen</button>
                <button class="btn ghost" onclick="resetInputFields()" style="background:var(--danger);">❌ Abbrechen</button>
              </div>
            </div>
            
            <div id="folders"></div>
          </section>

          <!-- Diagramme -->
          <section id="diagramme" class="card" style="display:none;">
            <h2>Analysen & Diagramme</h2>
            
            <!-- Gruppen-Modus Banner -->
            <div id="diagrammeModeBanner" style="display:none;margin-bottom:16px;"></div>
            
            <!-- Mitglieder-Filter (nur im Gruppenmodus sichtbar) -->
            <div id="memberFilterContainer" style="display:none;margin-bottom:16px;padding:12px;background:var(--bg-secondary);border-radius:12px;">
              <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                <span style="font-weight:600;font-size:14px;">👥 Mitglieder:</span>
                <button class="small-btn" id="selectAllMembers" style="font-size:11px;padding:4px 8px;">Alle auswählen</button>
                <button class="small-btn" id="deselectAllMembers" style="font-size:11px;padding:4px 8px;">Alle abwählen</button>
              </div>
              <div id="memberCheckboxes" style="display:flex;flex-wrap:wrap;gap:8px;"></div>
            </div>
            
            <!-- Status-Filter (Tickbar/Selffound/Neue Arten) -->
            <div style="margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.02);border-radius:12px;border:1px solid rgba(255,255,255,0.05);">
              <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                <span style="font-weight:600;font-size:14px;">🎯 Status-Filter:</span>
                
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer;padding:6px 12px;background:rgba(16,185,129,0.1);border-radius:8px;border:2px solid transparent;transition:all 0.2s;" 
                       id="tickableFilterLabel">
                  <input type="checkbox" id="tickableFilter" onchange="updateChart()" 
                         style="width:16px;height:16px;cursor:pointer;accent-color:var(--success);">
                  <span style="font-size:13px;font-weight:600;">✓ Nur Tickbar</span>
                </label>
                
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer;padding:6px 12px;background:rgba(239,68,68,0.1);border-radius:8px;border:2px solid transparent;transition:all 0.2s;" 
                       id="selffoundFilterLabel">
                  <input type="checkbox" id="selffoundFilter" onchange="updateChart()" 
                         style="width:16px;height:16px;cursor:pointer;accent-color:var(--danger);">
                  <span style="font-size:13px;font-weight:600;">🔴 Nur Selffound</span>
                </label>
                
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer;padding:6px 12px;background:rgba(6,182,212,0.1);border-radius:8px;border:2px solid transparent;transition:all 0.2s;" 
                       id="newSpeciesFilterLabel"
                       title="Zeigt pro Tag nur Arten, die an diesem Tag zum ersten Mal im gewählten Zeitraum gesehen wurden (kumulative Erstbeobachtungen)">
                  <input type="checkbox" id="newSpeciesFilter" onchange="updateChart()" 
                         style="width:16px;height:16px;cursor:pointer;accent-color:var(--accent);">
                  <span style="font-size:13px;font-weight:600;">✨ Nur neue Arten (kumulativ)</span>
                </label>
                
                <span style="font-size:12px;color:var(--muted);margin-left:8px;" id="statusFilterInfo"></span>
              </div>
              
              <div id="newSpeciesInfo" style="display:none;margin-top:8px;padding:8px 12px;background:rgba(6,182,212,0.05);border-left:3px solid var(--accent);border-radius:4px;">
                <span style="font-size:12px;color:var(--soft);">
                  ℹ️ <strong>Neue Arten (kumulativ):</strong> Zeigt für jeden Tag nur Arten an, die <strong>an diesem Tag zum ersten Mal im Zeitraum</strong> beobachtet wurden.
                  <span id="newSpeciesCount" style="color:var(--accent);font-weight:600;"></span>
                  <br>
                  <span style="font-size:11px;color:var(--muted);margin-top:4px;display:inline-block;">
                    💡 <strong>Tipp:</strong> Klicke auf eine Säule im Diagramm, um die einzelnen Erstbeobachtungen zu sehen!
                  </span>
                </span>
              </div>
            </div>
            
            <div class="chart-controls">
              <div class="preset-buttons">
                <button class="preset-btn active" data-preset="this_year">Dieses Jahr</button>
                <button class="preset-btn" data-preset="last_year">Letztes Jahr</button>
                <button class="preset-btn" data-preset="30_days">Letzte 30 Tage</button>
                <button class="preset-btn" data-preset="7_days">Letzte 7 Tage</button>
                <button class="preset-btn" data-preset="90_days">Letzte 90 Tage</button>
                <button class="preset-btn" data-preset="all">Alle Daten</button>
              </div>
              
              <div class="slider-container">
                <div class="slider-label">
                  <span>Zeitraum (Tage):</span>
                  <span class="value" id="timeRangeValue">Dieses Jahr</span>
                </div>
                <input type="range" min="1" max="3650" value="365" class="slider" id="timeRangeSlider">
              </div>
              
              <div class="aggregation-buttons">
                <button class="agg-btn active" data-aggregation="day">Täglich</button>
                <button class="agg-btn" data-aggregation="week">Wöchentlich</button>
                <button class="agg-btn" data-aggregation="month">Monatlich</button>
                <button class="agg-btn" data-aggregation="year">Jährlich</button>
              </div>
              
              <div class="checkbox-container">
                <input type="checkbox" id="emptyDaysCheckbox" checked>
                <label for="emptyDaysCheckbox">Tage ohne Daten anzeigen</label>
              </div>
              
              <div class="heatmap-controls">
                <button class="small-btn" id="heatmapToggle">🔥 Heatmap: Aus</button>
                <button class="small-btn" id="clusterToggle">📍 Cluster: An</button>
                <button class="small-btn" onclick="exportChart()">📊 Diagramm exportieren</button>
              </div>
            </div>
            
            <div id="canvasContainer">
              <canvas id="chartCanvas"></canvas>
              <div class="chart-info">
                <div class="chart-stat">
                  <span class="value" id="chartMax">0</span> max
                </div>
                <div class="chart-stat">
                  Ø <span class="value" id="chartAvg">0</span>
                </div>
                <div class="chart-stat">
                  <span class="value" id="chartTotal">0</span> Gesamt
                </div>
              </div>
            </div>
            
            <div class="feature-section">
              <h3 style="margin-top:0;">Korrelationsanalyse</h3>
              <div id="correlationAnalysis">
                <div class="muted">Analysiere Beziehungen zwischen Wetter und Vogelaktivität...</div>
              </div>
            </div>
          </section>

          <!-- Statistiken -->
          <section id="statistiken" class="card" style="display:none;">
            <h2>Detaillierte Statistiken</h2>
            
            <!-- Gruppen-Modus Banner -->
            <div id="statistikenModeBanner" style="display:none;margin-bottom:16px;"></div>
            
            <div id="stats"></div>
            
            <div class="feature-section">
              <h3 style="margin-top:0;">Monatliche Übersicht</h3>
              <div id="monthlyOverview" style="margin-top:12px;">
                <div class="muted">Lade Daten...</div>
              </div>
            </div>
            
            <div class="feature-section">
              <h3 style="margin-top:0;">Artenspezifische Statistiken</h3>
              <div id="speciesStats">
                <div class="muted">Wähle eine Art aus der Liste...</div>
              </div>
            </div>
            
            <!-- Hier wird die Beobachtungsübersicht automatisch eingefügt -->
            <div id="detailsPerDate" style="margin-top:20px;"></div>
          </section>

          <!-- Listen -->
          <section id="listen" class="card" style="display:none;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">
              <div>
                <h2 style="margin:0;">📋 Benutzerdefinierte Listen</h2>
                <p class="muted" style="margin-top:4px;">Erstelle und verwalte Listen für spezifische Vogelbeobachtungen</p>
              </div>
              <div style="display:flex;gap:8px;">
                <button class="btn ghost" id="syncSharedListsBtn" onclick="manualSyncSharedLists()" title="Geteilte Listen in Gruppen aktualisieren">
                  🔄 Geteilte Listen synchronisieren
                </button>
                <button class="btn" id="createListBtn">➕ Neue Liste</button>
              </div>
            </div>
            
            <div class="lists-container">
              <div class="search" style="margin-bottom:16px;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="opacity:0.8"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
                <input id="listSearch" placeholder="Suche Listen..." />
              </div>
              
              <div style="display:flex;gap:8px;margin-bottom:16px;flex-wrap:wrap;">
                <button class="small-btn active" onclick="filterLists('all')">Alle</button>
                <button class="small-btn" onclick="filterLists('personal')">Persönlich</button>
                <button class="small-btn" onclick="filterLists('favorites')">Favoriten</button>
                <button class="small-btn" onclick="filterLists('shared')">Geteilt</button>
                <button class="small-btn" onclick="filterLists('recent')">Zuletzt bearbeitet</button>
              </div>
              
              <div id="listsGrid" class="lists-grid">
                <div class="empty-state">
                  <div class="empty-state-icon">📋</div>
                  <div class="empty-state-title">Noch keine Listen</div>
                  <div class="empty-state-description">Erstelle deine erste Liste, um Vogelbeobachtungen zu organisieren und zu analysieren.</div>
                  <button class="btn" onclick="openCreateListModal()">Erste Liste erstellen</button>
                </div>
              </div>
            </div>
            
            <div class="feature-section" style="margin-top:32px;">
              <h3 style="margin-top:0;">💡 Verwendungsbeispiele</h3>
              <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 250px), 1fr));gap:16px;margin-top:16px;">
                <div class="card">
                  <h4 style="margin:0 0 8px 0;">🦅 Seltene Arten</h4>
                  <p style="font-size:13px;color:var(--muted);margin:0;">Erstelle eine Liste für seltene oder geschützte Vogelarten in deiner Region.</p>
                </div>
                <div class="card">
                  <h4 style="margin:0 0 8px 0;">🌳 Standort-basiert</h4>
                  <p style="font-size:13px;color:var(--muted);margin:0;">Beobachtungen aus einem spezifischen Gebiet oder Naturschutzgebiet.</p>
                </div>
                <div class="card">
                  <h4 style="margin:0 0 8px 0;">📅 Saisonale Listen</h4>
                  <p style="font-size:13px;color:var(--muted);margin:0;">Frühlingszugvögel oder Wintergäste aus deinen Beobachtungen.</p>
                </div>
              </div>
            </div>
          </section>

          <!-- Arten-Datenbank -->
          <section id="arten" class="card" style="display:none;">
            <h2>Vogelarten-Datenbank</h2>
            <p class="muted">Übersicht über alle erfassten Vogelarten mit Details und Schutzstatus.</p>
            
            <div class="search" style="margin-bottom:12px;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="opacity:0.8"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
              <input id="speciesSearch" placeholder="Suche Vogelart, Familie oder wissenschaftlichen Namen..." />
            </div>
            
            <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;">
              <button class="small-btn active" onclick="filterSpecies('all')">Alle</button>
              <button class="small-btn" onclick="filterSpecies('seen')">✓ Gesehen (Ich)</button>
              <button class="small-btn" onclick="filterSpecies('unseen')">Noch nicht gesehen</button>
              <button class="small-btn" onclick="filterSpecies('common')">Häufig</button>
              <button class="small-btn" onclick="filterSpecies('rare')">Selten</button>
              <button class="small-btn" onclick="filterSpecies('very-rare')">Sehr selten</button>
              <button class="small-btn" onclick="filterSpecies('selffound')">🔴 Selffound</button>
            </div>
            
            <!-- Gruppen-Filter (nur sichtbar wenn in Gruppe) -->
            <div id="groupSpeciesFilters" style="display:none;gap:8px;margin-bottom:12px;flex-wrap:wrap;padding:12px;background:rgba(124,58,237,0.08);border-radius:10px;border:1px solid rgba(124,58,237,0.2);">
              <div style="width:100%;font-size:12px;color:var(--muted);margin-bottom:6px;font-weight:600;">👥 Gruppenansicht:</div>
              <button class="small-btn" onclick="filterSpecies('group-all')">🌍 Von allen gesehen</button>
              <button class="small-btn" onclick="filterSpecies('group-any')">👤 Von Mitgliedern gesehen</button>
              <button class="small-btn" onclick="filterSpecies('group-missing')">❌ Von niemand gesehen</button>
            </div>
            
            <!-- NEU: Aktive Filter Anzeige für Arten-Datenbank -->
            <div id="speciesActiveFiltersContainer" class="active-filters-container">
              <div class="active-filters-header">
                <span class="active-filters-title">🎯 Aktive Filter</span>
                <button class="clear-all-filters-btn" onclick="clearAllSpeciesFilters()">Alle löschen</button>
              </div>
              <div id="speciesActiveFilterBadges" class="filter-badges">
                <!-- Filter badges will be added here dynamically -->
              </div>
            </div>
            
            <div id="speciesDatabase" style="max-height:500px;overflow-y:auto;">
              <div class="muted">Lade Arten-Datenbank...</div>
            </div>
          </section>

          <!-- Species Detail Modal -->
          <div id="speciesDetailModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.85);backdrop-filter:blur(8px);align-items:center;justify-content:center;z-index:10000;padding:20px;overflow-y:auto;">
            <div style="background:var(--card);padding:24px;border-radius:16px;max-width:1000px;width:100%;max-height:90vh;overflow-y:auto;border:1px solid rgba(255,255,255,0.06);box-shadow:0 20px 60px rgba(0,0,0,0.6);">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                <h2 id="speciesDetailTitle" style="margin:0;display:flex;align-items:center;gap:12px;">
                  <span id="speciesDetailName">Vogelart</span>
                  <span id="speciesDetailBadge" style="font-size:12px;padding:4px 10px;border-radius:20px;"></span>
                </h2>
                <button class="small-btn" onclick="closeSpeciesDetail()" style="background:var(--danger);">✕ Schließen</button>
              </div>
              
              <!-- Arten-Info -->
              <div id="speciesDetailInfo" style="margin-bottom:24px;padding:16px;background:var(--glass);border-radius:12px;border:1px solid rgba(255,255,255,0.04);">
                <div class="species-details" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:12px;">
                </div>
              </div>
              
              <!-- Statistiken -->
              <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));gap:12px;margin-bottom:24px;">
                <div class="card" style="text-align:center;padding:16px;">
                  <div style="font-size:32px;font-weight:700;color:var(--accent);" id="speciesObsCount">0</div>
                  <div style="font-size:13px;color:var(--muted);margin-top:4px;">Beobachtungen</div>
                </div>
                <div class="card" style="text-align:center;padding:16px;">
                  <div style="font-size:32px;font-weight:700;color:var(--accent-2);" id="speciesPhotoCount">0</div>
                  <div style="font-size:13px;color:var(--muted);margin-top:4px;">Fotos</div>
                </div>
                <div class="card" style="text-align:center;padding:16px;">
                  <div style="font-size:32px;font-weight:700;color:var(--success);" id="speciesFirstSeen">-</div>
                  <div style="font-size:13px;color:var(--muted);margin-top:4px;">Erstsichtung</div>
                </div>
                <div class="card" style="text-align:center;padding:16px;">
                  <div style="font-size:32px;font-weight:700;color:var(--success);" id="speciesLastSeen">-</div>
                  <div style="font-size:13px;color:var(--muted);margin-top:4px;">Letztsichtung</div>
                </div>
              </div>
              
              <!-- Foto-Galerie -->
              <div id="speciesPhotoGallery" style="margin-bottom:24px;">
                <h3 style="margin:0 0 12px 0;">📸 Fotos</h3>
                <div id="speciesPhotos" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(150px, 1fr));gap:12px;">
                  <div class="muted">Keine Fotos vorhanden</div>
                </div>
              </div>
              
              <!-- Beobachtungen -->
              <div>
                <h3 style="margin:0 0 12px 0;">📋 Alle Beobachtungen</h3>
                <div id="speciesObservations" style="max-height:400px;overflow-y:auto;display:flex;flex-direction:column;gap:8px;">
                  <div class="muted">Keine Beobachtungen vorhanden</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Tools -->
          <section id="tools" class="card" style="display:none;">
            <h2>Werkzeuge & Einstellungen</h2>
            
            <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 250px), 1fr));gap:16px;">
              <!-- In Gruppe kopieren -->
              <div class="card" id="copyToGroupTool">
                <h3>👥 In Gruppe kopieren</h3>
                <p style="font-size:12px;color:var(--muted);margin-bottom:12px;">
                  Kopiere deine privaten Beobachtungen in eine Gruppe
                </p>
                <div style="margin-bottom:8px;">
                  <label style="font-size:13px;color:var(--muted);">Zielgruppe:</label>
                  <select id="targetGroupSelect" style="width:100%;margin-top:4px;">
                    <option value="">Gruppe auswählen...</option>
                  </select>
                </div>
                <button class="small-btn" onclick="openCopyToGroupModal()" style="width:100%;background:var(--accent);">
                  📋 Beobachtungen auswählen
                </button>
                <div style="font-size:11px;color:var(--muted);margin-top:8px;text-align:center;">
                  <span id="copyToGroupStatus">Bitte wähle eine Gruppe aus</span>
                </div>
              </div>
              
              <!-- Datenmanagement -->
              <div class="card">
                <h3>📁 Datenmanagement</h3>
                <div class="import-export">
                  <button class="small-btn" onclick="exportData('json')" style="flex:1;">JSON Export</button>
                  <button class="small-btn" onclick="exportData('csv')" style="flex:1;">CSV Export</button>
                </div>
                <div class="import-export" style="margin-top:8px;">
                  <input type="file" id="importFile" accept=".json,.csv" style="display:none;">
                  <button class="small-btn" onclick="document.getElementById('importFile').click()" style="flex:1;">Daten importieren</button>
                </div>
                <div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.06);">
                  <input type="file" id="ornithoImportFile" accept=".txt" style="display:none;">
                  <button class="small-btn" onclick="document.getElementById('ornithoImportFile').click()" style="width:100%;background:var(--accent);text-align:center;cursor:pointer;">
                    🦅 Ornitho.de Import
                  </button>
                  <div style="font-size:11px;color:var(--muted);margin-top:6px;text-align:center;">
                    Importiere Beobachtungen aus ornitho.de Export-Dateien<br>
                    <span style="color:rgba(124,58,237,0.8);">📸 Foto-URLs werden automatisch importiert</span>
                  </div>
                </div>
                <button class="small-btn" onclick="backupData()" style="margin-top:12px;width:100%;">💾 Backup erstellen</button>
                <button class="small-btn" onclick="restoreBackup()" style="margin-top:4px;width:100%;">🔧 Backup wiederherstellen</button>
                <div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.06);">
                  <button class="small-btn" onclick="deleteAllObservations()" style="width:100%;background:var(--danger);">
                    🗑️ Alle Beobachtungen löschen
                  </button>
                  <div style="font-size:11px;color:var(--muted);margin-top:6px;text-align:center;">
                    ⚠️ Löscht alle deine Beobachtungen (nicht rückgängig zu machen!)
                  </div>
                </div>
              </div>
              
              <!-- NEU: Benutzername (Privater Modus) -->
              <div class="card">
                <h3>👤 Benutzername</h3>
                <p style="font-size:12px;color:var(--muted);margin-bottom:12px;">
                  Dein Name wird bei deinen Beobachtungen im privaten Modus angezeigt
                </p>
                <div style="margin-bottom:8px;">
                  <label style="font-size:13px;color:var(--muted);">Dein Name:</label>
                  <input type="text" id="privateUserNameInput" placeholder="z.B. Max Mustermann" 
                         style="width:100%;margin-top:4px;padding:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);">
                </div>
                <button class="small-btn" onclick="savePrivateUserName()" style="width:100%;background:var(--success);">
                  💾 Namen speichern
                </button>
                <div style="font-size:11px;color:var(--muted);margin-top:8px;text-align:center;">
                  Dein aktueller Name: <span id="currentUserNameDisplay" style="color:var(--accent);font-weight:600;"></span>
                </div>
              </div>
              
              <!-- Karteneinstellungen -->
              <div class="card">
                <h3>🗺️ Karten-Einstellungen</h3>
                <div class="form-row">
                  <label style="font-size:13px;color:var(--muted);">Kartenlayer:</label>
                  <select id="mapLayerSelect" style="flex:1;">
                    <option value="osm">OpenStreetMap</option>
                    <option value="topo">Topografisch</option>
                    <option value="satellite">Satellit</option>
                    <option value="hybrid">Hybrid (Satellit + Straßen)</option>
                  </select>
                </div>
                <div style="display:flex;gap:8px;margin-top:8px;">
                  <button class="small-btn" id="heatmapToggleTools" onclick="toggleHeatmap()" style="flex:1;">🔥 Heatmap: Aus</button>
                  <button class="small-btn" onclick="showHeatmapOptions()" style="flex:1;">⚙️ Einstellungen</button>
                </div>
              </div>
              
              <!-- Systeminfo -->
              <div class="card">
                <h3>⚙️ Systeminfo</h3>
                <div style="font-size:13px;">
                  <div style="display:flex;justify-content:space-between;">
                    <span>Gespeicherte Beobachtungen:</span>
                    <span id="sysObservations">0</span>
                  </div>
                  <div style="display:flex;justify-content:space-between;margin-top:4px;">
                    <span>LocalStorage:</span>
                    <span id="sysStorage">0 KB</span>
                  </div>
                  <div style="display:flex;justify-content:space-between;margin-top:4px;">
                    <span>Offline-Modus:</span>
                    <span id="sysOffline">Aktiv</span>
                  </div>
                  <div style="display:flex;justify-content:space-between;margin-top:4px;">
                    <span>Version:</span>
                    <span>2.1.0</span>
                  </div>
                </div>
                <button class="small-btn" onclick="clearCache()" style="margin-top:12px;width:100%;background:var(--danger);">🧹 Cache leeren</button>
              </div>
            </div>
          </section>

          <!-- Challenges Section -->
          <section id="challenges" class="card" style="display:none;">
            <h2>🏆 Challenges</h2>
            
            <!-- XP & Level Display -->
            <div class="card" style="margin-bottom:16px;background:linear-gradient(135deg, rgba(245,158,11,0.1), rgba(217,119,6,0.05));">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <div>
                  <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
                    <div style="font-size:32px;">⭐</div>
                    <div>
                      <div style="font-size:14px;color:var(--muted);">Dein Level</div>
                      <div style="font-size:28px;font-weight:700;color:var(--text);">
                        Level <span id="challengeLevelDisplay">1</span>
                      </div>
                    </div>
                  </div>
                  <div style="margin-top:12px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                      <span style="font-size:13px;color:var(--muted);">XP Fortschritt</span>
                      <span style="font-size:13px;font-weight:600;color:var(--text);">
                        <span id="challengeXPDisplay">0</span>/<span id="challengeXPNeeded">100</span> XP
                      </span>
                    </div>
                    <div style="width:100%;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;">
                      <div id="challengeProgressBar" style="height:100%;background:linear-gradient(90deg, #f59e0b, #d97706);width:0%;transition:width 0.3s ease;"></div>
                    </div>
                  </div>
                </div>
                <div style="text-align:center;padding:12px;background:rgba(245,158,11,0.1);border-radius:8px;">
                  <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Pro Beobachtung</div>
                  <div class="xp-badge">+10 XP</div>
                </div>
              </div>
              <div style="margin-top:12px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;font-size:12px;color:var(--muted);">
                💡 Verdiene XP durch neue Beobachtungen und steige im Level auf!
              </div>
            </div>
            
            <div style="margin-bottom:20px;">
              <p style="color:var(--muted);font-size:14px;">
                Setze dir Ziele und verfolge deinen Fortschritt! Challenges helfen dir, mehr Vögel zu entdecken und deine Beobachtungsfähigkeiten zu verbessern.
              </p>
            </div>

            <!-- Aktive Challenges -->
            <div class="card" style="margin-bottom:16px;">
              <h3>⚡ Aktive Challenges</h3>
              <div id="activeChallenges">
                <div style="text-align:center;padding:40px 20px;color:var(--muted);">
                  <div style="font-size:48px;margin-bottom:12px;">🎯</div>
                  <p>Noch keine aktiven Challenges</p>
                  <p style="font-size:12px;margin-top:8px;">Wähle unten eine Challenge aus um zu starten!</p>
                </div>
              </div>
            </div>

            <!-- Verfügbare Challenges -->
            <div class="card">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                <h3 style="margin:0;">📋 Verfügbare Challenges</h3>
                <button class="small-btn" onclick="openChallengeCreator()" style="background:var(--accent);color:white;">
                  ➕ Eigene Challenge
                </button>
              </div>
              <div id="availableChallengesGrid" style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 280px), 1fr));gap:12px;margin-top:12px;">
                
                <!-- Challenge: Arten-Sammler -->
                <div class="card" style="background:rgba(6,182,212,0.05);border-left:3px solid #06b6d4;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🐦</span>
                    <strong>Arten-Sammler</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Beobachte 10 verschiedene Vogelarten
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Bronze</span>
                    <button class="small-btn" onclick="startChallenge('species_collector')">Starten</button>
                  </div>
                </div>

                <!-- Challenge: Fleißiger Beobachter -->
                <div class="card" style="background:rgba(124,58,237,0.05);border-left:3px solid #7c3aed;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">📊</span>
                    <strong>Fleißiger Beobachter</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Erfasse 50 Beobachtungen
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Silber</span>
                    <button class="small-btn" onclick="startChallenge('diligent_observer')">Starten</button>
                  </div>
                </div>

                <!-- Challenge: Früher Vogel -->
                <div class="card" style="background:rgba(234,179,8,0.05);border-left:3px solid #eab308;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🌅</span>
                    <strong>Früher Vogel</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Beobachte vor 7:00 Uhr morgens
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Bronze</span>
                    <button class="small-btn" onclick="startChallenge('early_bird')">Starten</button>
                  </div>
                </div>

                <!-- Challenge: Wochenend-Explorer -->
                <div class="card" style="background:rgba(239,68,68,0.05);border-left:3px solid #ef4444;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🗓️</span>
                    <strong>Wochenend-Explorer</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Beobachte an 4 Wochenenden hintereinander
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Gold</span>
                    <button class="small-btn" onclick="startChallenge('weekend_explorer')">Starten</button>
                  </div>
                </div>

                <!-- Challenge: Diversitäts-Champion -->
                <div class="card" style="background:rgba(34,197,94,0.05);border-left:3px solid #22c55e;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🌈</span>
                    <strong>Diversitäts-Champion</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Beobachte Vögel aus 5 verschiedenen Familien
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Platin</span>
                    <button class="small-btn" onclick="startChallenge('diversity_champion')">Starten</button>
                  </div>
                </div>

                <!-- Challenge: Foto-Dokumentar -->
                <div class="card" style="background:rgba(236,72,153,0.05);border-left:3px solid #ec4899;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">📸</span>
                    <strong>Foto-Dokumentar</strong>
                  </div>
                  <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
                    Füge 20 Beobachtungen mit Fotos hinzu
                  </p>
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-size:12px;color:var(--muted);">🏅 Silber</span>
                    <button class="small-btn" onclick="startChallenge('photo_documentarian')">Starten</button>
                  </div>
                </div>

              </div>
            </div>

            <!-- Abgeschlossene Challenges -->
            <div class="card" style="margin-top:16px;">
              <h3>✅ Abgeschlossen</h3>
              <div id="completedChallenges">
                <div style="text-align:center;padding:40px 20px;color:var(--muted);">
                  <div style="font-size:48px;margin-bottom:12px;">🏆</div>
                  <p>Noch keine abgeschlossenen Challenges</p>
                  <p style="font-size:12px;margin-top:8px;">Starte deine erste Challenge!</p>
                </div>
              </div>
            </div>

          </section>

          <!-- Gruppenvergleich -->
          <section id="group-compare" class="card" style="display:none;">
            <div style="background:linear-gradient(135deg, rgba(6,182,212,0.1), rgba(124,58,237,0.05));padding:20px;border-radius:12px;margin-bottom:20px;border:1px solid rgba(6,182,212,0.2);">
              <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
                <div style="font-size:36px;">👥</div>
                <div>
                  <h2 style="margin:0;font-size:24px;">Gruppenvergleich</h2>
                  <p style="margin:4px 0 0 0;color:var(--muted);font-size:13px;">Vergleiche Beobachtungen und Erfolge der Gruppenmitglieder</p>
                </div>
              </div>
            </div>

            <!-- Tab-Navigation -->
            <div style="display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;padding:12px;background:rgba(255,255,255,0.02);border-radius:10px;">
              <button class="small-btn active" id="compareObsTab" onclick="switchCompareTab('observations')" style="flex:1;min-width:140px;padding:10px 14px;font-weight:600;">
                📊 Beobachtungen
              </button>
              <button class="small-btn" id="compareListsTab" onclick="switchCompareTab('lists')" style="flex:1;min-width:140px;padding:10px 14px;font-weight:600;">
                📋 Listen
              </button>
              <button class="small-btn" id="compareRarityTab" onclick="switchCompareTab('rarity2026')" style="flex:1;min-width:140px;padding:10px 14px;font-weight:600;">
                💎 Raritäten
              </button>
              <button class="small-btn" id="compareAchTab" onclick="switchCompareTab('achievements')" style="flex:1;min-width:140px;padding:10px 14px;font-weight:600;">
                🏅 Erfolge
              </button>
              <button class="small-btn" id="compareStatsTab" onclick="switchCompareTab('stats')" style="flex:1;min-width:140px;padding:10px 14px;font-weight:600;">
                📈 Statistiken
              </button>
            </div>

            <!-- Beobachtungs-Vergleich -->
            <div id="compareObservationsView">
              <!-- Leaderboards in Grid Layout -->
              <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 300px), 1fr));gap:16px;margin-bottom:20px;">
                <div class="card" style="background:linear-gradient(135deg, rgba(6,182,212,0.12), rgba(124,58,237,0.06));border-left:4px solid #06b6d4;">
                  <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                    <span style="font-size:28px;">🏆</span>
                    <h3 style="margin:0;">Beobachtungen</h3>
                  </div>
                  <div id="observationLeaderboard">
                    <div class="skeleton-loader">
                      <div class="skeleton skeleton-card"></div>
                      <div class="skeleton skeleton-card"></div>
                      <div class="skeleton skeleton-card"></div>
                    </div>
                  </div>
                </div>
                
                <div class="card" style="background:linear-gradient(135deg, rgba(168,85,247,0.12), rgba(236,72,153,0.06));border-left:4px solid #a855f7;">
                  <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                    <span style="font-size:28px;">🐦</span>
                    <h3 style="margin:0;">Arten</h3>
                  </div>
                  <div id="speciesLeaderboard">
                    <div class="skeleton-loader">
                      <div class="skeleton skeleton-card"></div>
                      <div class="skeleton skeleton-card"></div>
                      <div class="skeleton skeleton-card"></div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Direkter Mitglieder-Vergleich -->
              <div class="card" style="margin-bottom:20px;border-left:4px solid #22c55e;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                  <div style="display:flex;align-items:center;gap:10px;">
                    <span style="font-size:28px;">🔍</span>
                    <h3 style="margin:0;">Direkter Mitglieder-Vergleich</h3>
                  </div>
                  <button class="small-btn" onclick="openDetailedMemberComparison()" style="background:var(--accent);padding:8px 14px;">
                    📊 Detailansicht
                  </button>
                </div>
                <div id="memberComparisonGrid" style="display:grid;grid-template-columns:1fr;gap:12px;">
                  <p style="color:var(--muted);text-align:center;grid-column:1/-1;padding:20px;">Lade Daten...</p>
                </div>
              </div>

              <!-- Detaillierter Vergleich -->
              <div class="card" style="border-left:4px solid #06b6d4;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">📊</span>
                  <h3 style="margin:0;">Detaillierter Vergleich</h3>
                </div>
                <div id="detailedObservationComparison"></div>
              </div>
            </div>

            <!-- Listen-Vergleich -->
            <div id="compareListsView" style="display:none;">
              <div class="card" style="border-left:4px solid #7c3aed;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                  <div>
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px;">
                      <span style="font-size:28px;">📁</span>
                      <h3 style="margin:0;">Vergleichs-Ordner</h3>
                    </div>
                    <p style="margin:0;color:var(--muted);font-size:13px;">
                      Erstelle Ordner und lade Listen zum Vergleich ein
                    </p>
                  </div>
                  <button class="small-btn" onclick="openCreateComparisonFolderModal()" style="background:var(--accent);color:white;padding:8px 14px;font-weight:600;">
                    ➕ Ordner erstellen
                  </button>
                </div>
                <div id="comparisonFoldersList">
                  <div style="text-align:center;padding:40px 20px;color:var(--muted);">
                    <div style="font-size:48px;margin-bottom:12px;">📁</div>
                    <p>Noch keine Vergleichs-Ordner</p>
                    <p style="font-size:12px;margin-top:8px;">Erstelle einen Ordner um Listen zu vergleichen!</p>
                  </div>
                </div>
              </div>
            </div>

            <!-- Rarität-Challenge 2026 -->
            <div id="compareRarity2026View" style="display:none;">
              <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg, rgba(234,179,8,0.18), rgba(217,119,6,0.08));border:2px solid rgba(234,179,8,0.4);border-left:6px solid #f59e0b;">
                <div style="text-align:center;padding:24px;">
                  <div style="font-size:56px;margin-bottom:16px;">💎</div>
                  <h2 style="margin:0 0 8px 0;font-size:28px;font-weight:700;">Rarität-Challenge <span id="rarityChallengeYearTitle">2025</span></h2>
                  <p style="color:var(--soft);font-size:15px;margin:0;">
                    Wer findet die meisten seltenen Arten im ausgewählten Jahr?
                  </p>
                  
                  <!-- Jahr-Auswahl -->
                  <div style="margin-top:20px;margin-bottom:20px;">
                    <label style="font-size:14px;color:var(--soft);margin-right:8px;font-weight:600;">📅 Jahr auswählen:</label>
                    <select id="rarityChallengeYearSelect" class="input" style="padding:8px 16px;border-radius:8px;background:rgba(255,255,255,0.08);border:1px solid rgba(234,179,8,0.3);color:var(--text);font-weight:600;font-size:14px;" onchange="changeRarityChallengeYear()">
                      <option value="2022">2022</option>
                      <option value="2023">2023</option>
                      <option value="2024">2024</option>
                      <option value="2025">2025</option>
                      <option value="2026" selected>2026</option>
                      <option value="2027">2027</option>
                      <option value="2028">2028</option>
                      <option value="all">Alle Jahre</option>
                    </select>
                  </div>
                  
                  <div style="margin-top:20px;padding:16px;background:rgba(255,255,255,0.06);border-radius:10px;text-align:left;max-width:500px;margin-left:auto;margin-right:auto;border:1px solid rgba(234,179,8,0.2);">
                    <div style="font-weight:700;margin-bottom:12px;font-size:14px;color:#eab308;">📊 Punktesystem:</div>
                    <div style="font-size:13px;line-height:2;color:var(--text);">
                      • Seltene Art: <strong style="color:#eab308;">1 Punkt</strong><br>
                      • Sehr seltene Art: <strong style="color:#f59e0b;">2 Punkte</strong><br>
                      • Seltene Art + Selffound: <strong style="color:#10b981;">3 Punkte</strong><br>
                      • Sehr seltene Art + Selffound: <strong style="color:#22c55e;">5 Punkte</strong>
                    </div>
                    <div style="margin-top:14px;padding:10px;background:rgba(239,68,68,0.12);border-radius:8px;border-left:3px solid #ef4444;font-size:12px;color:var(--text);line-height:1.6;">
                      <strong>🚫 Anti-Duplikat-Regel (nur eigene Meldungen):</strong> Wurde eine seltene Art bereits <strong>von dir selbst</strong> in den <strong>letzten 3 Wochen</strong> im <strong>Umkreis von 3km</strong> gemeldet, bringt sie keine weiteren Punkte. So wird verhindert, dass du dieselbe überwinternde Seltenheit mehrfach zählst. Meldungen anderer Gruppenmitglieder blockieren deine Punkte nicht!
                    </div>
                    <div style="margin-top:10px;padding:10px;background:rgba(6,182,212,0.08);border-radius:8px;border-left:3px solid #06b6d4;font-size:12px;color:var(--soft);line-height:1.6;">
                      <strong>💡 Beispiel:</strong> Ein Ohrentaucher (selten) gibt 1 Punkt. Als Selffound gibt er 3 Punkte!
                    </div>
                  </div>
                </div>
              </div>

              <!-- Leaderboard -->
              <div class="card" style="margin-bottom:20px;border-left:4px solid #eab308;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">🏆</span>
                  <h3 style="margin:0;">Leaderboard <span id="rarityLeaderboardYearTitle">2025</span></h3>
                </div>
                <div id="rarityLeaderboard2026">
                  <div class="skeleton-loader">
                    <div class="skeleton skeleton-card"></div>
                    <div class="skeleton skeleton-card"></div>
                    <div class="skeleton skeleton-card"></div>
                  </div>
                </div>
              </div>

              <!-- Detaillierte Statistiken -->
              <div class="card" style="border-left:4px solid #06b6d4;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">📊</span>
                  <h3 style="margin:0;">Detaillierte Statistiken</h3>
                </div>
                <div id="rarityDetailedStats2026"></div>
              </div>
            </div>

            <!-- Erfolgs-Vergleich -->
            <div id="compareAchievementsView" style="display:none;">
              <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg, rgba(124,58,237,0.12), rgba(6,182,212,0.06));border-left:4px solid #7c3aed;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">🏆</span>
                  <h3 style="margin:0;">Leaderboard - Erfolge</h3>
                </div>
                <div id="achievementLeaderboard">
                  <div style="text-align:center;padding:20px;color:var(--muted);">
                    <div style="font-size:32px;margin-bottom:8px;">🏅</div>
                    <p style="margin:0;">Lade Erfolge...</p>
                  </div>
                </div>
              </div>

              <div class="card" style="border-left:4px solid #22c55e;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">🎯</span>
                  <h3 style="margin:0;">Erfolgs-Vergleich</h3>
                </div>
                <div id="detailedAchievementComparison"></div>
              </div>
            </div>

            <!-- Statistik-Vergleich -->
            <div id="compareStatsView" style="display:none;">
              <div class="card" style="margin-bottom:20px;border-left:4px solid #06b6d4;">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                  <span style="font-size:28px;">📈</span>
                  <h3 style="margin:0;">Gruppen-Statistiken im Überblick</h3>
                </div>
                <div id="groupStatsOverview"></div>
              </div>

              <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 280px), 1fr));gap:16px;">
                <div class="card" style="border-left:4px solid #22c55e;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🐦</span>
                    <h4 style="margin:0;">Meiste einzigartige Arten</h4>
                  </div>
                  <div id="topSpeciesFinders"></div>
                </div>
                
                <div class="card" style="border-left:4px solid #ec4899;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">📸</span>
                    <h4 style="margin:0;">Meiste Fotos</h4>
                  </div>
                  <div id="topPhotoTakers"></div>
                </div>
                
                <div class="card" style="border-left:4px solid #f59e0b;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span style="font-size:24px;">🔥</span>
                    <h4 style="margin:0;">Längste Streak</h4>
                  </div>
                  <div id="topStreaks"></div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <aside>
          <!-- Karte -->
          <div id="mapCard" class="card">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <h2 style="margin:0;">Karte</h2>
              <div style="display:flex;gap:4px;">
                <button class="small-btn" onclick="locateUser()" title="Zu meinem Standort">📍</button>
                <button class="small-btn" onclick="printMap()" title="Karte drucken">🖨️</button>
              </div>
            </div>
            <p style="margin:0 0 12px 0; font-size:13px; color:var(--muted);">Klicke auf die Karte, um einen Vogel zu melden.</p>
            <div id="map" style="margin:12px 0;"></div>
            <div class="form-row" style="margin:12px 0;">
              <button id="toggleMarkersLock" class="small-btn" style="background:var(--danger);" onclick="toggleMarkersLock()">🔒 Marker gesperrt</button>
              <button id="toggleDragMode" class="small-btn" style="background:var(--accent);">Verschieben: An</button>
              <button id="clearMarkers" class="small-btn">Alle löschen</button>
              <button id="exitMapView" class="small-btn" style="background:var(--accent); color:white;">← Zurück</button>
            </div>
            <div id="markerLockHint" style="font-size: 12px; color: var(--danger); padding: 8px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; margin-bottom: 12px; text-align: center;">
              🔒 Marker sind gesperrt. Klicke auf "🔒 Marker gesperrt" zum Entsperren.
            </div>
            <div class="marker-list" id="markerList" style="margin:12px 0;">
              <div class="muted">Keine Punkte</div>
            </div>
            
            <!-- Gruppen-Legende (nur im Gruppenmodus sichtbar) -->
            <div id="groupMarkerLegend" style="display:none;" class="group-legend">
              <div class="group-legend-title">👥 Gruppenmitglieder</div>
              <div id="groupLegendItems">
                <!-- Wird dynamisch gefüllt -->
              </div>
            </div>
          </div>

          <!-- Erweiterte Filter -->
          <div class="card filter-system" style="margin-top:12px;">
            <h3 style="margin-top:0;">🔍 Erweiterte Filter</h3>
            
            <div class="filter-group">
              <label>Zeitraum:</label>
              <div class="form-row">
                <input type="date" id="filterDateFrom" style="flex:1;">
                <input type="date" id="filterDateTo" style="flex:1;">
              </div>
            </div>
            
            <div class="filter-group">
              <label>Vogelart:</label>
              <select id="filterSpecies" style="width:100%;">
                <option value="">Alle Arten</option>
              </select>
            </div>
            
            <div class="filter-group">
              <label>Wetterbedingungen:</label>
              <select id="filterWeather" style="width:100%;">
                <option value="">Alle</option>
                <option value="sunny">Sonnig</option>
                <option value="cloudy">Bewölkt</option>
                <option value="rainy">Regnerisch</option>
                <option value="snowy">Schnee</option>
              </select>
            </div>
            
            <div class="filter-group">
              <label>Bundesland:</label>
              <select id="filterState" style="width:100%;">
                <option value="">Alle Bundesländer</option>
              </select>
            </div>
            
            <div class="form-row">
              <button class="small-btn" onclick="applyFilters()" style="flex:1;background:var(--accent);">Filter anwenden</button>
              <button class="small-btn" onclick="resetFilters()">Zurücksetzen</button>
            </div>
          </div>

          <!-- Quick Stats -->
          <div class="card" style="margin-top:12px;">
            <h3 style="margin-top:0;">📊 Schnellstatistik</h3>
            <div id="quickStats">
              <div class="muted">Lade Statistik...</div>
            </div>
            <div class="form-row" style="margin-top:12px;">
              <button class="small-btn" onclick="updateQuickStats()" style="flex:1;">Aktualisieren</button>
              <button class="small-btn" onclick="exportQuickStats()">Export</button>
            </div>
          </div>
        </aside>
      </div>
    </main>
  </div>

  <!-- NEU: Quick-Add Modal (Schnelleingabe) -->
  <div id="quickAddModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.85);backdrop-filter:blur(4px);align-items:center;justify-content:center;z-index:10001;animation:fadeIn 0.2s ease;">
    <div style="background:linear-gradient(180deg, var(--card), rgba(11,18,32,0.98));padding:24px;border-radius:16px;width:420px;max-width:90vw;border:2px solid var(--accent);box-shadow:0 20px 60px rgba(6,182,212,0.3);animation:slideInUp 0.3s ease;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <div>
          <h3 style="margin:0;font-size:20px;display:flex;align-items:center;gap:10px;">
            <span style="font-size:28px;">⚡</span>
            Schnelleingabe
          </h3>
          <p style="margin:4px 0 0 0;font-size:12px;color:var(--muted);">Nur das Wichtigste - schnell erfasst</p>
        </div>
        <button onclick="closeQuickAdd()" style="background:rgba(255,255,255,0.05);border:none;color:var(--muted);width:32px;height:32px;border-radius:8px;cursor:pointer;font-size:18px;transition:all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.2)';this.style.color='var(--danger)'" onmouseout="this.style.background='rgba(255,255,255,0.05)';this.style.color='var(--muted)'">✕</button>
      </div>
      
      <div style="display:flex;flex-direction:column;gap:14px;">
        <!-- Vogelart -->
        <div>
          <label style="font-size:13px;color:var(--muted);margin-bottom:6px;display:block;font-weight:600;">🐦 Vogelart *</label>
          <input id="quickAddBird" type="text" list="quickBirdSuggestions" 
                 style="width:100%;padding:12px;border-radius:10px;border:2px solid rgba(6,182,212,0.3);background:rgba(255,255,255,0.03);color:var(--text);font-size:15px;transition:all 0.2s;" 
                 placeholder="z.B. Amsel"
                 onfocus="this.style.borderColor='var(--accent)';this.style.background='rgba(6,182,212,0.05)'"
                 onblur="this.style.borderColor='rgba(6,182,212,0.3)';this.style.background='rgba(255,255,255,0.03)'" />
          <datalist id="quickBirdSuggestions"></datalist>
        </div>
        
        <!-- Anzahl -->
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div>
            <label style="font-size:13px;color:var(--muted);margin-bottom:6px;display:block;font-weight:600;">📊 Anzahl</label>
            <input id="quickAddCount" type="number" min="1" value="1"
                   style="width:100%;padding:12px;border-radius:10px;border:2px solid rgba(6,182,212,0.3);background:rgba(255,255,255,0.03);color:var(--text);font-size:15px;"
                   onfocus="this.style.borderColor='var(--accent)';this.style.background='rgba(6,182,212,0.05)'"
                   onblur="this.style.borderColor='rgba(6,182,212,0.3)';this.style.background='rgba(255,255,255,0.03)'" />
          </div>
          
          <div>
            <label style="font-size:13px;color:var(--muted);margin-bottom:6px;display:block;font-weight:600;">📅 Datum</label>
            <input id="quickAddDate" type="date"
                   style="width:100%;padding:12px;border-radius:10px;border:2px solid rgba(6,182,212,0.3);background:rgba(255,255,255,0.03);color:var(--text);font-size:15px;"
                   onfocus="this.style.borderColor='var(--accent)';this.style.background='rgba(6,182,212,0.05)'"
                   onblur="this.style.borderColor='rgba(6,182,212,0.3)';this.style.background='rgba(255,255,255,0.03)'" />
          </div>
        </div>
        
        <!-- Optional: Notiz -->
        <div>
          <label style="font-size:13px;color:var(--muted);margin-bottom:6px;display:block;font-weight:600;">💬 Notiz (optional)</label>
          <input id="quickAddNote" type="text"
                 style="width:100%;padding:12px;border-radius:10px;border:2px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.02);color:var(--text);font-size:14px;"
                 placeholder="z.B. Singend auf Dach"
                 onfocus="this.style.borderColor='rgba(6,182,212,0.3)';this.style.background='rgba(255,255,255,0.03)'"
                 onblur="this.style.borderColor='rgba(255,255,255,0.1)';this.style.background='rgba(255,255,255,0.02)'" />
        </div>
        
        <!-- Info-Box -->
        <div style="background:linear-gradient(135deg, rgba(6,182,212,0.1), rgba(124,58,237,0.05));padding:12px;border-radius:10px;border-left:3px solid var(--accent);font-size:12px;color:var(--soft);">
          <strong>💡 Tipp:</strong> Standort wird automatisch erkannt. Weitere Details kannst du später hinzufügen!
        </div>
        
        <!-- Buttons -->
        <div style="display:flex;gap:10px;margin-top:8px;">
          <button onclick="closeQuickAdd()" class="small-btn" style="flex:1;background:rgba(239,68,68,0.15);color:#ef4444;border:1px solid rgba(239,68,68,0.3);padding:12px;font-size:14px;font-weight:600;transition:all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.25)'" onmouseout="this.style.background='rgba(239,68,68,0.15)'">
            Abbrechen
          </button>
          <button onclick="saveQuickAdd()" class="small-btn" style="flex:2;background:linear-gradient(135deg, var(--accent), var(--accent-2));color:white;border:none;padding:12px;font-size:14px;font-weight:600;box-shadow:0 4px 12px rgba(6,182,212,0.3);transition:all 0.2s;" onmouseover="this.style.transform='translateY(-2px)';this.style.boxShadow='0 6px 20px rgba(6,182,212,0.4)'" onmouseout="this.style.transform='';this.style.boxShadow='0 4px 12px rgba(6,182,212,0.3)'">
            ⚡ Schnell speichern
          </button>
        </div>
        
        <!-- Keyboard Shortcut Hinweis -->
        <div style="text-align:center;font-size:11px;color:var(--muted);margin-top:4px;">
          Tastenkürzel: <kbd style="background:rgba(255,255,255,0.1);padding:2px 6px;border-radius:4px;font-family:monospace;">Strg+Q</kbd>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for name + date input -->
  <div id="modalBackdrop" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.6);align-items:center;justify-content:center;z-index:9999;">
    <div style="background:var(--card);padding:18px;border-radius:12px;width:360px;border:1px solid rgba(255,255,255,0.03);">
      <h3 style="margin:0 0 8px 0;" id="modalTitle">Vogelbeobachtung eingeben</h3>
      <div style="display:flex;flex-direction:column;gap:8px;">
        <label style="font-size:13px;color:var(--muted)" id="modalLabel1">Vogelart *</label>
        <input id="modalName" type="text" style="padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" placeholder="z.B. Amsel, Rotkehlchen..." />
        <label style="font-size:13px;color:var(--muted)" id="modalLabel2">Beobachtungsdatum</label>
        <input id="modalDate" type="date" style="padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" />
        
        <!-- Seltenheits-Regler -->
        <label style="font-size:13px;color:var(--muted);margin-top:8px;">Seltenheit (optional)</label>
        <div style="display:flex;flex-direction:column;gap:8px;padding:10px;background:rgba(255,255,255,0.02);border-radius:8px;">
          <input type="range" id="modalRarity" min="0" max="3" value="0" step="1" 
                 style="width:100%;accent-color:var(--accent);" 
                 oninput="updateRarityLabel(this.value)">
          <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--muted);">
            <span>Häufig</span>
            <span>Selten</span>
            <span>Sehr selten</span>
            <span>Escape</span>
          </div>
          <div id="rarityLabel" style="text-align:center;font-size:13px;color:var(--text);font-weight:600;">
            Standard (aus Datenbank)
          </div>
        </div>
        
        <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:6px;">
          <button id="modalCancel" class="small-btn" style="background:var(--danger)">Abbrechen</button>
          <button id="modalOk" class="small-btn" style="background:var(--success)">Speichern</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Vogelarten Guide Modal -->
  <div id="speciesGuideModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.8);align-items:center;justify-content:center;z-index:10000;padding:20px;">
    <div style="background:var(--card);padding:24px;border-radius:16px;max-width:800px;max-height:80vh;overflow-y:auto;width:100%;border:1px solid rgba(255,255,255,0.03);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
        <h2 style="margin:0;">🐦 Vogelbestimmungshilfe</h2>
        <button class="small-btn" onclick="document.getElementById('speciesGuideModal').style.display='none'">✕</button>
      </div>
      <div id="speciesGuideContent">
        <div class="muted">Lade Bestimmungshilfe...</div>
      </div>
    </div>
  </div>

  <!-- Wetter Modal -->
  <div id="weatherModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.8);align-items:center;justifycontent:center;z-index:10000;">
    <div style="background:var(--card);padding:24px;border-radius:16px;width:400px;border:1px solid rgba(255,255,255,0.03);">
      <h3 style="margin:0 0 12px 0;">🌤️ Wetterdaten</h3>
      <div id="weatherData">
        <div class="muted">Lade Wetterdaten...</div>
      </div>
      <div style="display:flex;justify-content:flex-end;margin-top:16px;">
        <button class="small-btn" onclick="document.getElementById('weatherModal').style.display='none'">Schließen</button>
      </div>
    </div>
  </div>

  <!-- NEU: Ordnererstellung Modal -->
  <div id="newFolderModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.8);align-items:center;justify-content:center;z-index:10000;">
    <div style="background:var(--card);padding:24px;border-radius:16px;width:360px;border:1px solid rgba(255,255,255,0.03);">
      <h3 style="margin:0 0 16px 0;">📁 Neuen Ordner erstellen</h3>
      <div style="display:flex;flex-direction:column;gap:12px;">
        <input type="text" id="newFolderName" placeholder="Ordnername" style="padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);">
        
        <div>
          <div style="font-size:13px;color:var(--muted);margin-bottom:8px;">Farbe:</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;" id="folderColorPicker">
            <!-- Farben werden dynamisch geladen -->
          </div>
        </div>
        
        <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:16px;">
          <button class="small-btn" onclick="closeNewFolderModal()" style="background:var(--danger);">Abbrechen</button>
          <button class="small-btn" onclick="saveNewFolderFromInput()" style="background:var(--success);">Erstellen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Neue Liste Modal MIT POLYGON-ERWEITERUNG -->
  <div id="createListModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="createListModalTitle">📋 Neue Liste erstellen</h2>
        <p class="modal-subtitle">Definiere Kriterien für deine benutzerdefinierte Vogelbeobachtungsliste</p>
      </div>
      
      <div class="form-group">
        <label class="form-label">Listenname *</label>
        <input type="text" id="listName" class="input" placeholder="z.B. Seltene Arten 2024" style="width:100%;">
      </div>
      
      <div class="form-group">
        <label class="form-label">Beschreibung</label>
        <textarea id="listDescription" class="input" placeholder="Beschreibe den Zweck dieser Liste..." rows="3" style="width:100%;resize:vertical;"></textarea>
      </div>
      
      <div class="form-group">
        <label class="form-label">Tags</label>
        <div class="tag-input" id="tagInputContainer">
          <input type="text" id="tagInput" placeholder="Tag hinzufügen...">
        </div>
        <div class="form-hint">Drücke Enter um einen Tag hinzuzufügen</div>
      </div>
      
      <!-- NEU: Zeitraum-Auswahl -->
      <div class="form-group">
        <label class="form-label">📅 Zeitraum</label>
        <div style="background: var(--glass); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.02);">
          <div style="display: flex; gap: 12px; margin-bottom: 12px;">
            <div style="flex: 1;">
              <label style="font-size: 12px; color: var(--muted); display: block; margin-bottom: 4px;">Von (optional)</label>
              <input type="date" id="listTimeRangeFrom" class="input" style="width: 100%;">
            </div>
            <div style="flex: 1;">
              <label style="font-size: 12px; color: var(--muted); display: block; margin-bottom: 4px;">Bis (optional)</label>
              <input type="date" id="listTimeRangeTo" class="input" style="width: 100%;">
            </div>
          </div>
          <div style="font-size: 12px; color: var(--muted);">
            Lege fest, welche Beobachtungen zeitlich einbezogen werden sollen. Leer lassen für alle Beobachtungen.
          </div>
        </div>
      </div>
      
      <div class="form-group">
        <label class="form-label">Filterkriterien</label>
        <div class="checkbox-grid">
          <label class="checkbox-item">
            <input type="checkbox" id="filterBySpecies">
            <span class="checkbox-label">Nach Vogelart filtern</span>
          </label>
          <label class="checkbox-item">
            <input type="checkbox" id="filterByDate">
            <span class="checkbox-label">Nach Zeitraum filtern</span>
          </label>
          <label class="checkbox-item">
            <input type="checkbox" id="filterByLocation">
            <span class="checkbox-label">Nach Standort filtern</span>
          </label>
          <label class="checkbox-item">
            <input type="checkbox" id="filterByWeather">
            <span class="checkbox-label">Nach Wetter filtern</span>
          </label>
        </div>
      </div>
      
      <div id="filterDetails" style="display:none;">
        <div class="form-group">
          <label class="form-label">Vogelart</label>
          <select id="listSpeciesFilter" class="input" style="width:100%;">
            <option value="">Alle Arten</option>
          </select>
        </div>
        
        <div class="form-group">
          <label class="form-label">Zeitraum</label>
          <div style="display:flex;gap:8px;">
            <input type="date" id="listDateFrom" class="input" style="flex:1;" placeholder="Von">
            <input type="date" id="listDateTo" class="input" style="flex:1;" placeholder="Bis">
          </div>
        </div>
      </div>

      <!-- NEU: Polygon-Erweiterung -->
      <div class="form-group">
        <label class="form-label">🗺️ Geografischer Filter (Polygon)</label>
        <div class="polygon-creation" id="polygonCreation">
          <div class="polygon-instructions">
            <p>Zeichne ein Polygon auf der Karte, um Beobachtungen auf dieses Gebiet zu beschränken.</p>
            <ol style="margin: 8px 0 8px 16px; padding: 0;">
              <li>Klicke auf "Polygon zeichnen" um zur Karte zu wechseln</li>
              <li>Klicke auf die Karte, um Eckpunkte zu setzen</li>
              <li>Klicke "Fertig", wenn das Polygon komplett ist</li>
            </ol>
          </div>
          
          <div id="polygonStatus" class="polygon-status" style="display: none;">
            <span>●</span> <span id="polygonPointCount">0 Punkte</span>
          </div>
          
          <div id="polygonPointsList" class="polygon-points" style="display: none;">
            <!-- Punkte werden hier dynamisch hinzugefügt -->
          </div>
          
          <div id="polygonSummary" class="polygon-summary" style="display: none;">
            <strong>Polygon aktiv</strong>
            <div id="polygonArea">Bereich wird berechnet...</div>
          </div>
          
          <div class="polygon-actions">
            <button type="button" class="small-btn" onclick="startDrawingPolygonForList()" id="drawPolygonBtn">
              📐 Polygon zeichnen
            </button>
            <button type="button" class="small-btn" onclick="clearPolygon()" id="clearPolygonBtn" style="background: var(--danger); display: none;">
              ❌ Löschen
            </button>
            <button type="button" class="small-btn" onclick="finishDrawingPolygon()" id="finishPolygonBtn" style="display: none; background: var(--success);">
              ✓ Fertig
            </button>
          </div>
          
          <!-- Verstecktes Feld für Polygon-Daten -->
          <input type="hidden" id="polygonData" name="polygonData">
        </div>
      </div>
      
      <!-- NEU: Bundesland-Filter -->
      <div class="form-group">
        <label class="form-label">🏛️ Bundesland-Filter</label>
        <div style="background: var(--glass); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.02);">
          <select id="listStateFilter" class="input" style="width: 100%;">
            <option value="">Alle Bundesländer</option>
            <option value="Baden-Württemberg">Baden-Württemberg</option>
            <option value="Bayern">Bayern</option>
            <option value="Berlin">Berlin</option>
            <option value="Brandenburg">Brandenburg</option>
            <option value="Bremen">Bremen</option>
            <option value="Hamburg">Hamburg</option>
            <option value="Hessen">Hessen</option>
            <option value="Mecklenburg-Vorpommern">Mecklenburg-Vorpommern</option>
            <option value="Niedersachsen">Niedersachsen</option>
            <option value="Nordrhein-Westfalen">Nordrhein-Westfalen</option>
            <option value="Rheinland-Pfalz">Rheinland-Pfalz</option>
            <option value="Saarland">Saarland</option>
            <option value="Sachsen">Sachsen</option>
            <option value="Sachsen-Anhalt">Sachsen-Anhalt</option>
            <option value="Schleswig-Holstein">Schleswig-Holstein</option>
            <option value="Thüringen">Thüringen</option>
          </select>
          <div style="font-size: 12px; color: var(--muted); margin-top: 8px;">
            Zeige nur Beobachtungen aus dem gewählten Bundesland an (automatische Erkennung über Koordinaten)
          </div>
        </div>
      </div>
      
      <!-- NEU: Beobachtungsmodus -->
      <div class="form-group">
        <label class="form-label">📊 Zählmodus</label>
        <div style="background: var(--glass); padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.02);">
          <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer; margin-bottom: 12px;">
            <input type="radio" name="observationMode" id="modeAllObservations" value="all" checked style="margin-top: 2px;">
            <div style="flex: 1;">
              <div style="font-weight: 600; margin-bottom: 4px;">Alle Beobachtungen</div>
              <div style="font-size: 12px; color: var(--muted);">Zähle jede einzelne Beobachtung einer Art</div>
            </div>
          </label>
          <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
            <input type="radio" name="observationMode" id="modeFirstObservations" value="first" style="margin-top: 2px;">
            <div style="flex: 1;">
              <div style="font-weight: 600; margin-bottom: 4px;">Nur Erstbeobachtungen</div>
              <div style="font-size: 12px; color: var(--muted);">Zähle nur die erste Beobachtung pro Art (nützlich für Artenlisten)</div>
            </div>
          </label>
        </div>
      </div>
      
      <div class="form-group">
        <label class="form-label">Listenfarbe</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap;" id="colorPicker">
          <div class="color-option" style="background:#06b6d4;" data-color="#06b6d4"></div>
          <div class="color-option" style="background:#7c3aed;" data-color="#7c3aed"></div>
          <div class="color-option" style="background:#10b981;" data-color="#10b981"></div>
          <div class="color-option" style="background:#ef4444;" data-color="#ef4444"></div>
          <div class="color-option" style="background:#f59e0b;" data-color="#f59e0b"></div>
          <div class="color-option" style="background:#84cc16;" data-color="#84cc16"></div>
          <div class="color-option" style="background:#14b8a6;" data-color="#14b8a6"></div>
          <div class="color-option" style="background:#8b5cf6;" data-color="#8b5cf6"></div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button class="btn ghost" onclick="closeCreateListModal()">Abbrechen</button>
        <button class="btn" id="saveListButton" onclick="saveNewList()">Liste erstellen</button>
      </div>
    </div>
  </div>

  <!-- In Gruppe kopieren Modal -->
  <div id="copyToGroupModal" class="modal-overlay" style="display:none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header">
        <h2 class="modal-title">👥 Beobachtungen in Gruppe kopieren</h2>
        <p class="modal-subtitle">Wähle die Beobachtungen aus, die du in die Gruppe kopieren möchtest</p>
      </div>
      
      <div style="margin-bottom:16px;padding:12px;background:rgba(6,182,212,0.05);border-radius:8px;border-left:3px solid var(--accent);">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
          <span style="font-weight:600;">📍 Zielgruppe:</span>
          <span id="copyModalTargetGroup" style="color:var(--accent);">-</span>
        </div>
        <div style="font-size:12px;color:var(--muted);">
          Die ausgewählten Beobachtungen werden in diese Gruppe kopiert (nicht verschoben)
        </div>
      </div>

      <!-- Filter und Auswahl -->
      <div style="display:flex;gap:8px;margin-bottom:12px;">
        <button class="small-btn" onclick="selectAllObservations()">✓ Alle auswählen</button>
        <button class="small-btn" onclick="deselectAllObservations()">✗ Alle abwählen</button>
        <div style="flex:1;"></div>
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="font-size:13px;color:var(--muted);">Ausgewählt:</span>
          <span id="selectedObsCount" style="font-weight:600;color:var(--accent);">0</span>
        </div>
      </div>

      <!-- Beobachtungsliste mit Checkboxen -->
      <div id="observationSelectionList" style="max-height:400px;overflow-y:auto;border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:12px;background:rgba(255,255,255,0.01);">
        <div style="text-align:center;padding:40px;color:var(--muted);">
          <div style="font-size:32px;margin-bottom:8px;">📋</div>
          <p>Lade Beobachtungen...</p>
        </div>
      </div>

      <div class="modal-footer" style="margin-top:16px;">
        <button class="btn ghost" onclick="closeCopyToGroupModal()">Abbrechen</button>
        <button class="btn" onclick="copySelectedObservationsToGroup()" style="background:var(--accent);">
          <span id="copyBtnText">📤 In Gruppe kopieren</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Polygon-Zeichen-Modal -->
  <div id="polygonDrawingModal" class="modal-overlay" style="display: none;">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h2 class="modal-title">📐 Polygon zeichnen</h2>
        <button class="small-btn" onclick="closePolygonDrawing()" style="position:absolute;top:32px;right:32px;">✕</button>
      </div>
      
      <div class="polygon-instructions" style="margin: 20px 0;">
        <p><strong>Anleitung:</strong></p>
        <ol>
          <li>Klicke auf die Karte, um Eckpunkte des Polygons zu setzen</li>
          <li>Das Polygon wird automatisch geschlossen (letzter Punkt verbindet sich mit erstem)</li>
          <li>Mindestens 3 Punkte sind erforderlich</li>
          <li>Klicke "Polygon fertigstellen" wenn du zufrieden bist</li>
          <li>Klicke "Zurücksetzen" um neu zu beginnen</li>
        </ol>
        <p id="drawingStatus" style="margin-top: 12px; color: var(--accent); font-weight: 600;">● Zeichenmodus aktiv</p>
      </div>
      
      <div id="polygonMapContainer" style="height: 400px; border-radius: 12px; overflow: hidden; margin-bottom: 20px;">
        <div id="polygonMap" style="height: 100%;"></div>
      </div>
      
      <div class="polygon-actions" style="justify-content: center;">
        <button class="small-btn" onclick="resetPolygonDrawing()" style="background: var(--danger);">
          🔄 Zurücksetzen
        </button>
        <button class="small-btn" onclick="finishPolygonDrawing()" style="background: var(--success);">
          ✓ Polygon fertigstellen
        </button>
      </div>
    </div>
  </div>

  <!-- Listen Detail Ansicht -->
  <div id="listDetailView" class="list-detail-view">
    <div class="list-detail-header">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;">
        <div>
          <h1 id="detailListName" style="margin:0;font-size:28px;"></h1>
          <p id="detailListDescription" class="muted" style="margin-top:8px;font-size:16px;"></p>
          <div id="detailListTags" class="list-tags" style="margin-top:12px;"></div>
        </div>
        <button class="small-btn" onclick="closeListDetail()">✕ Schließen</button>
      </div>
      
      <div class="list-detail-actions">
        <button class="small-btn" onclick="editCurrentList()">✏️ Bearbeiten</button>
        <button class="small-btn" onclick="exportCurrentList()">📤 Export</button>
        <button class="small-btn" onclick="deleteCurrentList()" style="background:var(--danger);">🗑️ Löschen</button>
      </div>
    </div>
    
    <div class="list-observations-table">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h3 style="margin:0;">📊 Beobachtungen in dieser Liste</h3>
        
        <!-- View Mode Toggle -->
        <div style="display:flex;gap:8px;background:rgba(255,255,255,0.02);padding:4px;border-radius:8px;">
          <button class="list-view-btn active" data-view="observations" onclick="switchListView('observations')" style="padding:6px 12px;border-radius:6px;border:none;background:transparent;color:var(--text);cursor:pointer;font-weight:600;font-size:13px;transition:all 0.2s;">
            📋 Beobachtungen
          </button>
          <button class="list-view-btn" data-view="simple" onclick="switchListView('simple')" style="padding:6px 12px;border-radius:6px;border:none;background:transparent;color:var(--muted);cursor:pointer;font-weight:600;font-size:13px;transition:all 0.2s;">
            📝 Liste
          </button>
          <button class="list-view-btn" data-view="lifelist" onclick="switchListView('lifelist')" style="padding:6px 12px;border-radius:6px;border:none;background:transparent;color:var(--muted);cursor:pointer;font-weight:600;font-size:13px;transition:all 0.2s;">
            🔢 Life List
          </button>
        </div>
      </div>
      
      <div id="listObservations">
        <div class="empty-state">
          <div class="empty-state-icon">🔍</div>
          <div class="empty-state-title">Keine Beobachtungen gefunden</div>
          <div class="empty-state-description">Diese Liste enthält noch keine Beobachtungen oder die Filterkriterien treffen auf keine vorhandenen Daten zu.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Beobachtungsdetail Modal -->
  <div id="observationDetailModal" class="modal-overlay" style="display:none;">
    <div class="modal-content" style="max-width:800px;">
      <div class="modal-header">
        <h2 class="modal-title" id="detailModalTitle">Beobachtungsdetails</h2>
        <button class="small-btn" onclick="closeObservationDetail()" style="position:absolute;top:32px;right:32px;">✕</button>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:24px;margin-top:24px;">
        <!-- Linke Spalte: Details und Foto -->
        <div>
          <div class="card" style="margin-bottom:16px;">
            <h3 style="margin:0 0 16px 0;">📋 Details</h3>
            <div id="detailModalContent">
              <!-- Details werden hier eingefügt -->
            </div>
          </div>
          
          <div class="card" id="detailPhotoContainer" style="display:none;">
            <h3 style="margin:0 0 16px 0;">📸 Foto</h3>
            <img id="detailPhoto" src="" alt="Beobachtungsfoto" style="width:100%;max-height:600px;height:auto;object-fit:contain;border-radius:8px;cursor:pointer;">
          </div>
        </div>
        
        <!-- Rechte Spalte: Karte -->
        <div>
          <div class="card" style="height:100%;">
            <h3 style="margin:0 0 16px 0;">🗺️ Standort</h3>
            <div id="detailMap" style="height:300px;border-radius:8px;overflow:hidden;"></div>
            <div id="detailNoMap" style="display:none;text-align:center;padding:40px 20px;">
              <div style="font-size:48px;margin-bottom:16px;">🗺️</div>
              <div class="muted">Keine Koordinaten für diese Beobachtung vorhanden</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="modal-footer">
        <button class="btn ghost" onclick="closeObservationDetail()">Schließen</button>
        <button class="btn" onclick="deleteCurrentObservation()" style="background:var(--danger);">🗑️ Löschen</button>
        <button class="btn" onclick="editObservation()" id="editObservationBtn">✏️ Bearbeiten</button>
      </div>
    </div>
  </div>

  <!-- NEU: Foto-Lightbox -->
  <div id="photoLightbox" class="photo-lightbox">
    <button class="lightbox-close" onclick="closePhotoLightbox()">✕</button>
    <img id="lightboxPhoto" class="lightbox-photo" src="" alt="Vogelbeobachtungsfoto">
    <div id="lightboxCaption" class="lightbox-caption"></div>
  </div>

  <!-- Challenge Creator Modal -->
  <div id="challengeCreatorModal" style="display:none;" class="challenge-creator-modal">
    <div class="challenge-creator-container">
      <div class="challenge-creator-header">
        <div>
          <h2 style="margin:0;font-size:24px;">✨ Eigene Challenge erstellen</h2>
          <p style="margin:4px 0 0 0;color:var(--muted);font-size:14px;">
            Gestalte deine persönliche Herausforderung
          </p>
        </div>
        <button class="small-btn" onclick="closeChallengeCreator()" style="background:var(--danger);">
          ✕
        </button>
      </div>
      
      <form id="challengeCreatorForm" onsubmit="createCustomChallenge(event); return false;">
        <!-- Challenge Name -->
        <div class="form-group">
          <label>📝 Challenge Name *</label>
          <input type="text" id="customChallengeName" class="input" placeholder="z.B. Morgen-Beobachter" required style="width:100%;">
          <div class="hint">Gib deiner Challenge einen einprägsamen Namen</div>
        </div>
        
        <!-- Challenge Beschreibung -->
        <div class="form-group">
          <label>📄 Beschreibung *</label>
          <textarea id="customChallengeDesc" class="input" rows="3" placeholder="Beschreibe, was erreicht werden muss..." required style="width:100%;resize:vertical;"></textarea>
          <div class="hint">Erkläre das Ziel der Challenge</div>
        </div>
        
        <!-- Icon Auswahl -->
        <div class="form-group">
          <label>🎨 Icon wählen *</label>
          <div class="icon-selector" id="iconSelector">
            <div class="icon-option selected" data-icon="🎯" onclick="selectIcon('🎯')">🎯</div>
            <div class="icon-option" data-icon="⭐" onclick="selectIcon('⭐')">⭐</div>
            <div class="icon-option" data-icon="🏆" onclick="selectIcon('🏆')">🏆</div>
            <div class="icon-option" data-icon="🎪" onclick="selectIcon('🎪')">🎪</div>
            <div class="icon-option" data-icon="🌟" onclick="selectIcon('🌟')">🌟</div>
            <div class="icon-option" data-icon="💫" onclick="selectIcon('💫')">💫</div>
            <div class="icon-option" data-icon="🔥" onclick="selectIcon('🔥')">🔥</div>
            <div class="icon-option" data-icon="⚡" onclick="selectIcon('⚡')">⚡</div>
            <div class="icon-option" data-icon="🌈" onclick="selectIcon('🌈')">🌈</div>
            <div class="icon-option" data-icon="🦅" onclick="selectIcon('🦅')">🦅</div>
            <div class="icon-option" data-icon="🦜" onclick="selectIcon('🦜')">🦜</div>
            <div class="icon-option" data-icon="🐧" onclick="selectIcon('🐧')">🐧</div>
            <div class="icon-option" data-icon="🦆" onclick="selectIcon('🦆')">🦆</div>
            <div class="icon-option" data-icon="🦉" onclick="selectIcon('🦉')">🦉</div>
            <div class="icon-option" data-icon="🐦" onclick="selectIcon('🐦')">🐦</div>
            <div class="icon-option" data-icon="🕊️" onclick="selectIcon('🕊️')">🕊️</div>
          </div>
          <input type="hidden" id="customChallengeIcon" value="🎯" required>
        </div>
        
        <!-- Farbe Auswahl -->
        <div class="form-group">
          <label>🎨 Farbe wählen *</label>
          <div class="color-selector">
            <div class="color-option selected" style="background:#06b6d4;" data-color="#06b6d4" onclick="selectColor('#06b6d4')"></div>
            <div class="color-option" style="background:#7c3aed;" data-color="#7c3aed" onclick="selectColor('#7c3aed')"></div>
            <div class="color-option" style="background:#eab308;" data-color="#eab308" onclick="selectColor('#eab308')"></div>
            <div class="color-option" style="background:#ef4444;" data-color="#ef4444" onclick="selectColor('#ef4444')"></div>
            <div class="color-option" style="background:#22c55e;" data-color="#22c55e" onclick="selectColor('#22c55e')"></div>
            <div class="color-option" style="background:#ec4899;" data-color="#ec4899" onclick="selectColor('#ec4899')"></div>
            <div class="color-option" style="background:#f59e0b;" data-color="#f59e0b" onclick="selectColor('#f59e0b')"></div>
            <div class="color-option" style="background:#8b5cf6;" data-color="#8b5cf6" onclick="selectColor('#8b5cf6')"></div>
            <div class="color-option" style="background:#14b8a6;" data-color="#14b8a6" onclick="selectColor('#14b8a6')"></div>
            <div class="color-option" style="background:#f97316;" data-color="#f97316" onclick="selectColor('#f97316')"></div>
          </div>
          <input type="hidden" id="customChallengeColor" value="#06b6d4" required>
        </div>
        
        <!-- Tier Auswahl -->
        <div class="form-group">
          <label>🏅 Schwierigkeitsgrad *</label>
          <div class="tier-selector">
            <div class="tier-option selected" data-tier="Bronze" onclick="selectTier('Bronze')">
              <div style="font-size:20px;margin-bottom:4px;">🥉</div>
              <div>Bronze</div>
            </div>
            <div class="tier-option" data-tier="Silber" onclick="selectTier('Silber')">
              <div style="font-size:20px;margin-bottom:4px;">🥈</div>
              <div>Silber</div>
            </div>
            <div class="tier-option" data-tier="Gold" onclick="selectTier('Gold')">
              <div style="font-size:20px;margin-bottom:4px;">🥇</div>
              <div>Gold</div>
            </div>
            <div class="tier-option" data-tier="Platin" onclick="selectTier('Platin')">
              <div style="font-size:20px;margin-bottom:4px;">💎</div>
              <div>Platin</div>
            </div>
          </div>
          <input type="hidden" id="customChallengeTier" value="Bronze" required>
        </div>
        
        <!-- Challenge Typ -->
        <div class="form-group">
          <label>🎯 Challenge-Typ *</label>
          <select id="customChallengeType" class="input" onchange="updateGoalHint()" style="width:100%;" required>
            <option value="species_count">Anzahl verschiedener Vogelarten</option>
            <option value="observation_count">Anzahl Beobachtungen</option>
            <option value="photo_count">Anzahl Beobachtungen mit Fotos</option>
            <option value="rare_species">Seltene und sehr seltene Arten</option>
            <option value="selffound_species">Selffound Arten</option>
            <option value="early_morning">Beobachtungen vor 7:00 Uhr</option>
            <option value="late_evening">Beobachtungen nach 20:00 Uhr</option>
            <option value="weekend_streak">Beobachtungen an Wochenenden</option>
            <option value="daily_streak">Tage hintereinander mit Beobachtung</option>
            <option value="specific_bird">Spezifische Vogelart beobachten</option>
            <option value="location_count">Verschiedene Standorte</option>
            <option value="weather_diverse">Bei verschiedenen Wetterbedingungen</option>
          </select>
          <div class="hint" id="goalTypeHint">Beobachte verschiedene Vogelarten</div>
        </div>
        
        <!-- Ziel (Goal) -->
        <div class="form-group">
          <label>🎲 Ziel *</label>
          <div style="display:flex;align-items:center;">
            <input type="range" id="customChallengeGoal" class="range-input" min="1" max="100" value="10" oninput="updateGoalValue()">
            <span class="range-value" id="goalValue">10</span>
          </div>
          <div class="hint" id="goalHint">Wie viele musst du erreichen?</div>
        </div>
        
        <!-- Spezifischer Vogel (nur bei specific_bird) -->
        <div class="form-group" id="specificBirdGroup" style="display:none;">
          <label>🐦 Vogelart angeben</label>
          <input type="text" id="customChallengeSpecificBird" class="input" placeholder="z.B. Amsel, Rotkehlchen..." style="width:100%;">
          <div class="hint">Welche Vogelart soll beobachtet werden?</div>
        </div>
        
        <!-- Zeitlimit (Optional) -->
        <div class="form-group">
          <label>⏰ Zeitlimit (Optional)</label>
          <select id="customChallengeTimeLimit" class="input" style="width:100%;">
            <option value="">Kein Zeitlimit</option>
            <option value="7">1 Woche</option>
            <option value="14">2 Wochen</option>
            <option value="30">1 Monat</option>
            <option value="60">2 Monate</option>
            <option value="90">3 Monate</option>
          </select>
          <div class="hint">Setze eine Frist für die Challenge (optional)</div>
        </div>
        
        <!-- XP Belohnung -->
        <div class="form-group">
          <label>⭐ XP Belohnung bei Abschluss</label>
          <div style="display:flex;align-items:center;">
            <input type="range" id="customChallengeXP" class="range-input" min="0" max="500" step="10" value="50" oninput="updateXPValue()">
            <span class="range-value" id="xpValue">50 XP</span>
          </div>
          <div class="hint">Bonus-XP beim Abschließen der Challenge</div>
        </div>
        
        <!-- Buttons -->
        <div style="display:flex;gap:12px;margin-top:24px;">
          <button type="button" class="small-btn" onclick="closeChallengeCreator()" style="flex:1;background:var(--muted);">
            Abbrechen
          </button>
          <button type="submit" class="small-btn" style="flex:2;background:var(--accent);color:white;font-weight:600;">
            ✨ Challenge erstellen
          </button>
        </div>
      </form>
    </div>
  </div>

  <!-- Vergleichs-Ordner erstellen Modal -->
  <div id="createComparisonFolderModal" style="display:none;" class="challenge-creator-modal">
    <div class="challenge-creator-container" style="max-width:600px;">
      <div class="challenge-creator-header">
        <div>
          <h2 style="margin:0;font-size:24px;">📁 Vergleichs-Ordner erstellen</h2>
          <p style="margin:4px 0 0 0;color:var(--muted);font-size:14px;">
            Lade andere ein, ihre Listen zu teilen
          </p>
        </div>
        <button class="small-btn" onclick="closeCreateComparisonFolderModal()" style="background:var(--danger);">
          ✕
        </button>
      </div>
      
      <form id="createComparisonFolderForm" onsubmit="createComparisonFolder(event); return false;">
        <div class="form-group">
          <label>📝 Ordner-Name *</label>
          <input type="text" id="comparisonFolderName" class="input" placeholder="z.B. Frühlings-Challenge 2024" required style="width:100%;">
          <div class="hint">Gib dem Ordner einen aussagekräftigen Namen</div>
        </div>
        
        <div class="form-group">
          <label>📄 Beschreibung (optional)</label>
          <textarea id="comparisonFolderDesc" class="input" rows="3" placeholder="Beschreibe den Zweck des Vergleichs..." style="width:100%;resize:vertical;"></textarea>
          <div class="hint">Was soll verglichen werden?</div>
        </div>
        
        <div style="display:flex;gap:12px;margin-top:24px;">
          <button type="button" class="small-btn" onclick="closeCreateComparisonFolderModal()" style="flex:1;background:var(--muted);">
            Abbrechen
          </button>
          <button type="submit" class="small-btn" style="flex:2;background:var(--accent);color:white;font-weight:600;">
            📁 Ordner erstellen
          </button>
        </div>
      </form>
    </div>
  </div>

  <!-- Listen zum Ordner hinzufügen Modal -->
  <div id="addListToFolderModal" style="display:none;" class="challenge-creator-modal">
    <div class="challenge-creator-container" style="max-width:700px;">
      <div class="challenge-creator-header">
        <div>
          <h2 style="margin:0;font-size:24px;">📋 Liste hinzufügen</h2>
          <p style="margin:4px 0 0 0;color:var(--muted);font-size:14px;">
            Wähle eine deiner Listen zum Vergleichen
          </p>
        </div>
        <button class="small-btn" onclick="closeAddListToFolderModal()" style="background:var(--danger);">
          ✕
        </button>
      </div>
      
      <div id="availableListsForComparison">
        <div style="text-align:center;padding:40px 20px;color:var(--muted);">
          <div style="font-size:32px;margin-bottom:8px;">📋</div>
          <p>Lade deine Listen...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Listen-Details Modal im Vergleich -->
  <div id="comparisonListDetailsModal" style="display:none;" class="challenge-creator-modal">
    <div class="challenge-creator-container" style="max-width:1000px;max-height:90vh;overflow-y:auto;">
      <div class="challenge-creator-header">
        <div>
          <h2 id="comparisonListTitle" style="margin:0;font-size:24px;">📋 Listen-Details</h2>
          <p id="comparisonListMeta" style="margin:4px 0 0 0;color:var(--muted);font-size:14px;"></p>
        </div>
        <button class="small-btn" onclick="closeComparisonListDetails()" style="background:var(--danger);">
          ✕
        </button>
      </div>
      
      <!-- Statistiken -->
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:20px;">
        <div class="card" style="text-align:center;padding:16px;">
          <div style="font-size:28px;font-weight:700;color:var(--accent);" id="comparisonListObsCount">0</div>
          <div style="font-size:12px;color:var(--muted);margin-top:4px;">Beobachtungen</div>
        </div>
        <div class="card" style="text-align:center;padding:16px;">
          <div style="font-size:28px;font-weight:700;color:var(--accent-2);" id="comparisonListSpeciesCount">0</div>
          <div style="font-size:12px;color:var(--muted);margin-top:4px;">Arten</div>
        </div>
        <div class="card" style="text-align:center;padding:16px;">
          <div style="font-size:28px;font-weight:700;color:var(--success);" id="comparisonListDaysCount">0</div>
          <div style="font-size:12px;color:var(--muted);margin-top:4px;">Tage</div>
        </div>
      </div>
      
      <!-- Ansichtsmodus -->
      <div style="display:flex;gap:8px;margin-bottom:16px;background:rgba(255,255,255,0.02);padding:4px;border-radius:8px;width:fit-content;">
        <button class="small-btn active" id="comparisonViewSpecies" onclick="switchComparisonView('species')" 
                style="background:var(--accent);">
          🐦 Nach Arten
        </button>
        <button class="small-btn" id="comparisonViewObservations" onclick="switchComparisonView('observations')">
          📋 Alle Beobachtungen
        </button>
      </div>
      
      <!-- Content Container -->
      <div id="comparisonListContent">
        <div style="text-align:center;padding:40px 20px;color:var(--muted);">
          <p>Lade Details...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // ---------- IndexedDB Implementation ----------
    const DB_NAME = 'VogelzaehlungDB';
    const DB_VERSION = 3;
    let db = null;

    // ---------- Globale Variablen ----------
    let dragMode = true;
    let markersLocked = true; // NEU: Marker sind standardmäßig gesperrt
    window.mapObj = null;
    window.markers = new Map();
    let nextId = 1;
    let activeRowForMapClick = null;
    let chart = null;
    let heatmapLayer = null;
    let isRestoringMarkers = false; // Flag um Marker-Wiederherstellung zu verfolgen
    let markerCluster = null;
    let currentFilters = {};
    let tempObservationData = null;
    let currentListId = null;
    let listTags = [];
    let selectedListColor = '#06b6d4';
    let detailMap = null;
    let currentObservationId = null;
    let currentTileLayer = null; // NEU: Aktueller Karten-Layer
    
    // NEU: Challenge & XP System
    let challengeXP = 0;
    let challengeLevel = 1;
    const XP_PER_OBSERVATION = 10;
    const XP_PER_LEVEL = 100;
    
    // XP-System Funktionen
    async function loadChallengeProgress() {
      try {
        console.log("📖 Lade Challenge-Fortschritt...");
        const progress = await getFromIndexedDB('settings', 'challengeProgress');
        if (progress) {
          challengeXP = progress.xp || 0;
          challengeLevel = progress.level || 1;
          console.log("✅ Challenge-Fortschritt geladen:", {level: challengeLevel, xp: challengeXP});
        } else {
          console.log("ℹ️ Kein gespeicherter Fortschritt gefunden, starte bei Level 1 mit 0 XP");
        }
      } catch (error) {
        console.log('ℹ️ Keine gespeicherten Challenge-Daten gefunden, starte bei 0');
      }
    }
    
    async function saveChallengeProgress() {
      try {
        console.log("💾 Speichere Challenge-Fortschritt:", {level: challengeLevel, xp: challengeXP});
        const result = await saveToIndexedDB('settings', {
          key: 'challengeProgress',
          xp: challengeXP,
          level: challengeLevel,
          updatedAt: new Date().toISOString()
        });
        console.log("✅ Challenge-Fortschritt gespeichert, ID:", result);
      } catch (error) {
        console.error('❌ Fehler beim Speichern der Challenge-Daten:', error);
      }
    }
    
    function showXPNotification(xp) {
      const notification = document.createElement('div');
      notification.className = 'xp-notification';
      notification.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;">
          <div style="font-size:28px;">⭐</div>
          <div>
            <div style="font-size:16px;margin-bottom:4px;">+${xp} XP erhalten!</div>
            <div style="font-size:13px;opacity:0.9;">Level ${challengeLevel} • ${challengeXP}/${XP_PER_LEVEL * challengeLevel} XP</div>
          </div>
        </div>
      `;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    
    function showLevelUpNotification(newLevel) {
      const notification = document.createElement('div');
      notification.className = 'xp-notification';
      notification.style.background = 'linear-gradient(135deg, #7c3aed, #6366f1)';
      notification.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;">
          <div style="font-size:32px;">🎉</div>
          <div>
            <div style="font-size:18px;font-weight:700;margin-bottom:4px;">Level Up!</div>
            <div style="font-size:14px;opacity:0.95;">Du bist jetzt Level ${newLevel}!</div>
          </div>
        </div>
      `;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 4000);
    }
    
    async function awardXPForNewObservation() {
      try {
        console.log("🎯 ========== XP-VERGABE GESTARTET ==========");
        console.log("   Aktueller Stand vor XP-Vergabe - Level:", challengeLevel, "XP:", challengeXP);
        
        const xpGained = XP_PER_OBSERVATION;
        challengeXP += xpGained;
        
        console.log("   XP erhalten:", xpGained);
        console.log("   Neuer XP-Stand:", challengeXP);
        
        // Zeige sofort eine Benachrichtigung
        console.log("   Zeige XP-Benachrichtigung...");
        showNotification(`⭐ +${xpGained} XP erhalten!`, 2000);
        
        // Prüfe Level-Up
        const xpNeeded = XP_PER_LEVEL * challengeLevel;
        console.log("   XP benötigt für nächstes Level:", xpNeeded);
        
        if (challengeXP >= xpNeeded) {
          challengeLevel++;
          challengeXP = challengeXP - xpNeeded;
          console.log("🎉 LEVEL UP! Neues Level:", challengeLevel, "Übrige XP:", challengeXP);
          showLevelUpNotification(challengeLevel);
          await saveChallengeProgress();
          setTimeout(() => {
            showXPNotification(xpGained);
          }, 1500);
        } else {
          console.log("   Noch kein Level-Up");
          showXPNotification(xpGained);
          await saveChallengeProgress();
        }
        
        console.log("   Speichere Challenge-Fortschritt...");
        updateChallengeDisplay();
        
        // NEU: Prüfe auch Challenge-Fortschritt
        await checkChallengeProgress();
        
        console.log("✅ ========== XP-VERGABE ABGESCHLOSSEN ==========");
      } catch (error) {
        console.error("❌ FEHLER IN awardXPForNewObservation:", error);
        console.error("   Stack:", error.stack);
        // Zeige trotzdem eine Benachrichtigung
        showNotification(`⚠️ XP-System Fehler: ${error.message}`, 3000);
      }
    }
    
    function updateChallengeDisplay() {
      // Update Challenge-Seite wenn sichtbar
      const xpDisplay = document.getElementById('challengeXPDisplay');
      const levelDisplay = document.getElementById('challengeLevelDisplay');
      const xpNeededDisplay = document.getElementById('challengeXPNeeded');
      const progressBar = document.getElementById('challengeProgressBar');
      
      const xpNeeded = XP_PER_LEVEL * challengeLevel;
      
      if (xpDisplay) {
        xpDisplay.textContent = challengeXP;
      }
      if (levelDisplay) {
        levelDisplay.textContent = challengeLevel;
      }
      if (xpNeededDisplay) {
        xpNeededDisplay.textContent = xpNeeded;
      }
      if (progressBar) {
        const progress = (challengeXP / xpNeeded) * 100;
        progressBar.style.width = Math.min(100, progress) + '%';
      }
    }
    
    // ============ Challenge-System ============
    
    // Challenge-Definitionen
    const CHALLENGES = {
      species_collector: {
        id: 'species_collector',
        name: 'Arten-Sammler',
        description: 'Beobachte 10 verschiedene Vogelarten',
        icon: '🐦',
        tier: 'Bronze',
        goal: 10,
        type: 'species_count',
        color: '#06b6d4'
      },
      diligent_observer: {
        id: 'diligent_observer',
        name: 'Fleißiger Beobachter',
        description: 'Erfasse 50 Beobachtungen',
        icon: '📊',
        tier: 'Silber',
        goal: 50,
        type: 'observation_count',
        color: '#7c3aed'
      },
      early_bird: {
        id: 'early_bird',
        name: 'Früher Vogel',
        description: 'Beobachte vor 7:00 Uhr morgens',
        icon: '🌅',
        tier: 'Bronze',
        goal: 1,
        type: 'early_morning',
        color: '#eab308'
      },
      weekend_explorer: {
        id: 'weekend_explorer',
        name: 'Wochenend-Explorer',
        description: 'Beobachte an 4 Wochenenden hintereinander',
        icon: '🗓️',
        tier: 'Gold',
        goal: 4,
        type: 'weekend_streak',
        color: '#ef4444'
      },
      diversity_champion: {
        id: 'diversity_champion',
        name: 'Diversitäts-Champion',
        description: 'Beobachte Vögel aus 5 verschiedenen Familien',
        icon: '🌈',
        tier: 'Platin',
        goal: 5,
        type: 'bird_families',
        color: '#22c55e'
      },
      photo_documentarian: {
        id: 'photo_documentarian',
        name: 'Foto-Dokumentar',
        description: 'Füge 20 Beobachtungen mit Fotos hinzu',
        icon: '📸',
        tier: 'Silber',
        goal: 20,
        type: 'photo_count',
        color: '#ec4899'
      }
    };
    
    // Aktive Challenges laden
    async function loadActiveChallenges() {
      try {
        const active = await getFromIndexedDB('settings', 'activeChallenges');
        return active ? active.challenges || [] : [];
      } catch (error) {
        return [];
      }
    }
    
    // Aktive Challenges speichern
    async function saveActiveChallenges(challenges) {
      try {
        await saveToIndexedDB('settings', {
          key: 'activeChallenges',
          challenges: challenges,
          updatedAt: new Date().toISOString()
        });
      } catch (error) {
        console.error('Fehler beim Speichern der aktiven Challenges:', error);
      }
    }
    
    // Abgeschlossene Challenges laden
    async function loadCompletedChallenges() {
      try {
        const completed = await getFromIndexedDB('settings', 'completedChallenges');
        return completed ? completed.challenges || [] : [];
      } catch (error) {
        return [];
      }
    }
    
    // Abgeschlossene Challenges speichern
    async function saveCompletedChallenges(challenges) {
      try {
        await saveToIndexedDB('settings', {
          key: 'completedChallenges',
          challenges: challenges,
          updatedAt: new Date().toISOString()
        });
      } catch (error) {
        console.error('Fehler beim Speichern der abgeschlossenen Challenges:', error);
      }
    }
    
    // Challenge starten
    async function startChallenge(challengeId) {
      // Stelle sicher, dass Custom Challenges geladen sind
      await loadCustomChallenges();
      
      const challenge = CHALLENGES[challengeId];
      if (!challenge) {
        console.error('Challenge nicht gefunden:', challengeId);
        showNotification('❌ Challenge konnte nicht gefunden werden', 3000);
        return;
      }
      
      const activeChallenges = await loadActiveChallenges();
      
      // Prüfe ob Challenge bereits aktiv
      if (activeChallenges.find(c => c.id === challengeId)) {
        showNotification('Diese Challenge ist bereits aktiv!', 3000);
        return;
      }
      
      // Füge Challenge hinzu
      activeChallenges.push({
        id: challengeId,
        startedAt: new Date().toISOString(),
        progress: 0,
        goal: challenge.goal
      });
      
      await saveActiveChallenges(activeChallenges);
      showNotification(`🎯 Challenge "${challenge.name}" gestartet!`, 3000);
      await renderChallenges();
    }
    
    // Challenge abbrechen/deaktivieren
    async function cancelChallenge(challengeId) {
      if (!confirm('Möchtest du diese Challenge wirklich abbrechen? Der Fortschritt geht verloren.')) {
        return;
      }
      
      const activeChallenges = await loadActiveChallenges();
      const challenge = CHALLENGES[challengeId];
      
      // Entferne Challenge aus aktiven
      const updatedChallenges = activeChallenges.filter(c => c.id !== challengeId);
      
      await saveActiveChallenges(updatedChallenges);
      
      if (challenge) {
        showNotification(`❌ Challenge "${challenge.name}" abgebrochen`, 2000);
      } else {
        showNotification(`❌ Challenge abgebrochen`, 2000);
      }
      
      await renderChallenges();
    }
    
    // Challenge-Fortschritt prüfen
    async function checkChallengeProgress() {
      const activeChallenges = await loadActiveChallenges();
      if (activeChallenges.length === 0) return;
      
      const allObservations = await getAllFromIndexedDB('observations');
      // NEU: Filtere Nullmeldungen aus
      const observations = allObservations.filter(o => isValidObservation(o));
      
      const completedChallenges = await loadCompletedChallenges();
      const newlyCompleted = [];
      
      for (const activeChallenge of activeChallenges) {
        const challenge = CHALLENGES[activeChallenge.id];
        if (!challenge) {
          console.warn('⚠️ Aktive Challenge nicht im CHALLENGES Objekt gefunden:', activeChallenge.id);
          console.warn('   Verfügbare Challenge IDs:', Object.keys(CHALLENGES));
          continue;
        }
        
        let progress = 0;
        
        switch (challenge.type) {
          case 'species_count':
            const uniqueSpecies = new Set(observations.map(obs => obs.bird));
            progress = uniqueSpecies.size;
            break;
            
          case 'observation_count':
            progress = observations.length;
            break;
            
          case 'early_morning':
            progress = observations.filter(obs => {
              if (!obs.time) return false;
              const hour = parseInt(obs.time.split(':')[0]);
              return hour < 7;
            }).length;
            break;
            
          case 'late_evening':
            progress = observations.filter(obs => {
              if (!obs.time) return false;
              const hour = parseInt(obs.time.split(':')[0]);
              return hour >= 20;
            }).length;
            break;
            
          case 'weekend_streak':
            // Vereinfachte Version: Zähle Beobachtungen an Wochenenden
            const weekendObs = observations.filter(obs => {
              const date = new Date(obs.date);
              const day = date.getDay();
              return day === 0 || day === 6; // Sonntag oder Samstag
            });
            const uniqueWeekends = new Set(weekendObs.map(obs => {
              const date = new Date(obs.date);
              const weekStart = new Date(date);
              weekStart.setDate(date.getDate() - date.getDay());
              return weekStart.toISOString().split('T')[0];
            }));
            progress = uniqueWeekends.size;
            break;
            
          case 'daily_streak':
            // Berechne die längste Serie von aufeinanderfolgenden Tagen
            const dates = observations.map(obs => obs.date).sort();
            const uniqueDates = [...new Set(dates)];
            let currentStreak = 0;
            let maxStreak = 0;
            
            for (let i = 0; i < uniqueDates.length; i++) {
              if (i === 0) {
                currentStreak = 1;
              } else {
                const prevDate = new Date(uniqueDates[i - 1]);
                const currDate = new Date(uniqueDates[i]);
                const diffDays = Math.floor((currDate - prevDate) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 1) {
                  currentStreak++;
                } else {
                  maxStreak = Math.max(maxStreak, currentStreak);
                  currentStreak = 1;
                }
              }
            }
            maxStreak = Math.max(maxStreak, currentStreak);
            progress = maxStreak;
            break;
            
          case 'photo_count':
            progress = observations.filter(obs => obs.photo).length;
            break;
            
          case 'specific_bird':
            if (challenge.specificBird) {
              progress = observations.filter(obs => 
                obs.bird.toLowerCase().includes(challenge.specificBird.toLowerCase())
              ).length;
            }
            break;
            
          case 'location_count':
            const uniqueLocations = new Set(
              observations
                .filter(obs => obs.lat && obs.lng)
                .map(obs => `${parseFloat(obs.lat).toFixed(3)},${parseFloat(obs.lng).toFixed(3)}`)
            );
            progress = uniqueLocations.size;
            break;
            
          case 'weather_diverse':
            const uniqueWeather = new Set(
              observations
                .filter(obs => obs.weather)
                .map(obs => obs.weather)
            );
            progress = uniqueWeather.size;
            break;
            
          case 'rare_species':
            // Zähle Beobachtungen mit Seltenheit "Selten" oder "Sehr selten"
            progress = observations.filter(obs => {
              const rarity = obs.rarity || 'Nicht bewertet';
              return rarity === 'Selten' || rarity === 'Sehr selten';
            }).length;
            break;
            
          case 'selffound_species':
            // Zähle Beobachtungen die als "selffound" markiert sind
            progress = observations.filter(obs => obs.selffound === true).length;
            break;
            
          case 'bird_families':
            // Vereinfacht: Zähle verschiedene Vogelarten
            const families = new Set(observations.map(obs => obs.bird));
            progress = Math.min(families.size, challenge.goal);
            break;
        }
        
        activeChallenge.progress = progress;
        
        // Prüfe ob abgeschlossen
        if (progress >= challenge.goal) {
          completedChallenges.push({
            id: activeChallenge.id,
            completedAt: new Date().toISOString(),
            progress: progress,
            goal: challenge.goal
          });
          newlyCompleted.push(challenge);
          
          // Vergebe Bonus-XP wenn vorhanden
          if (challenge.xpReward && challenge.xpReward > 0) {
            challengeXP += challenge.xpReward;
            await saveChallengeProgress();
            updateChallengeDisplay();
            showNotification(`🎁 Bonus: +${challenge.xpReward} XP für Challenge-Abschluss!`, 3000);
          }
        }
      }
      
      // Entferne abgeschlossene Challenges aus aktiven
      const stillActive = activeChallenges.filter(ac => 
        !newlyCompleted.find(nc => nc.id === ac.id)
      );
      
      await saveActiveChallenges(stillActive);
      await saveCompletedChallenges(completedChallenges);
      
      // Zeige Benachrichtigungen für abgeschlossene Challenges
      for (const challenge of newlyCompleted) {
        showChallengeCompletedNotification(challenge);
      }
      
      return newlyCompleted.length > 0;
    }
    
    // Challenge abgeschlossen Benachrichtigung
    function showChallengeCompletedNotification(challenge) {
      const notification = document.createElement('div');
      notification.className = 'xp-notification';
      notification.style.background = `linear-gradient(135deg, ${challenge.color}, ${challenge.color}dd)`;
      notification.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;">
          <div style="font-size:32px;">${challenge.icon}</div>
          <div>
            <div style="font-size:18px;font-weight:700;margin-bottom:4px;">Challenge abgeschlossen! 🎉</div>
            <div style="font-size:14px;opacity:0.95;">${challenge.name}</div>
            <div style="font-size:12px;opacity:0.8;margin-top:2px;">🏅 ${challenge.tier}</div>
          </div>
        </div>
      `;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 5000);
    }
    
    // Challenges rendern
    async function renderChallenges() {
      // WICHTIG: Lade zuerst Custom Challenges, damit sie im CHALLENGES Objekt sind
      await loadCustomChallenges();
      
      const activeChallenges = await loadActiveChallenges();
      const completedChallenges = await loadCompletedChallenges();
      
      // Prüfe Fortschritt (nachdem Custom Challenges geladen wurden)
      await checkChallengeProgress();
      
      // Reload nach Check
      const updatedActive = await loadActiveChallenges();
      const updatedCompleted = await loadCompletedChallenges();
      
      // Rendere verfügbare Challenges (Standard + Benutzerdefiniert)
      await renderAvailableChallenges(updatedActive);
      
      // Rendere aktive Challenges
      const activeContainer = document.getElementById('activeChallenges');
      if (updatedActive.length === 0) {
        activeContainer.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">🎯</div>
            <p>Noch keine aktiven Challenges</p>
            <p style="font-size:12px;margin-top:8px;">Wähle unten eine Challenge aus um zu starten!</p>
          </div>
        `;
      } else {
        let html = '<div style="display:flex;flex-direction:column;gap:12px;">';
        for (const activeChallenge of updatedActive) {
          const challenge = CHALLENGES[activeChallenge.id];
          if (!challenge) continue;
          
          const progress = activeChallenge.progress || 0;
          const percentage = (progress / challenge.goal) * 100;
          
          html += `
            <div class="card" style="background:linear-gradient(135deg, ${challenge.color}15, ${challenge.color}05);border-left:3px solid ${challenge.color};">
              <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px;">
                <div style="display:flex;align-items:center;gap:12px;">
                  <div style="font-size:32px;">${challenge.icon}</div>
                  <div>
                    <div style="font-weight:600;font-size:16px;">${challenge.name}</div>
                    <div style="font-size:13px;color:var(--muted);margin-top:2px;">${challenge.description}</div>
                  </div>
                </div>
                <div style="display:flex;gap:8px;align-items:center;">
                  <div style="font-size:11px;color:var(--muted);padding:4px 8px;background:rgba(255,255,255,0.05);border-radius:6px;">
                    🏅 ${challenge.tier}
                  </div>
                  <button class="small-btn" onclick="cancelChallenge('${activeChallenge.id}')" 
                          style="background:var(--danger);padding:4px 8px;font-size:11px;" 
                          title="Challenge abbrechen">
                    ❌
                  </button>
                </div>
              </div>
              <div style="margin-bottom:8px;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                  <span style="font-size:13px;color:var(--muted);">Fortschritt</span>
                  <span style="font-size:14px;font-weight:600;">${progress} / ${challenge.goal}</span>
                </div>
                <div style="width:100%;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;">
                  <div style="height:100%;background:${challenge.color};width:${percentage}%;transition:width 0.5s ease;"></div>
                </div>
              </div>
            </div>
          `;
        }
        html += '</div>';
        activeContainer.innerHTML = html;
      }
      
      // Rendere abgeschlossene Challenges
      const completedContainer = document.getElementById('completedChallenges');
      if (updatedCompleted.length === 0) {
        completedContainer.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">🏆</div>
            <p>Noch keine abgeschlossenen Challenges</p>
            <p style="font-size:12px;margin-top:8px;">Starte deine erste Challenge!</p>
          </div>
        `;
      } else {
        let html = '<div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));gap:12px;">';
        for (const completed of updatedCompleted) {
          const challenge = CHALLENGES[completed.id];
          if (!challenge) continue;
          
          const completedDate = new Date(completed.completedAt).toLocaleDateString('de-DE');
          
          html += `
            <div class="card" style="background:linear-gradient(135deg, ${challenge.color}20, ${challenge.color}08);border:2px solid ${challenge.color};">
              <div style="text-align:center;">
                <div style="font-size:40px;margin-bottom:8px;">${challenge.icon}</div>
                <div style="font-weight:600;font-size:15px;margin-bottom:4px;">${challenge.name}</div>
                <div style="font-size:12px;color:var(--muted);margin-bottom:8px;">🏅 ${challenge.tier}</div>
                <div style="font-size:11px;color:var(--muted);">✅ ${completedDate}</div>
              </div>
            </div>
          `;
        }
        html += '</div>';
        completedContainer.innerHTML = html;
      }
    }
    
    // Rendere verfügbare Challenges
    async function renderAvailableChallenges(activeChallenges) {
      // Finde den Container mit der ID
      const grid = document.getElementById('availableChallengesGrid');
      if (!grid) {
        console.error('❌ Container für verfügbare Challenges nicht gefunden!');
        return;
      }
      
      console.log('✅ Container gefunden:', grid);
      
      const activeIds = new Set(activeChallenges.map(ac => ac.id));
      const completedChallenges = await loadCompletedChallenges();
      const completedIds = new Set(completedChallenges.map(cc => cc.id));
      
      // Hole alle Challenges (Standard + Benutzerdefiniert)
      const allChallenges = Object.values(CHALLENGES);
      console.log('🎯 Alle verfügbaren Challenges:', allChallenges.length);
      console.log('🎯 Challenge IDs:', allChallenges.map(c => c.id));
      
      // Filtere nur noch nicht gestartete und nicht abgeschlossene
      const availableChallenges = allChallenges.filter(ch => 
        !activeIds.has(ch.id) && !completedIds.has(ch.id)
      );
      
      console.log('📋 Verfügbare Challenges (nicht aktiv/abgeschlossen):', availableChallenges.length);
      console.log('📋 Benutzerdefinierte Challenges:', availableChallenges.filter(c => c.custom).length);
      
      if (availableChallenges.length === 0) {
        grid.innerHTML = `
          <div style="grid-column:1/-1;text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">🎉</div>
            <p>Alle Challenges gestartet oder abgeschlossen!</p>
            <p style="font-size:12px;margin-top:8px;">Erstelle deine eigenen Challenges!</p>
          </div>
        `;
        return;
      }
      
      let html = '';
      for (const challenge of availableChallenges) {
        const isCustom = challenge.custom || false;
        // Prüfe ob Challenge neu ist (erstellt in den letzten 5 Sekunden)
        const challengeAge = challenge.id.startsWith('custom_') ? Date.now() - parseInt(challenge.id.replace('custom_', '')) : Infinity;
        const isNew = challengeAge < 5000;
        
        // Erstelle lesbare Ziel-Beschreibung für Custom Challenges
        let goalText = '';
        if (isCustom) {
          const typeNames = {
            'species_count': '🐦 Verschiedene Arten',
            'observation_count': '📊 Beobachtungen',
            'early_morning': '🌅 Frühmorgendliche Beobachtungen',
            'late_evening': '🌙 Abendliche Beobachtungen',
            'weekend_streak': '📅 Wochenend-Serie',
            'daily_streak': '🔥 Tages-Serie',
            'photo_count': '📷 Beobachtungen mit Foto',
            'rare_species': '💎 Seltene/Sehr seltene Arten',
            'selffound_species': '🔴 Selffound Arten',
            'specific_bird': `🎯 ${challenge.specificBird || 'Spezifische Art'}`,
            'location_count': '📍 Verschiedene Standorte',
            'weather_diverse': '🌦️ Verschiedene Wetterbedingungen',
            'bird_families': '👨‍👩‍👧‍👦 Vogelfamilien'
          };
          goalText = `<div style="margin-top:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:6px;font-size:12px;">
            <strong>Ziel:</strong> ${challenge.goal}x ${typeNames[challenge.type] || challenge.type}
          </div>`;
        }
        
        html += `
          <div class="card" style="background:rgba(${isCustom ? '124,58,237' : '255,255,255'},0.05);border-left:3px solid ${challenge.color};${isNew ? 'animation: slideInUp 0.4s ease-out;' : ''}position:relative;">
            ${isCustom ? '<div style="position:absolute;top:8px;right:8px;background:var(--accent-2);color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:700;">CUSTOM</div>' : ''}
            ${isNew ? '<div style="position:absolute;top:8px;left:8px;background:#10b981;color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:700;animation: pulse 1s ease-in-out 3;">✨ NEU</div>' : ''}
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
              <span style="font-size:24px;">${challenge.icon}</span>
              <strong>${challenge.name}</strong>
            </div>
            <p style="font-size:13px;color:var(--muted);margin-bottom:12px;">
              ${challenge.description}
            </p>
            ${goalText}
            <div style="display:flex;justify-content:space-between;align-items:center;${goalText ? 'margin-top:12px;' : ''}">
              <span style="font-size:12px;color:var(--muted);">🏅 ${challenge.tier}</span>
              <button class="small-btn" onclick="startChallenge('${challenge.id}')">Starten</button>
            </div>
            ${challenge.xpReward && challenge.xpReward > 0 ? `
              <div style="margin-top:8px;padding:6px;background:rgba(245,158,11,0.1);border-radius:6px;text-align:center;">
                <span style="font-size:11px;color:#f59e0b;font-weight:600;">🎁 +${challenge.xpReward} Bonus-XP</span>
              </div>
            ` : ''}
          </div>
        `;
      }
      
      grid.innerHTML = html;
    }
    
    // ============ Challenge Creator Funktionen ============
    
    let selectedIcon = '🎯';
    let selectedColor = '#06b6d4';
    let selectedTier = 'Bronze';
    
    function openChallengeCreator() {
      document.getElementById('challengeCreatorModal').style.display = 'flex';
      // Reset form
      document.getElementById('challengeCreatorForm').reset();
      selectedIcon = '🎯';
      selectedColor = '#06b6d4';
      selectedTier = 'Bronze';
      updateGoalValue();
      updateXPValue();
      updateGoalHint();
    }
    
    function closeChallengeCreator() {
      document.getElementById('challengeCreatorModal').style.display = 'none';
      // Reset form beim Schließen
      document.getElementById('challengeCreatorForm').reset();
      selectedIcon = '🎯';
      selectedColor = '#06b6d4';
      selectedTier = 'Bronze';
    }
    
    function selectIcon(icon) {
      selectedIcon = icon;
      document.getElementById('customChallengeIcon').value = icon;
      
      // Update UI
      document.querySelectorAll('.icon-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      document.querySelector(`.icon-option[data-icon="${icon}"]`).classList.add('selected');
    }
    
    function selectColor(color) {
      selectedColor = color;
      document.getElementById('customChallengeColor').value = color;
      
      // Update UI
      document.querySelectorAll('.color-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      document.querySelector(`.color-option[data-color="${color}"]`).classList.add('selected');
    }
    
    function selectTier(tier) {
      selectedTier = tier;
      document.getElementById('customChallengeTier').value = tier;
      
      // Update UI
      document.querySelectorAll('.tier-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      document.querySelector(`.tier-option[data-tier="${tier}"]`).classList.add('selected');
    }
    
    function updateGoalValue() {
      const value = document.getElementById('customChallengeGoal').value;
      document.getElementById('goalValue').textContent = value;
    }
    
    function updateXPValue() {
      const value = document.getElementById('customChallengeXP').value;
      document.getElementById('xpValue').textContent = value + ' XP';
    }
    
    function updateGoalHint() {
      const type = document.getElementById('customChallengeType').value;
      const hints = {
        'species_count': 'Beobachte verschiedene Vogelarten',
        'observation_count': 'Erstelle Beobachtungen',
        'photo_count': 'Beobachtungen mit Fotos',
        'rare_species': 'Beobachte seltene oder sehr seltene Arten',
        'selffound_species': 'Beobachte selbst gefundene Arten',
        'early_morning': 'Beobachtungen vor 7:00 Uhr',
        'late_evening': 'Beobachtungen nach 20:00 Uhr',
        'weekend_streak': 'Beobachtungen an Wochenenden',
        'daily_streak': 'Tage mit mindestens einer Beobachtung',
        'specific_bird': 'Diese spezifische Vogelart beobachten',
        'location_count': 'Verschiedene Standorte besuchen',
        'weather_diverse': 'Bei verschiedenen Wetterbedingungen beobachten'
      };
      
      document.getElementById('goalTypeHint').textContent = hints[type] || '';
      
      // Zeige/verstecke spezifisches Vogel-Feld
      const birdGroup = document.getElementById('specificBirdGroup');
      if (type === 'specific_bird') {
        birdGroup.style.display = 'block';
      } else {
        birdGroup.style.display = 'none';
      }
    }
    
    async function createCustomChallenge(event) {
      event.preventDefault();
      
      const name = document.getElementById('customChallengeName').value;
      const description = document.getElementById('customChallengeDesc').value;
      const icon = selectedIcon;
      const color = selectedColor;
      const tier = selectedTier;
      const type = document.getElementById('customChallengeType').value;
      const goal = parseInt(document.getElementById('customChallengeGoal').value);
      const specificBird = document.getElementById('customChallengeSpecificBird').value;
      const timeLimit = document.getElementById('customChallengeTimeLimit').value;
      const xpReward = parseInt(document.getElementById('customChallengeXP').value);
      
      // NEU: Validierung für spezifische Vogelart
      if (type === 'specific_bird' && specificBird && !birdDatabase[specificBird]) {
        showNotification('❌ "' + specificBird + '" ist nicht in der Vogeldatenbank! Bitte wähle eine gültige Art.', 4000);
        return;
      }
      
      // Erstelle eindeutige ID
      const customId = 'custom_' + Date.now();
      
      // Füge Challenge zu CHALLENGES hinzu
      CHALLENGES[customId] = {
        id: customId,
        name: name,
        description: description,
        icon: icon,
        tier: tier,
        goal: goal,
        type: type,
        color: color,
        specificBird: specificBird,
        timeLimit: timeLimit ? parseInt(timeLimit) : null,
        xpReward: xpReward,
        custom: true
      };
      
      console.log('✨ Erstelle benutzerdefinierte Challenge:', CHALLENGES[customId]);
      
      // Speichere benutzerdefinierte Challenges
      await saveCustomChallenge(CHALLENGES[customId]);
      
      console.log('✅ Challenge gespeichert, CHALLENGES Objekt:', Object.keys(CHALLENGES));
      
      // Aktualisiere Challenge-Liste SOFORT
      await renderChallenges();
      
      // Dann schließe Modal und zeige Notification
      closeChallengeCreator();
      showNotification(`✨ Challenge "${name}" erfolgreich erstellt!`, 3000);
    }
    
    // Speichere benutzerdefinierte Challenge
    async function saveCustomChallenge(challenge) {
      try {
        const existing = await getFromIndexedDB('settings', 'customChallenges');
        const customs = existing ? existing.challenges || [] : [];
        
        console.log('💾 Speichere Challenge:', challenge.name);
        console.log('💾 Bereits gespeicherte Challenges:', customs.length);
        
        customs.push(challenge);
        
        const saveData = {
          key: 'customChallenges',
          challenges: customs,
          updatedAt: new Date().toISOString()
        };
        
        console.log('💾 Speichere Daten:', saveData);
        
        await saveToIndexedDB('settings', saveData);
        
        console.log('✅ Challenge erfolgreich in IndexedDB gespeichert');
      } catch (error) {
        console.error('❌ Fehler beim Speichern der benutzerdefinierten Challenge:', error);
      }
    }
    
    // Lade benutzerdefinierte Challenges
    async function loadCustomChallenges() {
      try {
        const data = await getFromIndexedDB('settings', 'customChallenges');
        console.log('📥 Lade benutzerdefinierte Challenges:', data);
        
        if (data && data.challenges) {
          console.log('✅ Gefundene Challenges:', data.challenges.length);
          for (const challenge of data.challenges) {
            CHALLENGES[challenge.id] = challenge;
            console.log('➕ Challenge hinzugefügt:', challenge.id, challenge.name);
          }
          console.log('✅ CHALLENGES Objekt nach Laden:', Object.keys(CHALLENGES));
        } else {
          console.log('ℹ️ Keine benutzerdefinierten Challenges in DB');
        }
      } catch (error) {
        console.log('❌ Fehler beim Laden:', error);
      }
    }
    
    // NEU: Polygon-Variablen
    let polygonDrawingMode = false;
    let currentPolygonPoints = [];
    let polygonMap = null;
    let polygonLayer = null;
    let polygonMarkers = [];
    let currentPolygonForList = null;
    
    // NEU: Temporäre Koordinaten-Container initialisieren
    if (!window.tempMapCoords) {
      window.tempMapCoords = null;
    }
    
    // Farbpalette für Ordner und Listen - Erweitert für mehr eindeutige Farben
    const colorPalette = [
      '#06b6d4', // Cyan/Akzent
      '#7c3aed', // Violett/Akzent-2
      '#10b981', // Grün/Erfolg
      '#ef4444', // Rot/Gefahr
      '#f59e0b', // Orange
      '#84cc16', // Limette
      '#14b8a6', // Türkis
      '#8b5cf6', // Violett 2
      '#ec4899', // Pink
      '#6366f1', // Indigo
      '#f97316', // Orange 2
      '#22c55e', // Grün 2
      '#0ea5e9', // Blau
      '#a855f7', // Lila
      '#fb923c', // Helles Orange
      '#34d399', // Mintgrün
      '#60a5fa', // Hellblau
      '#fbbf24', // Gelb
      '#f472b6', // Rosa
      '#a78bfa', // Helllila
    ];
    
    let folderColors = {};
    let userLists = []; // Array für benutzerdefinierte Listen
    
    // NEU: User-Farben für Gruppen-Marker
    let userColors = {};
    let userColorIndex = 0;
    let userColorsSorted = []; // Sortierte Liste von UIDs für konsistente Farben
    
    function getUserColor(userId) {
      if (!userColors[userId]) {
        // Füge zur sortierten Liste hinzu wenn neu
        if (!userColorsSorted.includes(userId)) {
          userColorsSorted.push(userId);
          userColorsSorted.sort(); // Sortiere alphabetisch für Konsistenz
        }
        
        // Verwende Position in sortierter Liste für Farbindex
        const colorIndex = userColorsSorted.indexOf(userId);
        userColors[userId] = colorPalette[colorIndex % colorPalette.length];
        
        console.log(`🎨 NEU: Farbe für User ${userId}:`);
        console.log(`   - Sortierte Liste: [${userColorsSorted.join(', ')}]`);
        console.log(`   - Position in Liste: ${colorIndex}`);
        console.log(`   - Zugewiesene Farbe: ${userColors[userId]}`);
      } else {
        console.log(`🎨 CACHE: User ${userId} hat bereits Farbe ${userColors[userId]}`);
      }
      return userColors[userId];
    }
    
    // NEU: Setze User-Farben zurück (z.B. beim Gruppenwechsel)
    function resetUserColors() {
      userColors = {};
      userColorIndex = 0;
      userColorsSorted = [];
    }
    
    // NEU: Benutzernamen-Verwaltung für privaten Modus
    function getPrivateUserName() {
      return localStorage.getItem('birdcount_private_username') || 'Mein Name';
    }
    
    function setPrivateUserName(name) {
      if (name && name.trim()) {
        localStorage.setItem('birdcount_private_username', name.trim());
        return true;
      }
      return false;
    }
    
    function getUserNameForObservation() {
      // Im Gruppenmodus: Firebase-Benutzer
      if (window.currentSelectedGroup && window.currentSelectedGroup !== 'personal' && window.FBA?.currentUser) {
        return window.FBA.currentUser.email || window.FBA.currentUser.displayName || 'Gruppenmitglied';
      }
      // Im privaten Modus: Gespeicherter Name
      return getPrivateUserName();
    }
    
    // ============ Listen-Vergleichs-System ============
    
    let currentComparisonFolderId = null;
    
    // Vergleichs-Ordner erstellen
    async function openCreateComparisonFolderModal() {
      document.getElementById('createComparisonFolderModal').style.display = 'flex';
      document.getElementById('createComparisonFolderForm').reset();
    }
    
    function closeCreateComparisonFolderModal() {
      document.getElementById('createComparisonFolderModal').style.display = 'none';
    }
    
    async function createComparisonFolder(event) {
      event.preventDefault();
      
      if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
        showNotification('❌ Bitte wähle eine Gruppe aus', 3000);
        return;
      }
      
      if (!window.FBA || !window.FBA.currentUser) {
        showNotification('❌ Du musst angemeldet sein', 3000);
        return;
      }
      
      const name = document.getElementById('comparisonFolderName').value;
      const description = document.getElementById('comparisonFolderDesc').value;
      
      const user = window.FBA.currentUser;
      const folderData = {
        name: name,
        description: description,
        createdBy: user.uid,
        createdByName: user.displayName || user.email.split('@')[0],
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        lists: {}
      };
      
      try {
        const ref = await window.FBD.ref(`groups/${window.currentSelectedGroup}/comparisonFolders`).push(folderData);
        console.log('✅ Vergleichs-Ordner erstellt:', ref.key);
        showNotification(`✅ Ordner "${name}" erstellt!`, 3000);
        closeCreateComparisonFolderModal();
        await renderComparisonFolders();
      } catch (error) {
        console.error('Fehler beim Erstellen des Ordners:', error);
        showNotification('❌ Fehler beim Erstellen', 3000);
      }
    }
    
    // Rendere Vergleichs-Ordner
    async function renderComparisonFolders() {
      const container = document.getElementById('comparisonFoldersList');
      
      if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
        container.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">👥</div>
            <p>Bitte wähle eine Gruppe aus</p>
          </div>
        `;
        return;
      }
      
      try {
        const snapshot = await window.FBD.ref(`groups/${window.currentSelectedGroup}/comparisonFolders`).once('value');
        const folders = snapshot.val();
        
        if (!folders) {
          container.innerHTML = `
            <div style="text-align:center;padding:40px 20px;color:var(--muted);">
              <div style="font-size:48px;margin-bottom:12px;">📁</div>
              <p>Noch keine Vergleichs-Ordner</p>
              <p style="font-size:12px;margin-top:8px;">Erstelle einen Ordner um Listen zu vergleichen!</p>
            </div>
          `;
          return;
        }
        
        let html = '';
        
        for (const [folderId, folder] of Object.entries(folders)) {
          const listsCount = folder.lists ? Object.keys(folder.lists).length : 0;
          const isOwner = window.FBA.currentUser && folder.createdBy === window.FBA.currentUser.uid;
          
          // Berechne Statistiken
          let totalObservations = 0;
          let totalSpecies = new Set();
          let listStats = [];
          
          if (folder.lists) {
            for (const [listId, list] of Object.entries(folder.lists)) {
              const obsCount = list.observations ? list.observations.length : 0;
              const speciesSet = new Set(list.observations?.map(obs => obs.bird) || []);
              
              totalObservations += obsCount;
              speciesSet.forEach(s => totalSpecies.add(s));
              
              listStats.push({
                name: list.listName,
                userName: list.userName,
                observations: obsCount,
                species: speciesSet.size
              });
            }
          }
          
          // Finde Gewinner
          const mostObservations = listStats.sort((a, b) => b.observations - a.observations)[0];
          const mostSpecies = [...listStats].sort((a, b) => b.species - a.species)[0];
          
          html += `
            <div class="comparison-folder-card">
              <div class="comparison-folder-header">
                <div>
                  <div class="comparison-folder-title">📁 ${escapeHtml(folder.name)}</div>
                  ${folder.description ? `<div style="font-size:13px;color:var(--muted);margin-top:4px;">${escapeHtml(folder.description)}</div>` : ''}
                  <div style="font-size:12px;color:var(--muted);margin-top:6px;">
                    Erstellt von ${escapeHtml(folder.createdByName)}${isOwner ? ' <span style="color:var(--accent);">(Du)</span>' : ''}
                  </div>
                </div>
                <button class="small-btn" onclick="openAddListToFolderModal('${folderId}')" style="background:var(--accent);">
                  ➕ Liste hinzufügen
                </button>
              </div>
              
              <div class="comparison-folder-stats">
                <span>📋 ${listsCount} Listen</span>
                <span>📊 ${totalObservations} Beobachtungen</span>
                <span>🐦 ${totalSpecies.size} Arten</span>
              </div>
              
              ${listsCount > 0 ? `
                <div class="list-comparison-grid">
                  ${listStats.map((stat, index) => {
                    const isWinnerObs = mostObservations && stat.name === mostObservations.name;
                    const isWinnerSpecies = mostSpecies && stat.name === mostSpecies.name;
                    const isWinner = isWinnerObs || isWinnerSpecies;
                    
                    // Finde die listId für diese Statistik
                    const listId = Object.keys(folder.lists)[index];
                    const list = folder.lists[listId];
                    const isListOwner = window.FBA.currentUser && list.userId === window.FBA.currentUser.uid;
                    
                    return `
                      <div class="compared-list-card ${isWinner ? 'winner' : ''}" style="position:relative;">
                        ${isWinner ? '<div class="winner-badge">🏆 Top</div>' : ''}
                        <div style="font-weight:600;margin-bottom:8px;">${escapeHtml(stat.name)}</div>
                        <div class="list-owner-badge">👤 ${escapeHtml(stat.userName)}</div>
                        <div style="margin-top:12px;display:flex;flex-direction:column;gap:6px;">
                          <div style="display:flex;justify-content:space-between;font-size:13px;">
                            <span style="color:var(--muted);">Beobachtungen</span>
                            <span style="font-weight:600;">${stat.observations}</span>
                          </div>
                          <div style="display:flex;justify-content:space-between;font-size:13px;">
                            <span style="color:var(--muted);">Arten</span>
                            <span style="font-weight:600;">${stat.species}</span>
                          </div>
                        </div>
                        <button class="small-btn" onclick="viewComparisonListDetails('${folderId}', '${listId}')" 
                                style="width:100%;margin-top:12px;background:var(--accent);">
                          👁️ Details ansehen
                        </button>
                        ${isListOwner ? `
                          <button class="small-btn" onclick="deleteListFromComparisonFolder('${folderId}', '${listId}')" 
                                  style="width:100%;margin-top:8px;background:var(--danger);font-size:11px;" 
                                  title="Liste aus Ordner entfernen">
                            🗑️ Löschen
                          </button>
                        ` : ''}
                      </div>
                    `;
                  }).join('')}
                </div>
              ` : `
                <div style="text-align:center;padding:20px;color:var(--muted);margin-top:12px;background:rgba(255,255,255,0.02);border-radius:8px;">
                  <p style="margin:0;">Noch keine Listen in diesem Ordner</p>
                </div>
              `}
            </div>
          `;
        }
        
        container.innerHTML = html;
        
      } catch (error) {
        console.error('Fehler beim Laden der Vergleichs-Ordner:', error);
        container.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--danger);">
            <p>Fehler beim Laden der Ordner</p>
          </div>
        `;
      }
    }
    
    // Öffne Modal zum Hinzufügen einer Liste
    async function openAddListToFolderModal(folderId) {
      currentComparisonFolderId = folderId;
      document.getElementById('addListToFolderModal').style.display = 'flex';
      
      // Lade Benutzer-Listen
      await renderAvailableListsForComparison();
    }
    
    function closeAddListToFolderModal() {
      document.getElementById('addListToFolderModal').style.display = 'none';
      currentComparisonFolderId = null;
    }
    
    // Rendere verfügbare Listen
    async function renderAvailableListsForComparison() {
      const container = document.getElementById('availableListsForComparison');
      
      try {
        // Lade Listen aus IndexedDB
        const lists = await getAllFromIndexedDB('lists');
        
        if (lists.length === 0) {
          container.innerHTML = `
            <div style="text-align:center;padding:40px 20px;color:var(--muted);">
              <div style="font-size:48px;margin-bottom:12px;">📋</div>
              <p>Du hast noch keine Listen erstellt</p>
              <p style="font-size:12px;margin-top:8px;">Erstelle Listen im Listen-Menü!</p>
            </div>
          `;
          return;
        }
        
        // Lade persönliche Beobachtungen für Statistiken
        const observations = await getPersonalObservationsWithDetails();
        
        let html = '<div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(min(100%, 280px), 1fr));gap:12px;">';
        
        for (const list of lists) {
          // Berechne Statistiken für diese Liste
          const filteredObs = await filterObservationsByList(observations, list);
          const tickableObs = filteredObs.filter(o => o.tickable !== false);
          const speciesCount = new Set(tickableObs.map(o => o.bird)).size;
          
          html += `
            <div class="card" style="cursor:pointer;transition:all 0.2s;" onclick="addListToComparisonFolder('${list.id}')">
              <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                <div style="width:12px;height:12px;background:${list.color || colorPalette[0]};border-radius:50%;"></div>
                <strong>${escapeHtml(list.name)}</strong>
              </div>
              <div style="font-size:12px;color:var(--muted);margin-bottom:8px;">
                ${escapeHtml(list.description || 'Keine Beschreibung')}
              </div>
              <div style="display:flex;gap:12px;font-size:13px;color:var(--muted);">
                <span>📊 ${filteredObs.length} Beobachtungen</span>
                <span>🐦 ${speciesCount} Arten</span>
              </div>
              <button class="small-btn" style="width:100%;margin-top:12px;background:var(--accent);">
                Hinzufügen
              </button>
            </div>
          `;
        }
        
        html += '</div>';
        container.innerHTML = html;
        
      } catch (error) {
        console.error('Fehler beim Laden der Listen:', error);
        container.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--danger);">
            <p>Fehler beim Laden der Listen</p>
            <p style="font-size:12px;margin-top:8px;">${error.message}</p>
          </div>
        `;
      }
    }
    
    // Liste zum Vergleichs-Ordner hinzufügen
    async function addListToComparisonFolder(listId) {
      if (!currentComparisonFolderId) return;
      if (!window.FBA || !window.FBA.currentUser) return;
      
      try {
        // Lade Liste aus IndexedDB
        const list = await getFromIndexedDB('lists', listId);
        if (!list) {
          showNotification('❌ Liste nicht gefunden', 3000);
          return;
        }
        
        // Lade persönliche Beobachtungen und filtere sie nach Listen-Kriterien
        const allObservations = await getPersonalObservationsWithDetails();
        const filteredObservations = await filterObservationsByList(allObservations, list);
        
        const user = window.FBA.currentUser;
        
        // Bereite Listendaten für Firebase vor
        const listData = {
          listId: list.id,
          listName: list.name,
          listDescription: list.description || '',
          listColor: list.color || colorPalette[0],
          listTags: list.tags || [],
          userId: user.uid,
          userName: user.displayName || user.email.split('@')[0],
          userEmail: user.email,
          observations: filteredObservations, // Die gefilterten Beobachtungen
          addedAt: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Füge Liste zum Ordner hinzu
        await window.FBD.ref(`groups/${window.currentSelectedGroup}/comparisonFolders/${currentComparisonFolderId}/lists`).push(listData);
        
        showNotification(`✅ Liste "${list.name}" mit ${filteredObservations.length} Beobachtungen hinzugefügt!`, 3000);
        closeAddListToFolderModal();
        await renderComparisonFolders();
        
      } catch (error) {
        console.error('Fehler beim Hinzufügen der Liste:', error);
        showNotification('❌ Fehler beim Hinzufügen: ' + error.message, 3000);
      }
    }
    
    // Liste aus Vergleichs-Ordner löschen
    async function deleteListFromComparisonFolder(folderId, listId) {
      if (!window.FBA || !window.FBA.currentUser) {
        showNotification('❌ Nicht angemeldet', 3000);
        return;
      }
      
      if (!confirm('Möchtest du diese Liste wirklich aus dem Vergleich entfernen?')) {
        return;
      }
      
      try {
        const groupId = window.currentSelectedGroup;
        
        // Prüfe ob der aktuelle User der Besitzer der Liste ist
        const listSnapshot = await window.FBD.ref(`groups/${groupId}/comparisonFolders/${folderId}/lists/${listId}`).once('value');
        const listData = listSnapshot.val();
        
        if (!listData) {
          showNotification('❌ Liste nicht gefunden', 3000);
          return;
        }
        
        if (listData.userId !== window.FBA.currentUser.uid) {
          showNotification('❌ Du kannst nur deine eigenen Listen löschen', 3000);
          return;
        }
        
        // Lösche Liste aus Firebase
        await window.FBD.ref(`groups/${groupId}/comparisonFolders/${folderId}/lists/${listId}`).remove();
        
        showNotification(`✅ Liste "${listData.listName}" entfernt`, 3000);
        
        // Aktualisiere Ansicht
        await renderComparisonFolders();
        
      } catch (error) {
        console.error('Fehler beim Löschen der Liste:', error);
        showNotification('❌ Fehler beim Löschen: ' + error.message, 3000);
      }
    }
    
    // Globale Funktion verfügbar machen
    window.deleteListFromComparisonFolder = deleteListFromComparisonFolder;
    
    // NEU: Synchronisiere geteilte Listen nach neuer Beobachtung
    async function syncSharedListsAfterNewObservation() {
      // Nur im privaten Modus ausführen
      if (window.currentSelectedGroup && window.currentSelectedGroup !== 'personal') {
        console.log('⏭️ Sync übersprungen: Nicht im privaten Modus');
        return; // Nicht im Gruppenmodus synchronisieren
      }
      
      if (!window.FBA || !window.FBA.currentUser) {
        console.log('⏭️ Sync übersprungen: Nicht angemeldet');
        return; // Nicht angemeldet
      }
      
      try {
        console.log('🔄 Starte automatische Synchronisation geteilter Listen...');
        const userId = window.FBA.currentUser.uid;
        console.log('   User ID:', userId);
        
        // Lade alle persönlichen Beobachtungen
        const allObservations = await getPersonalObservationsWithDetails();
        console.log('   Persönliche Beobachtungen geladen:', allObservations.length);
        
        // Durchsuche alle Gruppen
        const groupsSnapshot = await window.FBD.ref('groups').once('value');
        if (!groupsSnapshot.exists()) {
          console.log('⏭️ Keine Gruppen gefunden');
          return;
        }
        
        const groups = groupsSnapshot.val();
        console.log('   Gruppen gefunden:', Object.keys(groups).length);
        
        let updatedCount = 0;
        let checkedLists = 0;
        
        // Iteriere durch alle Gruppen
        for (const [groupKey, groupData] of Object.entries(groups)) {
          console.log(`   📁 Prüfe Gruppe: ${groupKey}`);
          
          if (!groupData.comparisonFolders) {
            console.log('      ⏭️ Keine Vergleichsordner in dieser Gruppe');
            continue;
          }
          
          // Durchsuche Vergleichsordner
          for (const [folderId, folder] of Object.entries(groupData.comparisonFolders)) {
            console.log(`      📂 Prüfe Ordner: ${folder.name || folderId}`);
            
            if (!folder.lists) {
              console.log('         ⏭️ Keine Listen in diesem Ordner');
              continue;
            }
            
            // Durchsuche Listen in diesem Ordner
            for (const [listFirebaseId, listData] of Object.entries(folder.lists)) {
              checkedLists++;
              console.log(`         📋 Prüfe Liste: ${listData.listName} (User: ${listData.userId})`);
              
              // Nur eigene Listen aktualisieren
              if (listData.userId !== userId) {
                console.log('            ⏭️ Nicht eigene Liste');
                continue;
              }
              
              console.log('            ✓ Eigene Liste gefunden!');
              
              // Lade die Original-Liste aus IndexedDB
              const originalList = await getFromIndexedDB('lists', listData.listId);
              if (!originalList) {
                console.log('            ❌ Original-Liste nicht in IndexedDB gefunden');
                continue;
              }
              
              console.log('            ✓ Original-Liste geladen aus IndexedDB');
              
              // Filtere Beobachtungen neu
              const filteredObservations = await filterObservationsByList(allObservations, originalList);
              console.log(`            📊 Gefiltert: ${filteredObservations.length} Beobachtungen (vorher: ${listData.observations?.length || 0})`);
              
              // Aktualisiere in Firebase
              const listRef = window.FBD.ref(`groups/${groupKey}/comparisonFolders/${folderId}/lists/${listFirebaseId}/observations`);
              await listRef.set(filteredObservations);
              
              console.log(`            ✅ Liste "${listData.listName}" aktualisiert!`);
              updatedCount++;
            }
          }
        }
        
        console.log(`✅ Synchronisation abgeschlossen: ${updatedCount} von ${checkedLists} Listen aktualisiert`);
        
        // Zeige Benachrichtigung bei erfolgreicher Aktualisierung
        if (updatedCount > 0) {
          showNotification(`🔄 ${updatedCount} geteilte Liste(n) automatisch aktualisiert`, 3000);
        }
        
      } catch (error) {
        console.error('❌ Fehler beim Synchronisieren geteilter Listen:', error);
        console.error('   Stack:', error.stack);
      }
    }
    
    // Globale Funktion verfügbar machen
    window.syncSharedListsAfterNewObservation = syncSharedListsAfterNewObservation;
    
    // NEU: Manuelle Synchronisation mit Benutzer-Feedback
    async function manualSyncSharedLists() {
      if (!window.FBA || !window.FBA.currentUser) {
        showNotification('❌ Du musst angemeldet sein, um Listen zu synchronisieren', 3000);
        return;
      }
      
      const btn = document.getElementById('syncSharedListsBtn');
      if (btn) {
        btn.disabled = true;
        btn.textContent = '🔄 Synchronisiere...';
      }
      
      try {
        showNotification('🔄 Synchronisiere geteilte Listen...', 2000);
        console.log('🔄 Manuelle Synchronisation gestartet...');
        
        const userId = window.FBA.currentUser.uid;
        console.log('   User ID:', userId);
        
        const allObservations = await getPersonalObservationsWithDetails();
        console.log('   Persönliche Beobachtungen:', allObservations.length);
        
        // Durchsuche alle Gruppen
        const groupsSnapshot = await window.FBD.ref('groups').once('value');
        if (!groupsSnapshot.exists()) {
          showNotification('ℹ️ Keine Gruppen gefunden', 2000);
          return;
        }
        
        const groups = groupsSnapshot.val();
        console.log('   Gruppen gefunden:', Object.keys(groups).length);
        
        let updatedCount = 0;
        let totalLists = 0;
        
        // Iteriere durch alle Gruppen
        for (const [groupKey, groupData] of Object.entries(groups)) {
          console.log(`   📁 Prüfe Gruppe: ${groupKey}`);
          
          if (!groupData.comparisonFolders) {
            console.log('      ⏭️ Keine Vergleichsordner');
            continue;
          }
          
          for (const [folderId, folder] of Object.entries(groupData.comparisonFolders)) {
            console.log(`      📂 Ordner: ${folder.name || folderId}`);
            
            if (!folder.lists) {
              console.log('         ⏭️ Keine Listen');
              continue;
            }
            
            for (const [listFirebaseId, listData] of Object.entries(folder.lists)) {
              console.log(`         📋 Liste: ${listData.listName} (User: ${listData.userId})`);
              
              // Nur eigene Listen
              if (listData.userId !== userId) {
                console.log('            ⏭️ Nicht eigene Liste');
                continue;
              }
              
              totalLists++;
              console.log('            ✓ Eigene Liste!');
              
              // Lade die Original-Liste aus IndexedDB
              const originalList = await getFromIndexedDB('lists', listData.listId);
              if (!originalList) {
                console.warn(`            ❌ Liste ${listData.listId} nicht in IndexedDB gefunden`);
                continue;
              }
              
              console.log('            ✓ Original-Liste geladen');
              
              // Filtere Beobachtungen neu
              const filteredObservations = await filterObservationsByList(allObservations, originalList);
              console.log(`            📊 ${filteredObservations.length} Beobachtungen (vorher: ${listData.observations?.length || 0})`);
              
              // Aktualisiere in Firebase
              const listRef = window.FBD.ref(`groups/${groupKey}/comparisonFolders/${folderId}/lists/${listFirebaseId}/observations`);
              await listRef.set(filteredObservations);
              
              updatedCount++;
              console.log(`            ✅ Liste "${listData.listName}" aktualisiert!`);
            }
          }
        }
        
        console.log(`✅ Manuelle Synchronisation abgeschlossen: ${updatedCount} von ${totalLists} Listen`);
        
        if (totalLists === 0) {
          showNotification('ℹ️ Du hast keine Listen in Gruppen geteilt', 3000);
        } else if (updatedCount > 0) {
          showNotification(`✅ ${updatedCount} von ${totalLists} geteilte(n) Liste(n) erfolgreich synchronisiert!`, 4000);
        } else {
          showNotification('⚠️ Keine Listen konnten aktualisiert werden', 3000);
        }
        
      } catch (error) {
        console.error('❌ Fehler beim Synchronisieren:', error);
        console.error('   Stack:', error.stack);
        showNotification('❌ Fehler beim Synchronisieren: ' + error.message, 4000);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = '🔄 Geteilte Listen synchronisieren';
        }
      }
    }
    
    // Globale Funktion verfügbar machen
    window.manualSyncSharedLists = manualSyncSharedLists;
    
    // NEU: Test-Funktion für XP-System (kann in der Konsole aufgerufen werden)
    window.testXPSystem = async function() {
      console.log('🧪 Teste XP-System...');
      console.log('   Aktuelles Level:', challengeLevel);
      console.log('   Aktuelle XP:', challengeXP);
      console.log('   XP pro Beobachtung:', XP_PER_OBSERVATION);
      console.log('   XP pro Level:', XP_PER_LEVEL);
      
      console.log('\n📊 Teste XP-Vergabe...');
      await awardXPForNewObservation();
      
      console.log('\n✅ Test abgeschlossen!');
      console.log('   Neues Level:', challengeLevel);
      console.log('   Neue XP:', challengeXP);
      
      return {
        level: challengeLevel,
        xp: challengeXP,
        xpNeeded: XP_PER_LEVEL * challengeLevel
      };
    };
    
    // NEU: Manuelles Setzen von XP (für Debugging)
    window.setXP = async function(xp, level = challengeLevel) {
      challengeXP = xp;
      challengeLevel = level;
      await saveChallengeProgress();
      updateChallengeDisplay();
      console.log('✅ XP gesetzt:', {level: challengeLevel, xp: challengeXP});
    };
    
    // NEU: XP-Status anzeigen
    window.checkXP = function() {
      console.log('📊 ========== XP-SYSTEM STATUS ==========');
      console.log('   Level:', challengeLevel);
      console.log('   Aktuelle XP:', challengeXP);
      console.log('   XP bis nächstes Level:', (XP_PER_LEVEL * challengeLevel) - challengeXP);
      console.log('   XP pro Beobachtung:', XP_PER_OBSERVATION);
      console.log('   XP pro Level:', XP_PER_LEVEL);
      console.log('=========================================');
      
      showNotification(`Level ${challengeLevel} • ${challengeXP}/${XP_PER_LEVEL * challengeLevel} XP`, 3000);
      
      return {
        level: challengeLevel,
        xp: challengeXP,
        xpNeeded: XP_PER_LEVEL * challengeLevel,
        xpToNextLevel: (XP_PER_LEVEL * challengeLevel) - challengeXP
      };
    };
    
    // NEU: Listen-Details im Vergleich anzeigen
    let currentComparisonListData = null;
    let currentComparisonViewMode = 'species';
    
    async function viewComparisonListDetails(folderId, listId) {
      try {
        const groupId = window.currentSelectedGroup;
        const listSnapshot = await window.FBD.ref(`groups/${groupId}/comparisonFolders/${folderId}/lists/${listId}`).once('value');
        const listData = listSnapshot.val();
        
        if (!listData) {
          showNotification('❌ Liste nicht gefunden', 3000);
          return;
        }
        
        currentComparisonListData = listData;
        currentComparisonViewMode = 'species';
        
        // Modal öffnen und Inhalt setzen
        document.getElementById('comparisonListTitle').textContent = `📋 ${listData.listName}`;
        document.getElementById('comparisonListMeta').textContent = `Erstellt von ${listData.userName}${listData.listDescription ? ' • ' + listData.listDescription : ''}`;
        
        // Statistiken berechnen
        const observations = listData.observations || [];
        // NEU: Filtere Nullmeldungen aus
        const validObs = observations.filter(o => isValidObservation(o));
        const tickableObs = validObs.filter(o => o.tickable !== false);
        const speciesCount = new Set(tickableObs.map(o => o.bird)).size;
        const daysCount = new Set(validObs.map(o => o.date)).size;
        
        document.getElementById('comparisonListObsCount').textContent = validObs.length;
        document.getElementById('comparisonListSpeciesCount').textContent = speciesCount;
        document.getElementById('comparisonListDaysCount').textContent = daysCount;
        
        // Zeige Arten-Ansicht
        renderComparisonListSpecies();
        
        // Modal anzeigen
        document.getElementById('comparisonListDetailsModal').style.display = 'flex';
        
      } catch (error) {
        console.error('Fehler beim Laden der Listen-Details:', error);
        showNotification('❌ Fehler beim Laden der Details', 3000);
      }
    }
    
    function closeComparisonListDetails() {
      document.getElementById('comparisonListDetailsModal').style.display = 'none';
      currentComparisonListData = null;
    }
    
    function switchComparisonView(viewMode) {
      currentComparisonViewMode = viewMode;
      
      // Update button styles
      document.getElementById('comparisonViewSpecies').classList.remove('active');
      document.getElementById('comparisonViewSpecies').style.background = 'transparent';
      document.getElementById('comparisonViewObservations').classList.remove('active');
      document.getElementById('comparisonViewObservations').style.background = 'transparent';
      
      if (viewMode === 'species') {
        document.getElementById('comparisonViewSpecies').classList.add('active');
        document.getElementById('comparisonViewSpecies').style.background = 'var(--accent)';
        renderComparisonListSpecies();
      } else {
        document.getElementById('comparisonViewObservations').classList.add('active');
        document.getElementById('comparisonViewObservations').style.background = 'var(--accent)';
        renderComparisonListObservations();
      }
    }
    
    function renderComparisonListSpecies() {
      if (!currentComparisonListData) return;
      
      const observations = currentComparisonListData.observations || [];
      // NEU: Filtere Nullmeldungen aus
      const validObs = observations.filter(o => isValidObservation(o));
      const tickableObs = validObs.filter(o => o.tickable !== false);
      
      // Gruppiere nach Arten
      const speciesMap = {};
      tickableObs.forEach(obs => {
        if (!speciesMap[obs.bird]) {
          speciesMap[obs.bird] = {
            bird: obs.bird,
            observations: [],
            firstDate: obs.date
          };
        }
        speciesMap[obs.bird].observations.push(obs);
        if (obs.date < speciesMap[obs.bird].firstDate) {
          speciesMap[obs.bird].firstDate = obs.date;
        }
      });
      
      // Sortiere alphabetisch
      const sortedSpecies = Object.values(speciesMap).sort((a, b) => a.bird.localeCompare(b.bird));
      
      let html = `
        <div style="display:flex;flex-direction:column;gap:10px;">
      `;
      
      sortedSpecies.forEach(species => {
        const rarity = getRarityStyle(species.bird, species.observations[0].manualRarity);
        
        html += `
          <div class="card" style="background:rgba(255,255,255,0.02);padding:14px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
              <div style="flex:1;">
                <div class="observation-species ${rarity.rarityClass}" style="font-size:17px;font-weight:600;">
                  ${rarity.rarityIcon} ${species.bird}
                </div>
                <div style="font-size:12px;color:var(--muted);margin-top:4px;">
                  ${species.observations.length} Beobachtung${species.observations.length !== 1 ? 'en' : ''} • 
                  Erstbeobachtung: ${formatDateForDisplay(species.firstDate)}
                </div>
              </div>
              <button class="small-btn" onclick="toggleSpeciesObservations('${species.bird}')" id="toggle_${species.bird.replace(/\s/g, '_')}">
                👁️ Zeigen
              </button>
            </div>
            <div id="obs_${species.bird.replace(/\s/g, '_')}" style="display:none;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.05);">
              ${species.observations.map(obs => `
                <div style="padding:8px;margin-bottom:8px;background:rgba(255,255,255,0.02);border-radius:6px;">
                  <div style="display:flex;justify-content:space-between;font-size:13px;">
                    <span>📅 ${formatDateForDisplay(obs.date)}</span>
                    <span>📍 ${obs.folderName || 'Unbekannt'}</span>
                  </div>
                  ${obs.behavior ? `<div style="font-size:12px;color:var(--muted);margin-top:4px;">💬 ${obs.behavior}</div>` : ''}
                  ${obs.photo ? `<div style="margin-top:6px;"><img src="${obs.photo}" style="width:100%;max-width:200px;border-radius:4px;" /></div>` : ''}
                </div>
              `).join('')}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      
      if (sortedSpecies.length === 0) {
        html = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">🐦</div>
            <p>Keine Arten in dieser Liste</p>
          </div>
        `;
      }
      
      document.getElementById('comparisonListContent').innerHTML = html;
    }
    
    function renderComparisonListObservations() {
      if (!currentComparisonListData) return;
      
      const observations = currentComparisonListData.observations || [];
      
      let html = `
        <div style="display:flex;flex-direction:column;gap:8px;">
      `;
      
      observations.forEach(obs => {
        const rarity = getRarityStyle(obs.bird, obs.manualRarity);
        
        html += `
          <div class="card" style="background:rgba(255,255,255,0.02);padding:14px;">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;">
              <div style="flex:1;">
                <div class="observation-species ${rarity.rarityClass}" style="font-size:16px;font-weight:600;margin-bottom:6px;">
                  ${rarity.rarityIcon} ${obs.bird}
                </div>
                <div style="font-size:13px;color:var(--muted);display:flex;gap:16px;flex-wrap:wrap;">
                  <span>📅 ${formatDateForDisplay(obs.date)}</span>
                  <span>📍 ${obs.folderName || 'Unbekannt'}</span>
                  ${obs.tickable === false ? '<span style="color:var(--danger);">⊘ Nicht tickbar</span>' : ''}
                  ${obs.selffound ? '<span style="color:var(--success);">🔴 Selffound</span>' : ''}
                </div>
                ${obs.behavior ? `<div style="font-size:13px;margin-top:8px;">💬 ${obs.behavior}</div>` : ''}
              </div>
            </div>
            ${obs.photo ? `<div style="margin-top:12px;"><img src="${obs.photo}" style="width:100%;max-width:300px;border-radius:6px;" /></div>` : ''}
          </div>
        `;
      });
      
      html += '</div>';
      
      if (observations.length === 0) {
        html = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">📋</div>
            <p>Keine Beobachtungen in dieser Liste</p>
          </div>
        `;
      }
      
      document.getElementById('comparisonListContent').innerHTML = html;
    }
    
    function toggleSpeciesObservations(birdName) {
      const elementId = 'obs_' + birdName.replace(/\s/g, '_');
      const toggleButtonId = 'toggle_' + birdName.replace(/\s/g, '_');
      const element = document.getElementById(elementId);
      const button = document.getElementById(toggleButtonId);
      
      if (element.style.display === 'none') {
        element.style.display = 'block';
        button.textContent = '👁️ Verbergen';
      } else {
        element.style.display = 'none';
        button.textContent = '👁️ Zeigen';
      }
    }
    
    // Globale Funktionen verfügbar machen
    window.viewComparisonListDetails = viewComparisonListDetails;
    window.closeComparisonListDetails = closeComparisonListDetails;
    window.switchComparisonView = switchComparisonView;
    window.toggleSpeciesObservations = toggleSpeciesObservations;
    
    // Diagramm-Einstellungen
    let chartSettings = {
      mode: 'this_year',
      customDays: 365,
      specificYear: new Date().getFullYear(),
      aggregation: 'day',
      showAllData: false,
      showEmptyDays: true
    };
    
    // ---------- VOLLSTÄNDIGE VOGELARTEN-DATENBANK ----------
    const birdDatabase = {
      "Nandu": { status: "Escape" },
      "Streifengans": { status: "Escape" },
      "Schneegans": { status: "Escape" },
      "Zwergschneegans": { status: "Escape" },
      "Graugans": { status: "häufig" },
      "Schwanengans": { status: "Escape" },
      "Blässgans": { status: "häufig" },
      "Zwerggans": { status: "selten" },
      "Waldsaatgans": { status: "häufig" },
      "Tundrasaatgans": { status: "häufig" },
      "Kurschnabelgans": { status: "selten" },
      "Ringelgans": { status: "häufig" },
      "Weißwangengans (Nonnengans)": { status: "häufig" },
      "Zwergkandagans": { status: "Escape" },
      "Kanadagans": { status: "häufig" },
      "Rothalsgans": { status: "selten" },
      "Höckerschwan": { status: "häufig" },
      "Schwarzschwan": { status: "Escape" },
      "Zwergschwan": { status: "häufig" },
      "Singschwan": { status: "häufig" },
      "Nilgans": { status: "häufig" },
      "Rostgans": { status: "häufig" },
      "Brandgans": { status: "häufig" },
      "Brautente": { status: "Escape" },
      "Mandarinente": { status: "häufig" },
      "Gluckente": { status: "sehr selten" },
      "Knäkente": { status: "häufig" },
      "Blauflügelente": { status: "sehr selten" },
      "Löffelente": { status: "häufig" },
      "Schnatterente": { status: "häufig" },
      "Sichelente": { status: "sehr selten" },
      "Pfeifente": { status: "häufig" },
      "Nordamerik. Pfeifente": { status: "sehr selten" },
      "Stockente": { status: "häufig" },
      "Spießente": { status: "häufig" },
      "Krickente": { status: "häufig" },
      "Marmelente": { status: "sehr selten" },
      "Kolbenente": { status: "häufig" },
      "Tafelente": { status: "häufig" },
      "Ringschnabelente": { status: "sehr selten" },
      "Moorente": { status: "selten" },
      "Reiherente": { status: "häufig" },
      "Bergente": { status: "selten" },
      "Kanadabergente": { status: "sehr selten" },
      "Scheckente": { status: "sehr selten" },
      "Prachteiderente": { status: "sehr selten" },
      "Eiderente": { status: "häufig" },
      "Kragenente": { status: "sehr selten" },
      "Brillenente": { status: "sehr selten" },
      "Samtente": { status: "selten" },
      "Amerik. Samtente": { status: "sehr selten" },
      "Asiatische Samtente": { status: "sehr selten" },
      "Trauerente": { status: "häufig" },
      "Amerik.Trauerente": { status: "sehr selten" },
      "Eisente": { status: "selten" },
      "Schellente": { status: "häufig" },
      "Spatelente": { status: "sehr selten" },
      "Zwergsäger": { status: "häufig" },
      "Gänsesäger": { status: "häufig" },
      "Mittelsäger": { status: "selten" },
      "Schwarzkopf-Ruderente": { status: "Escape" },
      "Weißkopf-Ruderente": { status: "sehr selten" },
      "Haselhuhn": { status: "selten" },
      "Alpenschneehuhn": { status: "häufig" },
      "Auerhuhn": { status: "selten" },
      "Birkhuhn": { status: "selten" },
      "Rebhuhn": { status: "häufig" },
      "Fasan": { status: "häufig" },
      "Wachtel": { status: "häufig" },
      "Steinhuhn": { status: "selten" },
      "Rosaflamingo": { status: "selten" },
      "Zwergtaucher": { status: "häufig" },
      "Bindentaucher": { status: "sehr selten" },
      "Ohrentaucher": { status: "selten" },
      "Rothalstaucher": { status: "häufig" },
      "Schwarzhalstaucher": { status: "häufig" },
      "Felsentaube": { status: "häufig" },
      "Hohltaube": { status: "häufig" },
      "Ringeltaube": { status: "häufig" },
      "Turteltaube": { status: "häufig" },
      "Orientturteltaube": { status: "sehr selten" },
      "Türkentaube": { status: "häufig" },
      "Carolinataube": { status: "sehr selten " },
      "Großtrappe": { status: "selten" },
      "Zwergtrappe": { status: "sehr selten" },
      "Kuckuck": { status: "häufig" },
      "Nachtschwalbe": { status: "häufig" },
      "Alpensegler": { status: "selten" },
      "Mauersegler": { status: "häufig" },
      "Fahlsegler": { status: "sehr selten" },
      "Haussegler": { status: "sehr selten" },
      "Wasserralle": { status: "häufig" },
      "Wachtelkönig": { status: "häufig" },
      "Teichhuhn": { status: "häufig" },
      "Tüpfelsumpfhuhn": { status: "häufig" },
      "Blässhuhn": { status: "häufig" },
      "Purpurhuhn": { status: "sehr selten" },
      "Gleitaar": { status: "sehr selten" },
      "Bartgeier": { status: "sehr selten" },
      "Schmutzgeier": { status: "sehr selten" },
      "Wespenbussard": { status: "häufig" },
      "Mönchsgeier": { status: "sehr selten" },
      "Gänsegeier": { status: "sehr selten" },
      "Schlangenadler": { status: "sehr selten" },
      "Schelladler": { status: "sehr selten" },
      "Zwergadler": { status: "sehr selten" },
      "Steppenadler": { status: "sehr selten" },
      "Kaiseradler": { status: "sehr selten" },
      "Steinadler": { status: "häufig" },
      "Habichtsadler": { status: "sehr selten" },
      "Rohrweihe": { status: "häufig" },
      "Kornweihe": { status: "häufig" },
      "Steppenweihe": { status: "selten" },
      "Wiesenweihe": { status: "häufig" },
      "Sperber": { status: "häufig" },
      "Habicht": { status: "häufig" },
      "Rotmilan": { status: "häufig" },
      "Schwarzmilan": { status: "häufig" },
      "Seeadler": { status: "häufig" },
      "Raufußbussard": { status: "häufig" },
      "Mäusebussard": { status: "häufig" },
      "Adlerbussard": { status: "sehr selten" },
      "Kleinsumpfhuhn": { status: "selten" },
      "Zwergsumpfhuhn": { status: "sehr selten" },
      "Jungfernkranich": { status: "sehr selten" },
      "Kanadakranich": { status: "sehr selten" },
      "Kranich": { status: "häufig" },
      "Triel": { status: "sehr selten" },
      "Stelzenläufer": { status: "selten" },
      "Säbelschnäbler": { status: "häufig" },
      "Austernfischer": { status: "häufig" },
      "Kiebitzregenpfeifer": { status: "häufig" },
      "Goldregenpfeifer": { status: "häufig" },
      "Amerik. Goldregenpfeifer": { status: "sehr selten" },
      "Pazifischer Goldregenpfeifer": { status: "sehr selten" },
      "Mornellregenpfeifer": { status: "selten" },
      "Sandregenpfeifer": { status: "häufig" },
      "Flussregenpfeier": { status: "häufig" },
      "Kiebitz": { status: "häufig" },
      "Rotlappenkiebitz": { status: "sehr selten" },
      "Steppenkiebitz": { status: "sehr selten" },
      "Weißschwanzkiebitz": { status: "sehr selten" },
      "Wermutregenpfeifer": { status: "sehr selten" },
      "Mongolenregenpfeifer": { status: "sehr selten" },
      "Wüstenregenpfeifer": { status: "sehr selten" },
      "Seeregenpfeifer": { status: "häufig" },
      "Prärieläufer": { status: "sehr selten" },
      "Regenbrachvogel": { status: "häufig" },
      "Brachvogel": { status: "häufig" },
      "Pfuhlschnepfe": { status: "häufig" },
      "Uferschnepfe": { status: "häufig" },
      "Kleiner Schlammläufer": { status: "sehr selten" },
      "Tundra Schlammläufer": { status: "sehr selten" },
      "Zwergschnepfe": { status: "häufig" },
      "Waldschnepfe": { status: "häufig" },
      "Doppelschnepfe": { status: "sehr selten" },
      "Bekassine": { status: "häufig" },
      "Wilsonwassertreter": { status: "sehr selten" },
      "Thorshühnchen": { status: "selten" },
      "Odinshünnchen": { status: "selten" },
      "Terekwasserläufer": { status: "sehr selten" },
      "Flussuferläufer": { status: "häufig" },
      "Drosseluferläufer": { status: "sehr selten" },
      "Waldwasserläufer": { status: "häufig" },
      "Teichwasserläufer": { status: "selten" },
      "Bruchwasserläufer": { status: "häufig" },
      "Rotschenkel": { status: "häufig" },
      "Kleiner Gelbschenkel": { status: "sehr selten" },
      "Dunkelwasserläufer": { status: "häufig" },
      "Grünschenkel": { status: "häufig" },
      "Steinwälzer": { status: "häufig" },
      "Anadyrknutt": { status: "sehr selten" },
      "Knutt": { status: "häufig" },
      "Kampfläufer": { status: "häufig" },
      "Sumpfläufer": { status: "selten" },
      "Spitzschwanz-Strandläufer": { status: "sehr selten" },
      "Sichelstrandläufer": { status: "häufig" },
      "Bindenstrandläufer": { status: "sehr selten" },
      "Temminckstrandläufer": { status: "häufig" },
      "Langzehen-Strandläufer": { status: "sehr selten" },
      "Rotkehl-Strandläufer": { status: "sehr selten" },
      "Grasläufer": { status: "sehr selten" },
      "Sanderling": { status: "häufig" },
      "Alpenstrandläufer": { status: "häufig" },
      "Meerstrandläufer": { status: "häufig" },
      "Bairdstrandläufer": { status: "sehr selten" },
      "Zwergstrandläufer": { status: "häufig" },
      "Weißbürzel-Strandläufer": { status: "sehr selten" },
      "Wiesenstrandläufer": { status: "sehr selten" },
      "Graubrust-Strandläufer": { status: "sehr selten" },
      "Sandstrandläufer": { status: "sehr selten" },
      "Rennvogel": { status: "sehr selten" },
      "Orientbrachschwalbe": { status: "sehr selten" },
      "Schwarzflügel-Brachschwalbe": { status: "sehr selten" },
      "Rotflügel-Brachschwalbe": { status: "sehr selten" },
      "Falkenraubmöwe": { status: "selten" },
      "Schmarotzerraubmöwe": { status: "selten" },
      "Spatelraubmöwe": { status: "selten" },
      "Skua": { status: "selten" },
      "Papageitaucher": { status: "sehr selten" },
      "Gryllteiste": { status: "häufig" },
      "Tordalk": { status: "häufig" },
      "Krabbentaucher": { status: "selten" },
      "Dickschnabellumme": { status: "sehr selten" },
      "Trottellumme": { status: "häufig" },
      "Zwergmöwe": { status: "häufig" },
      "Rosenmöwe": { status: "sehr selten" },
      "Dreizehenmöwe": { status: "häufig" },
      "Elfenbeinmöwe": { status: "sehr selten" },
      "Schwalbenmöwe": { status: "sehr selten" },
      "Dünnschnabelmöwe": { status: "sehr selten" },
      "Bonapartemöwe": { status: "sehr selten" },
      "Lachmöwe": { status: "häufig" },
      "Aztekenmöwe": { status: "sehr selten" },
      "Präriemöwe": { status: "sehr selten" },
      "Fischmöwe": { status: "sehr selten" },
      "Korallenmöwe": { status: "sehr selten" },
      "Schwarzkopfmöwe": { status: "häufig" },
      "Sturmmöwe": { status: "häufig" },
      "Ringschnabelmöwe": { status: "sehr selten" },
      "Steppenmöwe": { status: "häufig" },
      "Silbermöwe": { status: "häufig" },
      "Amerik. Silbermöwe": { status: "sehr selten" },
      "Mittelmeermöwe": { status: "häufig" },
      "Mantelmöwe": { status: "häufig" },
      "Eismöwe": { status: "sehr selten" },
      "Heringsmöwe": { status: "häufig" },
      "Polarmöwe": { status: "sehr selten" },
      "Noddi": { status: "sehr selten" },
      "Rußseeschwalbe": { status: "sehr selten" },
      "Zügelseeschwalbe": { status: "sehr selten" },
      "Zwergseeschwalbe": { status: "häufig" },
      "Lachseeschwalbe": { status: "selten" },
      "Raubseeschwalbe": { status: "selten" },
      "Weißbart-Seeschwalbe": { status: "häufig" },
      "Trauerseeschwalbe": { status: "häufig" },
      "Weißflügel-Seeschwalbe": { status: "selten" },
      "Küstenseeschwalbe": { status: "häufig" },
      "Flussseeschwalbe": { status: "häufig" },
      "Rosenseeschwalbe": { status: "sehr selten" },
      "Brandseeschwalbe": { status: "häufig" },
      "Schmuckseeschwalbe": { status: "sehr selten" },
      "Rüppellseeschwalbe": { status: "sehr selten" },
      "Sterntaucher": { status: "häufig" },
      "Prachttaucher": { status: "häufig" },
      "Eistaucher": { status: "selten" },
      "Gelbschnabeltaucher": { status: "sehr selten" },
      "Schwarzbrauenalbatros": { status: "sehr selten" },
      "Buntfuß-Sturmschwalbe": { status: "sehr selten" },
      "Sturmwellenläufer": { status: "sehr selten" },
      "Wellenläufer": { status: "selten" },
      "Swinhoewellenläufer": { status: "sehr selten" },
      "Madeirawellenläufer": { status: "sehr selten" },
      "Eissturmvogel": { status: "häufig" },
      "Bulwersturmvogel": { status: "sehr selten" },
      "Gelbschnabel-Sturmtaucher": { status: "sehr selten" },
      "Kanarensturmtaucher": { status: "sehr selten" },
      "Kappensturmtaucher": { status: "sehr selten" },
      "Dunkelsturmtaucher": { status: "sehr selten" },
      "Atlantiksturmtaucher": { status: "sehr selten" },
      "Mittelmeer-Sturmtaucher": { status: "sehr selten" },
      "Makaronesiensturmtaucher": { status: "sehr selten" },
      "Schwarzstorch": { status: "häufig" },
      "Weißstorch": { status: "häufig" },
      "Basstölpel": { status: "häufig" },
      "Weißbauchtölpel": { status: "sehr selten" },
      "Zwergscharbe": { status: "sehr selten" },
      "Kormoran": { status: "häufig" },
      "Krähenscharbe": { status: "häufig" },
      "Rosapelikan": { status: "sehr selten" },
      "Krauskopfpelikan": { status: "sehr selten" },
      "Rohrdommel": { status: "häufig" },
      "Zwergdommel": { status: "häufig" },
      "Nachtreiher": { status: "selten" },
      "Schmuckreiher": { status: "sehr selten" },
      "Seidenreiher": { status: "selten" },
      "Rallenreiher": { status: "sehr selten" },
      "Kuhreiher": { status: "selten" },
      "Silberreiher": { status: "häufig" },
      "Graureiher": { status: "häufig" },
      "Purpurreiher": { status: "häufig" },
      "Sichler": { status: "sehr selten" },
      "Heiliger Ibis": { status: "Escape" },
      "Löffler": { status: "häufig" },
      "Fischadler": { status: "häufig" },
      "Schleiereule": { status: "häufig" },
      "Zwergohreule": { status: "sehr selten" },
      "Schneeeule": { status: "sehr selten" },
      "Uhu": { status: "häufig" },
      "Sperbereule": { status: "sehr selten" },
      "Sperlingskauz": { status: "häufig" },
      "Steinkauz": { status: "häufig" },
      "Waldkauz": { status: "häufig" },
      "Habichtskauz": { status: "selten" },
      "Waldohreule": { status: "häufig" },
      "Sumpfohreule": { status: "selten" },
      "Raufußkauz": { status: "häufig" },
      "Wiedehopf": { status: "häufig" },
      "Eisvogel": { status: "häufig" },
      "Bienenfresser": { status: "selten" },
      "Blauwangenspint": { status: "sehr selten" },
      "Blauracke": { status: "sehr selten" },
      "Wendehals": { status: "häufig" },
      "Dreiezehenspecht": { status: "häufig" },
      "Mittelspecht": { status: "häufig" },
      "Weißrückenspecht": { status: "selten" },
      "Buntspecht": { status: "häufig" },
      "Blutspecht": { status: "sehr selten" },
      "Kleinspecht": { status: "häufig" },
      "Grauspecht": { status: "häufig" },
      "Grünspecht": { status: "häufig" },
      "Schwarzspecht": { status: "häufig" },
      "Rötelfalke": { status: "sehr selten" },
      "Turmfalke": { status: "häufig" },
      "Rotfußfalke": { status: "selten" },
      "Eleonorenfalke": { status: "sehr selten" },
      "Merlin": { status: "häufig" },
      "Baumfalke": { status: "häufig" },
      "Gerfalke": { status: "sehr selten" },
      "Würgfalke": { status: "sehr selten" },
      "Wanderfalke": { status: "häufig" },
      "Alexandersittich": { status: "häufig" },
      "Halsbandsittich": { status: "häufig" },
      "Gelbkopfamazone": { status: "Escape" },
      "Rotaugenvireo": { status: "sehr selten" },
      "Gelbkehlvireo": { status: "sehr selten" },
      "Pirol": { status: "häufig" },
      "Neuntöter": { status: "häufig" },
      "Turkestanwürger": { status: "sehr selten" },
      "Isabellwürger": { status: "sehr selten" },
      "Braunwürger": { status: "sehr selten" },
      "Raubwürger": { status: "häufig" },
      "Schwarzstirnwürger": { status: "sehr selten" },
      "Maskenwürger": { status: "sehr selten" },
      "Rotkopfwürger": { status: "sehr selten" },
      "Eichelhäher": { status: "häufig" },
      "Elster": { status: "häufig" },
      "Tannenhäher": { status: "häufig" },
      "Alpenkrähe": { status: "sehr selten" },
      "Alpendohle": { status: "häufig" },
      "Dohle": { status: "häufig" },
      "Elsterdohle": { status: "sehr selten" },
      "Saatkrähe": { status: "häufig" },
      "Aaskrähe": { status: "häufig" },
      "Rabenkrähe": { status: "häufig" },
      "Kolkrabe": { status: "häufig" },
      "Tannenmeise": { status: "häufig" },
      "Haubenmeise": { status: "häufig" },
      "Sumpfmeise": { status: "häufig" },
      "Weidenmeise": { status: "häufig" },
      "Blaumeise": { status: "häufig" },
      "Lasurmeise": { status: "sehr selten" },
      "Kohlmeise": { status: "häufig" },
      "Beutelmeise": { status: "häufig" },
      "Ohrenlerche": { status: "häufig" },
      "Kurzzehenlerche": { status: "sehr selten" },
      "Bergkalanderlerche": { status: "sehr selten" },
      "Kalanderlerche": { status: "sehr selten" },
      "Turkestanstummellerche": { status: "sehr selten" },
      "Heidelerche": { status: "häufig" },
      "Weißflügellerche": { status: "sehr selten" },
      "Feldlerche": { status: "häufig" },
      "Haubenlerche": { status: "häufig" },
      "Bartmeise": { status: "häufig" },
      "Buschspötter": { status: "sehr selten" },
      "Steppenspötter": { status: "sehr selten" },
      "Blassspötter": { status: "sehr selten" },
      "Isabellspötter": { status: "sehr selten" },
      "Orpheusspötter": { status: "selten" },
      "Gelbspötter": { status: "häufig" },
      "Seggenrohrsänger": { status: "sehr selten" },
      "Mariskenrohrsänger": { status: "sehr selten" },
      "Schilfrohrsänger": { status: "häufig" },
      "Feldrohrsänger": { status: "sehr selten" },
      "Buschrohrsänger": { status: "sehr selten" },
      "Sumpfrohrsänger": { status: "häufig" },
      "Teichrohrsänger": { status: "häufig" },
      "Drosselrohrsänger": { status: "häufig" },
      "Streifenschwirl": { status: "sehr selten" },
      "Strichelschwirl": { status: "sehr selten" },
      "Feldschwirl": { status: "häufig" },
      "Rohrschwirl": { status: "häufig" },
      "Schlagschwirl": { status: "häufig" },
      "Mehlschwalbe": { status: "häufig" },
      "Rauchschwalbe": { status: "häufig" },
      "Uferschwalbe": { status: "häufig" },
      "Felsenschwalbe": { status: "häufig" },
      "Rötelschwalbe": { status: "sehr selten" },
      "Waldlaubsänger": { status: "häufig" },
      "Berglaubsänger": { status: "häufig" },
      "Balkanlaubsänger": { status: "sehr selten" },
      "Gelbbrauen-Laubsänger": { status: "selten" },
      "Tienschan-Laubsänger": { status: "sehr selten" },
      "Goldhähnchen-Laubsänger": { status: "sehr selten" },
      "Bartlaubsänger": { status: "sehr selten" },
      "Dunkellaubsänger": { status: "sehr selten" },
      "Zilpzalp": { status: "häufig" },
      "Fitis": { status: "häufig" },
      "Iberischer Zilpzalp": { status: "sehr selten" },
      "Kronenlaubsänger": { status: "sehr selten" },
      "Wacholderlaubsänger": { status: "sehr selten" },
      "Grünlaubsänger": { status: "selten" },
      "Middendorflaubsänger": { status: "sehr selten" },
      "Wanderlaubsänger": { status: "sehr selten" },
      "Seidensänger": { status: "selten" },
      "Schwanzmeise": { status: "häufig" },
      "Mönchsgrasmücke": { status: "häufig" },
      "Gartengrasmücke": { status: "häufig" },
      "Sperbergrasmücke": { status: "häufig" },
      "Klappergrasmücke": { status: "häufig" },
      "Orpheusgrasmücke": { status: "sehr selten" },
      "Wüstengrasmücke": { status: "sehr selten" },
      "Samtkopf-Grasmücke": { status: "sehr selten" },
      "Liguriengrasmücke": { status: "sehr selten" },
      "Balkan-Bartgrasmücke": { status: "sehr selten" },
      "Ligurien-Bartgrasmücke": { status: "sehr selten" },
      "Dorngrasmücke": { status: "häufig" },
      "Provencegrasmücke": { status: "sehr selten" },
      "Brillengrasmücke": { status: "sehr selten" },
      "Wintergoldhähnchen": { status: "häufig" },
      "Sommergoldhähnchen": { status: "häufig" },
      "Mauerläufer": { status: "häufig" },
      "Kleiber": { status: "häufig" },
      "Rotbrustkleiber": { status: "häufig" },
      "Waldbaumläufer": { status: "häufig" },
      "Gartenbaumläufer": { status: "häufig" },
      "Zaunkönig": { status: "häufig" },
      "Wasseramsel": { status: "häufig" },
      "Star": { status: "häufig" },
      "Rosenstar": { status: "sehr selten" },
      "Katzenvogel": { status: "sehr selten" },
      "Spottdrossel": { status: "sehr selten" },
      "Erdsrossel": { status: "sehr selten" },
      "Grauwangendrossel": { status: "sehr selten" },
      "Zwergmusendrossel": { status: "sehr selten" },
      "Einsiedlerdrossel": { status: "sehr selten" },
      "Schieferdrossel": { status: "sehr selten" },
      "Misteldrossel": { status: "häufig" },
      "Singdrossel": { status: "häufig" },
      "Rotdrossel": { status: "häufig" },
      "Amsel": { status: "häufig" },
      "Einfarbdrossel": { status: "sehr selten" },
      "Wanderdrossel": { status: "sehr selten" },
      "Weißbrauendrossel": { status: "sehr selten" },
      "Wacholderdrossel": { status: "häufig" },
      "Ringdrossel": { status: "häufig" },
      "Schwarzkehldrossel": { status: "sehr selten" },
      "Rotkehldrossel": { status: "sehr selten" },
      "Rostflügeldrossel": { status: "sehr selten" },
      "Naumanndrossel": { status: "sehr selten" },
      "Grauschnäpper": { status: "häufig" },
      "Heckensänger": { status: "sehr selten" },
      "Rotkehlchen": { status: "häufig" },
      "Sprosser": { status: "häufig" },
      "Nachtigall": { status: "häufig" },
      "Blaukehlchen": { status: "häufig" },
      "Rubinkehlchen": { status: "sehr selten" },
      "Blauschwanz": { status: "sehr selten" },
      "Taigaschnäpper": { status: "sehr selten" },
      "Zwergschnäpper": { status: "selten" },
      "Trauerschnäpper": { status: "häufig" },
      "Halsbandschnäpper": { status: "sehr selten" },
      "Gartenrotschwanz": { status: "häufig" },
      "Hausrotschwanz": { status: "häufig" },
      "Steinrötel": { status: "selten" },
      "Blaumerle": { status: "sehr selten" },
      "Braunkehlchen": { status: "häufig" },
      "Schwarzkehlchen": { status: "häufig" },
      "Sibirisches Schwarzkehlchen": { status: "sehr selten" },
      "Steinschmätzer": { status: "häufig" },
      "Isabellsteinschmätzer": { status: "sehr selten" },
      "Wüstensteinschmätzer": { status: "sehr selten" },
      "Maurensteinschmätzer": { status: "sehr selten" },
      "Zypernsteinschmätzer": { status: "sehr selten" },
      "Balkansteinschmätzer": { status: "sehr selten" },
      "Nonnensteinschmätzer": { status: "sehr selten" },
      "Saharasteinschmätzer": { status: "sehr selten" },
      "Seidenschwanz": { status: "selten" },
      "Alpenbraunelle": { status: "häufig" },
      "Bergbraunelle": { status: "sehr selten" },
      "Schwarzkehlbraunelle": { status: "sehr selten" },
      "Heckenbraunelle": { status: "häufig" },
      "Haussperling": { status: "häufig" },
      "Italiensperling": { status: "sehr selten" },
      "Feldsperling": { status: "häufig" },
      "Schneesperling": { status: "häufig" },
      "Steinsperling": { status: "sehr selten" },
      "Weidensperling": { status: "sehr selten" },
      "Gebirgsstelze": { status: "häufig" },
      "Schafstelze": { status: "häufig" },
      "Bachstelze": { status: "häufig" },
      "Tschuktschenstelze": { status: "sehr selten" },
      "Zitronenstelze": { status: "selten" },
      "Spornpieper": { status: "sehr selten" },
      "Steppenpieper": { status: "sehr selten" },
      "Brachpieper": { status: "häufig" },
      "Wiesenpieper": { status: "häufig" },
      "Baumpieper": { status: "häufig" },
      "Waldpieper": { status: "sehr selten" },
      "Petschorapieper": { status: "sehr selten" },
      "Rotkehlpieper": { status: "selten" },
      "Bergpieper": { status: "häufig" },
      "Strandpieper": { status: "häufig" },
      "Buchfink": { status: "häufig" },
      "Bergfink": { status: "häufig" },
      "Kernbeißer": { status: "häufig" },
      "Karmingimpel": { status: "häufig" },
      "Hakengimpel": { status: "sehr selten" },
      "Gimpel": { status: "häufig" },
      "Wüstengimpel": { status: "sehr selten" },
      "Grünfink": { status: "häufig" },
      "Berghänfling": { status: "häufig" },
      "Bluthänfling": { status: "häufig" },
      "Birkenzeisig": { status: "häufig" },
      "Kiefernkreuzschnabel": { status: "sehr selten" },
      "Fichtenkreuzschnabel": { status: "häufig" },
      "Bindenkreuzschnabel": { status: "sehr selten" },
      "Girlitz": { status: "häufig" },
      "Zitronengirlitz": { status: "selten" },
      "Stieglitz": { status: "häufig" },
      "Erlenzeisig": { status: "häufig" },
      "Spornammer": { status: "häufig" },
      "Schneeammer": { status: "häufig" },
      "Kappenammer": { status: "" },
      "Braunkopfammer": { status: "" },
      "Grauammer": { status: "häufig" },
      "Zippammer": { status: "selten" },
      "Zaunammer": { status: "selten" },
      "Goldammer": { status: "häufig" },
      "Fichtenammer": { status: "sehr selten" },
      "Steinortolan": { status: "sehr selten" },
      "Türkenammer": { status: "sehr selten" },
      "Ortolan": { status: "häufig" },
      "Rohrammer": { status: "häufig" },
      "Grauortolan": { status: "sehr selten" },
      "Weidenammer": { status: "sehr selten" },
      "Zwergammer": { status: "sehr selten" },
      "Waldammer": { status: "sehr selten" },
      "Maskenammer": { status: "sehr selten" },
      "Fuchsammer": { status: "sehr selten" },
      "Weißkehlammer": { status: "sehr selten" },
      "Singammer": { status: "sehr selten" },
      "Braunkopf-Kuhstärling": { status: "sehr selten" },
      "Meisenwaldsänger": { status: "sehr selten" },
      "Grünwaldsänger": { status: "sehr selten" },
      "Rosenbrustkernknacker": { status: "sehr selten" }
    };
    

    
    // Hilfsfunktion für Seltenheits-Styling
    function getRarityStyle(birdName, manualRarity) {
      // Wenn manuelle Seltenheit gesetzt ist, nutze diese
      let status = '';
      if (manualRarity) {
        status = manualRarity;
      } else {
        const speciesInfo = birdDatabase[birdName] || {};
        status = speciesInfo.status || '';
      }
      
      let rarityClass = '';
      let rarityIcon = '';
      
      // SVG für oranges Ausrufezeichen (nur für sehr seltene Arten)
      const orangeWarningIcon = `<span class="rarity-indicator"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2L2 20h20L12 2z" fill="#FFD700" stroke="#ff0000" stroke-width="2"/>
        <path d="M12 9v4M12 17h.01" stroke="#ff0000" stroke-width="2" stroke-linecap="round"/>
      </svg></span>`;
      
      // Normalisiere Status (Escape mit großem E)
      const normalizedStatus = status.toLowerCase();
      
      if (normalizedStatus === 'escape') {
        rarityClass = 'escape';
        rarityIcon = ''; // Kein Icon für Escape-Arten
      } else if (status === 'sehr selten') {
        rarityClass = 'very-rare';
        rarityIcon = orangeWarningIcon;
      } else if (status === 'selten') {
        rarityClass = 'rare';
        rarityIcon = ''; // Kein Icon für seltene Arten
      }
      
      return { rarityClass, rarityIcon };
    }
    
    // Funktion zum Aktualisieren des Seltenheits-Labels
    function updateRarityLabel(value) {
      const label = document.getElementById('rarityLabel');
      const rarityNames = ['Häufig', 'Selten', 'Sehr selten', 'Escape'];
      const colors = ['var(--text)', '#ef4444', '#dc2626', '#3b82f6'];
      
      if (label) {
        label.textContent = rarityNames[value];
        label.style.color = colors[value];
      }
    }
    
    // Funktion zum Aktualisieren des Seltenheits-Labels (Intelligente Eingabe)
    function updateInputRarityLabel(value) {
      const label = document.getElementById('inputRarityLabel');
      const rarityNames = ['Standard (aus Datenbank)', 'Selten', 'Sehr selten', 'Escape'];
      const colors = ['var(--text)', '#ef4444', '#dc2626', '#3b82f6'];
      
      if (label) {
        label.textContent = rarityNames[value];
        label.style.color = colors[value];
      }
    }
    
    // Funktion zum Zurücksetzen des Seltenheits-Reglers
    function resetRaritySlider() {
      const slider = document.getElementById('modalRarity');
      const label = document.getElementById('rarityLabel');
      if (slider) slider.value = 0;
      if (label) {
        label.textContent = 'Standard (aus Datenbank)';
        label.style.color = 'var(--text)';
      }
    }
    
    // Funktion zum Zurücksetzen des Seltenheits-Reglers (Intelligente Eingabe)
    function resetInputRaritySlider() {
      const slider = document.getElementById('inputRarity');
      const label = document.getElementById('inputRarityLabel');
      if (slider) slider.value = 0;
      if (label) {
        label.textContent = 'Standard (aus Datenbank)';
        label.style.color = 'var(--text)';
      }
    }
    
    // Wetter-Daten
    const weatherConditions = {
      sunny: { icon: "☀️", temp: "15-25°C", desc: "Sonnig" },
      cloudy: { icon: "☁️", temp: "10-18°C", desc: "Bewölkt" },
      rainy: { icon: "🌧️", temp: "8-15°C", desc: "Regnerisch" },
      snowy: { icon: "❄️", temp: "-5-5°C", desc: "Schnee" }
    };
    
    // ---------- NEUE FUNKTIONEN FÜR FOTO-LIGHTBOX ----------
    
    function openPhotoLightbox(photoSrc, caption) {
      const lightbox = document.getElementById('photoLightbox');
      const photo = document.getElementById('lightboxPhoto');
      const captionElement = document.getElementById('lightboxCaption');
      
      photo.src = photoSrc;
      captionElement.textContent = caption || 'Vogelbeobachtungsfoto';
      
      lightbox.classList.add('active');
      document.body.style.overflow = 'hidden'; // Verhindert Scrollen hinter der Lightbox
    }
    
    function closePhotoLightbox() {
      const lightbox = document.getElementById('photoLightbox');
      lightbox.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    // Klicken außerhalb des Bildes schließt die Lightbox
    document.getElementById('photoLightbox').addEventListener('click', function(e) {
      if (e.target === this || e.target.classList.contains('lightbox-close')) {
        closePhotoLightbox();
      }
    });
    
    // ESC-Taste schließt die Lightbox
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && document.getElementById('photoLightbox').classList.contains('active')) {
        closePhotoLightbox();
      }
    });
    
    // ---------- IndexedDB Funktionen ----------
    // Datenbank initialisieren
    function initDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = function(event) {
          const db = event.target.result;
          console.log('Upgrading database to version:', DB_VERSION);
          
          // Beobachtungen Store
          if (!db.objectStoreNames.contains('observations')) {
            const store = db.createObjectStore('observations', { keyPath: 'id' });
            store.createIndex('date', 'date', { unique: false });
            store.createIndex('bird', 'bird', { unique: false });
            store.createIndex('folderId', 'folderId', { unique: false });
            store.createIndex('folderName', 'folderName', { unique: false });
          }
          
          // Ordner Store (enthält nur Ordner-Metadaten)
          if (!db.objectStoreNames.contains('folders')) {
            const folderStore = db.createObjectStore('folders', { keyPath: 'id' });
            folderStore.createIndex('name', 'name', { unique: false });
          }
          
          // Listen Store
          if (!db.objectStoreNames.contains('lists')) {
            const listsStore = db.createObjectStore('lists', { keyPath: 'id' });
            listsStore.createIndex('name', 'name', { unique: false });
            listsStore.createIndex('createdAt', 'createdAt', { unique: false });
          }
          
          // Arten-Datenbank Store
          if (!db.objectStoreNames.contains('species')) {
            const speciesStore = db.createObjectStore('species', { keyPath: 'name' });
            speciesStore.createIndex('family', 'family', { unique: false });
            speciesStore.createIndex('status', 'status', { unique: false });
          }
          
          // Einstellungen Store
          if (!db.objectStoreNames.contains('settings')) {
            db.createObjectStore('settings', { keyPath: 'key' });
          }
          
          // Fotos Store (für Base64-Daten)
          if (!db.objectStoreNames.contains('photos')) {
            const photosStore = db.createObjectStore('photos', { keyPath: 'id' });
            photosStore.createIndex('observationId', 'observationId', { unique: true });
          }
        };
        
        request.onsuccess = function(event) {
          db = event.target.result;
          console.log('IndexedDB erfolgreich initialisiert:', DB_NAME, 'Version:', DB_VERSION);
          
          // Migriere bestehende localStorage-Daten zu IndexedDB
          migrateLocalStorageToIndexedDB().then(() => {
            resolve(db);
          }).catch(err => {
            console.warn('Migration fehlgeschlagen:', err);
            resolve(db); // Trotzdem fortfahren
          });
        };
        
        request.onerror = function(event) {
          console.error('IndexedDB Fehler:', event.target.error);
          reject(event.target.error);
        };
      });
    }
    
    // Migriere localStorage-Daten zu IndexedDB
    async function migrateLocalStorageToIndexedDB() {
      try {
        // Migriere Vogelbeobachtungen
        const vogelData = JSON.parse(localStorage.getItem('vogelData') || '[]');
        if (vogelData.length > 0) {
          console.log('Migriere', vogelData.length, 'Ordner zu IndexedDB...');
          
          for (const folder of vogelData) {
            // Speichere Ordner-Metadaten
            await saveToIndexedDB('folders', {
              id: folder.id,
              name: folder.name,
              color: folder.color,
              createdAt: new Date().toISOString()
            });
            
            // Speichere Beobachtungen
            for (const map of folder.maps) {
              for (const row of map.rows) {
                if (row.bird) {
                  await saveToIndexedDB('observations', {
                    id: row.id,
                    bird: row.bird,
                    date: row.date || '',
                    lat: row.lat || '',
                    lng: row.lng || '',
                    folderId: folder.id,
                    folderName: folder.name,
                    folderColor: folder.color,
                    time: row.time || '',
                    count: row.count || '1',
                    behavior: row.behavior || '',
                    weather: row.weather || '',
                    photo: row.photo || '',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                  });
                  
                  // Speichere Foto separat
                  if (row.photo) {
                    await saveToIndexedDB('photos', {
                      id: 'photo_' + row.id,
                      observationId: row.id,
                      data: row.photo,
                      createdAt: new Date().toISOString()
                    });
                  }
                }
              }
            }
          }
          
          console.log('Migration der Beobachtungen abgeschlossen');
        }
        
        // Migriere Listen
        const userLists = JSON.parse(localStorage.getItem('userLists') || '[]');
        if (userLists.length > 0) {
          console.log('Migriere', userLists.length, 'Listen zu IndexedDB...');
          for (const list of userLists) {
            await saveToIndexedDB('lists', list);
          }
        }
        
        // Migriere Vogelarten-Datenbank
        await populateSpeciesDatabase();
        
        console.log('Migration zu IndexedDB abgeschlossen');
      } catch (error) {
        console.error('Fehler bei der Migration:', error);
        throw error;
      }
    }
    
    // Populiere die Arten-Datenbank
    async function populateSpeciesDatabase() {
      const speciesStore = getStore('species', 'readwrite');
      if (!speciesStore) return;
      
      for (const [name, data] of Object.entries(birdDatabase)) {
        await saveToIndexedDB('species', {
          name: name,
          ...data
        });
      }
      console.log('Arten-Datenbank populiert');
    }
    
    // Generische Funktion zum Speichern in IndexedDB
    function saveToIndexedDB(storeName, data) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('IndexedDB nicht initialisiert'));
          return;
        }
        
        const transaction = db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        const request = store.put(data);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Generische Funktion zum Laden aus IndexedDB
    function getFromIndexedDB(storeName, key) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('IndexedDB nicht initialisiert'));
          return;
        }
        
        const transaction = db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.get(key);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Alle Einträge aus einem Store laden
    function getAllFromIndexedDB(storeName, indexName = null, range = null) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('IndexedDB nicht initialisiert'));
          return;
        }
        
        const transaction = db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        let request;
        
        if (indexName && range) {
          const index = store.index(indexName);
          request = index.getAll(range);
        } else if (indexName) {
          const index = store.index(indexName);
          request = index.getAll();
        } else {
          request = store.getAll();
        }
        
        request.onsuccess = () => resolve(request.result || []);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Nach Datum filtern
    async function getObservationsByDateRange(startDate, endDate) {
      if (!db) return [];
      
      const allObservations = await getAllFromIndexedDB('observations');
      
      return allObservations.filter(obs => {
        if (!obs.date) return false;
        const obsDate = new Date(obs.date);
        return obsDate >= startDate && obsDate <= endDate;
      });
    }
    
    // Eintrag löschen
    function deleteFromIndexedDB(storeName, key) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('IndexedDB nicht initialisiert'));
          return;
        }
        
        const transaction = db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        const request = store.delete(key);
        
        request.onsuccess = () => resolve(true);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Store für Transaktionen holen
    function getStore(storeName, mode = 'readonly') {
      if (!db) return null;
      const transaction = db.transaction([storeName], mode);
      return transaction.objectStore(storeName);
    }
    
    // Datenbankstatistiken
    async function getDatabaseStats() {
      if (!db) return null;
      
      const observations = await getAllFromIndexedDB('observations');
      const folders = await getAllFromIndexedDB('folders');
      const lists = await getAllFromIndexedDB('lists');
      
      // Berechne Gesamtgröße
      let totalSize = 0;
      const stores = ['observations', 'folders', 'lists', 'species', 'settings', 'photos'];
      
      for (const storeName of stores) {
        const data = await getAllFromIndexedDB(storeName);
        totalSize += JSON.stringify(data).length;
      }
      
      return {
        totalObservations: observations.length,
        totalFolders: folders.length,
        totalLists: lists.length,
        totalSize: Math.round(totalSize / 1024) + ' KB',
        lastSync: new Date().toLocaleString()
      };
    }
    
    // Datenbank exportieren
    async function exportDatabase() {
      if (!db) return null;
      
      const exportData = {
        version: DB_VERSION,
        exportDate: new Date().toISOString(),
        observations: await getAllFromIndexedDB('observations'),
        folders: await getAllFromIndexedDB('folders'),
        lists: await getAllFromIndexedDB('lists'),
        species: await getAllFromIndexedDB('species'),
        settings: await getAllFromIndexedDB('settings')
      };
      
      return exportData;
    }
    
    // Alle Daten aus der Datenbank löschen
    async function clearAllData() {
      if (!db) {
        throw new Error('IndexedDB nicht initialisiert');
      }
      
      const stores = ['observations', 'folders', 'lists', 'species', 'settings', 'photos'];
      
      for (const storeName of stores) {
        const transaction = db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        await new Promise((resolve, reject) => {
          const request = store.clear();
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }
      
      console.log('✅ Alle Daten gelöscht');
    }
    
    // Datenbank importieren
    async function importDatabase(data) {
      if (!db || !data) return false;
      
      try {
        // Lösche alle vorhandenen Daten
        const stores = ['observations', 'folders', 'lists', 'species', 'settings', 'photos'];
        for (const storeName of stores) {
          const allItems = await getAllFromIndexedDB(storeName);
          for (const item of allItems) {
            await deleteFromIndexedDB(storeName, item.id || item.name || item.key);
          }
        }
        
        // Importiere neue Daten
        if (data.observations) {
          for (const obs of data.observations) {
            // NEU: Überspringe Beobachtungen mit Vögeln, die nicht in der Datenbank sind
            if (obs.bird && !birdDatabase[obs.bird]) {
              console.warn('Überspringe Beobachtung mit ungültiger Vogelart:', obs.bird);
              continue;
            }
            await saveToIndexedDB('observations', obs);
          }
        }
        
        if (data.folders) {
          for (const folder of data.folders) {
            await saveToIndexedDB('folders', folder);
          }
        }
        
        if (data.lists) {
          for (const list of data.lists) {
            await saveToIndexedDB('lists', list);
          }
        }
        
        if (data.species) {
          for (const species of data.species) {
            await saveToIndexedDB('species', species);
          }
        }
        
        if (data.settings) {
          for (const setting of data.settings) {
            await saveToIndexedDB('settings', setting);
          }
        }
        
        return true;
      } catch (error) {
        console.error('Import fehlgeschlagen:', error);
        return false;
      }
    }
    
    // ---------- Modifizierte Datenfunktionen für IndexedDB ----------
    
    // Alle Beobachtungen laden (ersetzt getAllObservationsWithDetails)
    async function getAllObservationsWithDetails() {
      try {
        // Prüfe ob wir im Gruppen-Modus sind
        if(window.currentSelectedGroup && window.currentSelectedGroup !== "personal"){
          console.log("📊 Lade Gruppendaten für Analyse/Statistik:", window.currentSelectedGroup);
          
          // Lade Gruppendaten aus Firebase
          return new Promise(function(resolve, reject){
            // NEU: Lade zuerst die Gruppenmitglieder
            var membersPromise = window.FBD.ref("groups/" + window.currentSelectedGroup + "/members").once("value");
            
            membersPromise.then(function(membersSnapshot) {
              var members = {};
              if (membersSnapshot.exists()) {
                membersSnapshot.forEach(function(memberSnap) {
                  members[memberSnap.key] = memberSnap.val();
                });
              }
              
              // Dann lade Beobachtungen
              window.FBD.ref("groups/" + window.currentSelectedGroup + "/observations").once("value").then(function(snapshot){
                if(!snapshot.exists()){
                  console.log("📭 Keine Gruppendaten verfügbar");
                  resolve([]);
                  return;
                }
                
                var observations = [];
                
                // Erstelle eine Map für User-Namen aus Firebase Auth
                var userNamesMap = {};
                
                snapshot.forEach(function(childSnap){
                  var obs = childSnap.val();
                  obs.id = childSnap.key;
                  
                  // NEU: Überspringe Beobachtungen von nicht-Mitgliedern
                  if (!members[obs.userId]) {
                    return; // Skip diese Beobachtung
                  }
                  
                  // Sammle UserIDs für Farbzuweisung
                  if (obs.userId && !userColorsSorted.includes(obs.userId)) {
                    userColorsSorted.push(obs.userId);
                  }
                  
                  // Füge Ordner-Informationen hinzu (für Gruppenmitglieder)
                  // Verwende userId als folderId für Gruppierung nach Benutzer
                  obs.folderId = obs.userId || 'unknown_user';
                  obs.folderName = obs.userName || obs.userEmail || members[obs.userId]?.name || 'Unbekannter Benutzer';
                  
                  observations.push(obs);
                });
                
                // NEU: Sortiere UserIDs und weise Farben zu
                userColorsSorted.sort();
                console.log('🎨 Sortierte UserIDs:', userColorsSorted);
                userColorsSorted.forEach(function(userId, index) {
                  userColors[userId] = colorPalette[index % colorPalette.length];
                  console.log(`   ${index}: ${userId} → ${userColors[userId]}`);
                });
                
                // Jetzt füge Farben zu Beobachtungen hinzu
                observations.forEach(function(obs) {
                  if (obs.userId) {
                    obs.folderColor = userColors[obs.userId];
                  } else {
                    obs.folderColor = colorPalette[0];
                  }
                });
                
                // Aktualisiere Namen für den aktuellen User (falls angemeldet)
                if (window.FBA && window.FBA.currentUser) {
                  var currentUser = window.FBA.currentUser;
                  var currentUserId = currentUser.uid;
                  var currentDisplayName = currentUser.displayName || currentUser.email.split("@")[0];
                  
                  observations.forEach(function(obs) {
                    if (obs.userId === currentUserId) {
                      // Überschreibe mit aktuellem displayName
                      obs.userName = currentDisplayName;
                      obs.folderName = currentDisplayName;
                    }
                  });
                }
                
                console.log("✅ " + observations.length + " Gruppen-Beobachtungen für Analyse geladen");
                resolve(observations);
              }).catch(function(error){
                console.error("❌ Fehler beim Laden der Gruppendaten:", error);
                resolve([]);
              });
            }).catch(function(error){
              console.error("❌ Fehler beim Laden der Gruppenmitglieder:", error);
              resolve([]);
            });
          });
        }
        
        // Sonst: Lade persönliche Daten aus IndexedDB
        console.log("📊 Lade persönliche Daten für Analyse/Statistik");
        const observations = await getAllFromIndexedDB('observations');
        
        // Hole Ordner-Farben für zusätzliche Formatierung
        const folders = await getAllFromIndexedDB('folders');
        const folderMap = {};
        folders.forEach(folder => {
          folderMap[folder.id] = folder;
        });
        
        // Bereichere Beobachtungen mit Ordner-Informationen
        return observations.map(obs => ({
          ...obs,
          folderName: obs.folderName || (folderMap[obs.folderId]?.name || 'Unbekannt'),
          folderColor: obs.folderColor || (folderMap[obs.folderId]?.color || colorPalette[0])
        }));
      } catch (error) {
        console.error('Fehler beim Laden der Beobachtungen:', error);
        return [];
      }
    }
    
    // NEU: Funktion um IMMER persönliche Beobachtungen zu laden (für Listen)
    async function getPersonalObservationsWithDetails() {
      try {
        console.log("📊 Lade persönliche Daten für Listen");
        const observations = await getAllFromIndexedDB('observations');
        
        // Hole Ordner-Farben für zusätzliche Formatierung
        const folders = await getAllFromIndexedDB('folders');
        const folderMap = {};
        folders.forEach(folder => {
          folderMap[folder.id] = folder;
        });
        
        // Bereichere Beobachtungen mit Ordner-Informationen
        return observations.map(obs => ({
          ...obs,
          folderName: obs.folderName || (folderMap[obs.folderId]?.name || 'Unbekannt'),
          folderColor: obs.folderColor || (folderMap[obs.folderId]?.color || colorPalette[0])
        }));
      } catch (error) {
        console.error('Fehler beim Laden der persönlichen Beobachtungen:', error);
        return [];
      }
    }
    
    // Reverse Geocoding: Bundesland aus Koordinaten ermitteln
    async function getStateFromCoordinates(lat, lng) {
      try {
        // Cache für bereits abgefragte Koordinaten (um API-Aufrufe zu reduzieren)
        const cacheKey = `${lat.toFixed(2)}_${lng.toFixed(2)}`;
        const cached = sessionStorage.getItem(`state_${cacheKey}`);
        if (cached) {
          return cached;
        }
        
        // CORS-Warnung im Cache speichern, damit wir nicht wiederholt fehlschlagen
        const corsFailed = sessionStorage.getItem('geocoding_cors_failed');
        if (corsFailed === 'true') {
          return null; // Überspringe weitere Versuche
        }
        
        // Nominatim API von OpenStreetMap
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10&addressdetails=1`,
          {
            headers: {
              'User-Agent': 'VogelzaehlungApp/1.0'
            }
          }
        );
        
        if (!response.ok) {
          console.warn('Reverse geocoding fehlgeschlagen:', response.status);
          return null;
        }
        
        const data = await response.json();
        
        // Extrahiere Bundesland
        let state = data.address?.state || null;
        
        // Cache das Ergebnis
        if (state) {
          sessionStorage.setItem(`state_${cacheKey}`, state);
        }
        
        return state;
      } catch (error) {
        // CORS-Fehler erkennen
        if (error.message && (error.message.includes('CORS') || error.message.includes('fetch'))) {
          console.warn('⚠️ Reverse Geocoding durch CORS blockiert. Bundesland-Filter wird übersprungen.');
          sessionStorage.setItem('geocoding_cors_failed', 'true');
        } else {
          console.error('Fehler beim Reverse Geocoding:', error);
        }
        return null;
      }
    }
    
    // Beobachtung speichern (ersetzt saveData für neue Beobachtungen)
    async function saveNewObservationToDB(observation) {
      try {
        // Generiere ID falls nicht vorhanden
        if (!observation.id) {
          observation.id = 'obs_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Hole Bundesland aus Koordinaten, falls noch nicht vorhanden
        if (observation.lat && observation.lng && !observation.state) {
          observation.state = await getStateFromCoordinates(
            parseFloat(observation.lat), 
            parseFloat(observation.lng)
          );
        }
        
        // Setze Zeitstempel
        observation.createdAt = observation.createdAt || new Date().toISOString();
        observation.updatedAt = new Date().toISOString();
        
        // Speichere in IndexedDB
        await saveToIndexedDB('observations', observation);
        
        // Falls Foto vorhanden, speichere es separat
        if (observation.photo) {
          await saveToIndexedDB('photos', {
            id: 'photo_' + observation.id,
            observationId: observation.id,
            data: observation.photo,
            createdAt: new Date().toISOString()
          });
        }
        
        console.log('Beobachtung gespeichert:', observation.id);
        return observation.id;
      } catch (error) {
        console.error('Fehler beim Speichern der Beobachtung:', error);
        throw error;
      }
    }
    
    // Aktualisiere bestehende Beobachtungen ohne Bundesland
    async function updateObservationsWithMissingStates() {
      try {
        const observations = await getAllFromIndexedDB('observations');
        let updatedCount = 0;
        
        for (const obs of observations) {
          // Wenn Koordinaten vorhanden sind, aber kein Bundesland
          if (obs.lat && obs.lng && !obs.state) {
            const state = await getStateFromCoordinates(
              parseFloat(obs.lat), 
              parseFloat(obs.lng)
            );
            
            if (state) {
              obs.state = state;
              obs.updatedAt = new Date().toISOString();
              await saveToIndexedDB('observations', obs);
              updatedCount++;
            }
            
            // Kleine Verzögerung, um API-Rate-Limits zu respektieren
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
        if (updatedCount > 0) {
          console.log(`${updatedCount} Beobachtungen mit Bundesland-Information aktualisiert`);
        }
      } catch (error) {
        console.error('Fehler beim Aktualisieren der Bundesland-Informationen:', error);
      }
    }
    
    // Beobachtung löschen
    async function deleteObservationFromDB(observationId) {
      try {
        // Lösche Beobachtung
        await deleteFromIndexedDB('observations', observationId);
        
        // Lösche zugehöriges Foto
        try {
          const photos = await getAllFromIndexedDB('photos');
          const photo = photos.find(p => p.observationId === observationId);
          if (photo) {
            await deleteFromIndexedDB('photos', photo.id);
          }
        } catch (photoError) {
          console.warn('Foto konnte nicht gelöscht werden:', photoError);
        }
        
        console.log('Beobachtung gelöscht:', observationId);
        return true;
      } catch (error) {
        console.error('Fehler beim Löschen der Beobachtung:', error);
        throw error;
      }
    }
    
    // Ordner speichern
    async function saveFolderToDB(folder) {
      try {
        if (!folder.id) {
          folder.id = 'folder_' + Date.now();
        }
        
        folder.createdAt = folder.createdAt || new Date().toISOString();
        folder.updatedAt = new Date().toISOString();
        
        await saveToIndexedDB('folders', folder);
        return folder.id;
      } catch (error) {
        console.error('Fehler beim Speichern des Ordners:', error);
        throw error;
      }
    }
    
    // Liste speichern
    async function saveListToDB(list) {
      try {
        if (!list.id) {
          list.id = 'list_' + Date.now();
        }
        
        list.createdAt = list.createdAt || new Date().toISOString();
        list.updatedAt = new Date().toISOString();
        
        await saveToIndexedDB('lists', list);
        return list.id;
      } catch (error) {
        console.error('Fehler beim Speichern der Liste:', error);
        throw error;
      }
    }
    
    // Alle Listen laden
    async function loadUserLists() {
      try {
        const lists = await getAllFromIndexedDB('lists');
        
        // NEU: Migration für bestehende Listen
        let hasUpdates = false;
        lists.forEach(list => {
          // Füge observationMode hinzu falls nicht vorhanden
          if (!list.observationMode) {
            list.observationMode = 'all'; // Standardwert
            hasUpdates = true;
          }
          // Füge timeRange hinzu falls nicht vorhanden
          if (!list.timeRange) {
            list.timeRange = { from: null, to: null };
            hasUpdates = true;
          }
        });
        
        // Speichere aktualisierte Listen zurück
        if (hasUpdates) {
          for (const list of lists) {
            await saveListToDB(list);
          }
          console.log('Listen wurden aktualisiert (Beobachtungsmodus & Zeitraum)');
        }
        
        userLists = lists;
        return lists;
      } catch (error) {
        console.error('Fehler beim Laden der Listen:', error);
        return [];
      }
    }
    
    // ---------- NEUE FUNKTIONEN: ORDNERAUSWAHL ----------
    
    // Ordnerauswahl initialisieren
    async function initFolderSelect() {
      const folderSelect = document.getElementById('folderSelect');
      if (!folderSelect) return;
      
      try {
        const folders = await getAllFromIndexedDB('folders');
        folderSelect.innerHTML = '<option value="">Ordner wählen...</option>';
        
        if (folders.length === 0) {
          // Erstelle Standard-Ordner falls keine vorhanden
          const defaultFolder = {
            id: 'folder_default',
            name: 'Standard-Ordner',
            color: colorPalette[0],
            createdAt: new Date().toISOString()
          };
          await saveFolderToDB(defaultFolder);
          folders.push(defaultFolder);
        }
        
        folders.forEach(folder => {
          const option = document.createElement('option');
          option.value = folder.id;
          option.textContent = folder.name;
          option.style.color = folder.color;
          folderSelect.appendChild(option);
        });
        
        // Standardmäßig den ersten Ordner auswählen
        if (folders.length > 0) {
          folderSelect.value = folders[0].id;
        }
        
        // Ordner-Indikator aktualisieren
        updateSelectedFolderInfo();
        
        console.log('Ordnerauswahl initialisiert:', folders.length, 'Ordner');
      } catch (error) {
        console.error('Fehler beim Initialisieren der Ordnerauswahl:', error);
      }
    }
    
    // Ausgewählten Ordner-Info aktualisieren
    function updateSelectedFolderInfo() {
      const folderSelect = document.getElementById('folderSelect');
      if (!folderSelect) return;
      
      const selectedOption = folderSelect.options[folderSelect.selectedIndex];
      const indicator = document.getElementById('folderIndicator');
      
      if (selectedOption && selectedOption.value) {
        // Extrahiere Farbe aus dem style-Attribut oder verwende Standard
        const color = selectedOption.style.color || colorPalette[0];
        indicator.style.background = color;
        indicator.title = `Ordner: ${selectedOption.textContent}`;
        indicator.style.display = 'inline-block';
      } else {
        indicator.style.display = 'none';
      }
    }
    
    // Neuen Ordner aus Eingabe erstellen
    function createNewFolderFromInput() {
      // Farbe-Picker füllen
      const colorPicker = document.getElementById('folderColorPicker');
      colorPicker.innerHTML = '';
      
      colorPalette.forEach(color => {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'color-option';
        colorDiv.style.background = color;
        colorDiv.style.width = '32px';
        colorDiv.style.height = '32px';
        colorDiv.style.borderRadius = '8px';
        colorDiv.style.cursor = 'pointer';
        colorDiv.style.border = color === colorPalette[0] ? '2px solid white' : 'none';
        colorDiv.dataset.color = color;
        
        colorDiv.addEventListener('click', function() {
          document.querySelectorAll('#folderColorPicker .color-option').forEach(o => {
            o.style.border = 'none';
          });
          this.style.border = '2px solid white';
          window.selectedFolderColor = color;
        });
        
        colorPicker.appendChild(colorDiv);
      });
      
      window.selectedFolderColor = colorPalette[0];
      
      // Modal anzeigen
      document.getElementById('newFolderName').value = '';
      document.getElementById('newFolderModal').style.display = 'flex';
    }
    
    // Neuen Ordner speichern
    async function saveNewFolderFromInput() {
      const folderName = document.getElementById('newFolderName').value.trim();
      
      if (!folderName) {
        showNotification('Bitte geben Sie einen Ordnernamen ein!', 3000);
        return;
      }
      
      try {
        const newFolder = {
          id: 'folder_' + Date.now(),
          name: folderName,
          color: window.selectedFolderColor || colorPalette[0],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        await saveFolderToDB(newFolder);
        
        // Ordnerauswahl aktualisieren
        await initFolderSelect();
        
        // Neuen Ordner auswählen
        const folderSelect = document.getElementById('folderSelect');
        if (folderSelect) {
          folderSelect.value = newFolder.id;
          updateSelectedFolderInfo();
        }
        
        closeNewFolderModal();
        showNotification(`Ordner "${folderName}" erstellt!`, 3000);
        
      } catch (error) {
        console.error('Fehler beim Erstellen des Ordners:', error);
        showNotification('Fehler beim Erstellen des Ordners', 3000);
      }
    }
    
    // Modal schließen
    function closeNewFolderModal() {
      document.getElementById('newFolderModal').style.display = 'none';
    }
    
    // Schnellerstellen eines Ordners (Alternative ohne Modal)
    async function quickCreateFolder() {
      const folderName = prompt('Name des neuen Ordners:');
      if (!folderName) return;
      
      try {
        // Wähle nächste Farbe in der Palette
        const folders = await getAllFromIndexedDB('folders');
        const nextColorIndex = folders.length % colorPalette.length;
        
        const newFolder = {
          id: 'folder_' + Date.now(),
          name: folderName,
          color: colorPalette[nextColorIndex],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        await saveFolderToDB(newFolder);
        await initFolderSelect();
        
        // Neuen Ordner auswählen
        const folderSelect = document.getElementById('folderSelect');
        if (folderSelect) {
          folderSelect.value = newFolder.id;
          updateSelectedFolderInfo();
        }
        
        showNotification(`Ordner "${folderName}" erstellt und ausgewählt!`, 3000);
      } catch (error) {
        console.error('Fehler beim schnellen Erstellen des Ordners:', error);
        showNotification('Fehler beim Erstellen des Ordners', 3000);
      }
    }
    
    // ---------- NEUE FUNKTIONEN FÜR KOORDINATEN-MANAGEMENT ----------
    
    // Koordinaten-Anzeige aktualisieren
    function updateMapCoordinatesDisplay() {
      const lat = document.getElementById('tempLat').value;
      const lng = document.getElementById('tempLng').value;
      const coordDisplay = document.getElementById('coordDisplay');
      const coordText = document.getElementById('coordText');
      
      if (lat && lng) {
        coordText.textContent = `Koordinaten gesetzt: ${lat}, ${lng}`;
        coordDisplay.style.display = 'block';
      } else {
        coordDisplay.style.display = 'none';
      }
    }
    
    // Koordinaten löschen
    function clearMapCoordinates() {
      document.getElementById('tempLat').value = '';
      document.getElementById('tempLng').value = '';
      updateMapCoordinatesDisplay();
      showNotification('Koordinaten gelöscht', 2000);
    }
    
    // ---------- Modifizierte saveNewObservation Funktion mit Ordnerauswahl ----------
    async function saveNewObservation() {
      const species = document.getElementById('birdSpeciesInput').value;
      const date = document.getElementById('obsDate').value;
      const time = document.getElementById('obsTime').value;
      const count = document.getElementById('obsCount').value;
      const behavior = document.getElementById('obsBehavior').value;
      const weather = document.getElementById('obsWeather').value;
      const photoData = document.getElementById('obsPhotoData')?.value || '';
      const folderSelect = document.getElementById('folderSelect');
      const selectedFolderId = folderSelect ? folderSelect.value : '';
      
      // Seltenheits-Regler auslesen
      const raritySlider = document.getElementById('inputRarity');
      const rarityValue = raritySlider ? raritySlider.value : '0';
      let manualRarity = null;
      if (rarityValue === '1') {
        manualRarity = 'Selten';
      } else if (rarityValue === '2') {
        manualRarity = 'Sehr selten';
      } else if (rarityValue === '3') {
        manualRarity = 'Escape';
      }
      
      // NEU: Koordinaten aus versteckten Inputs holen
      const lat = document.getElementById('tempLat').value;
      const lng = document.getElementById('tempLng').value;
      
      // NEU: Validiere Foto-Größe
      if (photoData && photoData.length > 0) {
        const sizeInMB = photoData.length / (1024 * 1024);
        if (sizeInMB > 9) {
          showNotification('⚠️ Foto ist zu groß (' + sizeInMB.toFixed(1) + ' MB)! Maximal 9 MB erlaubt. Bitte komprimiere das Foto weiter.', 5000);
          return;
        }
        console.log('📸 Foto-Größe OK: ' + sizeInMB.toFixed(2) + ' MB');
      }
      
      if (!species || !date) {
        showNotification('Bitte Vogelart und Datum eingeben!', 3000);
        return;
      }
      
      // NEU: Validierung ob Vogel in Datenbank existiert
      if (!birdDatabase[species]) {
        showNotification('❌ "' + species + '" ist nicht in der Vogeldatenbank! Bitte wähle eine gültige Art.', 4000);
        return;
      }
      
      console.log("💾 ===== SPEICHERE BEOBACHTUNG (Intelligente Eingabe) =====");
      
      // Prüfe ob eine Gruppe ausgewählt ist
      var selectedGroup = window.currentSelectedGroup || "personal";
      var isGroupMode = selectedGroup !== "personal" && selectedGroup !== null && selectedGroup !== undefined;
      
      console.log("   window.currentSelectedGroup:", window.currentSelectedGroup);
      console.log("   Ausgewählte Gruppe:", selectedGroup);
      console.log("   Ist Gruppen-Modus:", isGroupMode);
      console.log("   Firebase Auth vorhanden:", !!window.FBA);
      console.log("   Current User vorhanden:", !!(window.FBA && window.FBA.currentUser));
      
      if(isGroupMode && window.FBA && window.FBA.currentUser){
        // Speichere in Firebase für Gruppe
        var user = window.FBA.currentUser;
        var userName = user.displayName || user.email.split("@")[0];
        
        var observation = {
          bird: species,
          date: date,
          lat: lat || '',
          lng: lng || '',
          time: time,
          count: count || '1',
          behavior: behavior,
          weather: weather,
          photo: photoData || '',  // NEU: Foto hinzugefügt
          rarity: manualRarity || null,  // GEÄNDERT: rarity statt manualRarity
          userId: user.uid,
          userName: userName,
          userEmail: user.email,
          createdAt: firebase.database.ServerValue.TIMESTAMP
        };
        
        console.log("🔵 Speichere in Firebase-Gruppe:", selectedGroup);
        console.log("   Pfad:", "groups/" + selectedGroup + "/observations");
        console.log("   Beobachtung:", JSON.stringify(observation, null, 2));
        
        try{
          // NEU: Entferne undefined Werte für Firebase
          const cleanedObservation = removeUndefinedFields(observation);
          var ref = await window.FBD.ref("groups/" + selectedGroup + "/observations").push(cleanedObservation);
          console.log("✅ In Firebase gespeichert! Key:", ref.key);
          
          // NEU: Vergebe XP für neue Beobachtung
          await awardXPForNewObservation();
          
          // Eingabefelder zurücksetzen
          resetInputFields();
          
          showNotification(`✅ "${species}" in Gruppe gespeichert!`, 3000);
          
          // Aktualisiere Challenge falls auf der Seite
          if (document.getElementById('compareRarity2026View') && 
              document.getElementById('compareRarity2026View').style.display !== 'none') {
            console.log('🔄 Challenge wird aktualisiert...');
            setTimeout(() => renderRarityChallenge2026(), 1000);
          }
          
          return;
        }catch(e){
          console.error("❌ Firebase Fehler:", e);
          console.log("   Error Code:", e.code);
          console.log("   Error Message:", e.message);
          alert("❌ Fehler beim Speichern in Firebase:\n\n" + e.message + "\n\nFällt zurück auf lokale Speicherung.");
          // Falle durch zu lokaler Speicherung
        }
      } else {
        console.log("💾 Speichere lokal (persönlicher Modus)");
      }
      
      // LOKALE SPEICHERUNG (Original-Code)
      if (!selectedFolderId) {
        showNotification('Bitte wählen Sie einen Ordner aus!', 3000);
        return;
      }
      
      try {
        // Lade den ausgewählten Ordner
        const folders = await getAllFromIndexedDB('folders');
        const selectedFolder = folders.find(f => f.id === selectedFolderId);
        
        if (!selectedFolder) {
          showNotification('Ausgewählter Ordner nicht gefunden!', 3000);
          return;
        }
        
        // Erstelle neue Beobachtung
        const newObservation = {
          id: 'obs_' + Date.now(),
          bird: species,
          date: date,
          lat: lat,
          lng: lng,
          folderId: selectedFolder.id,
          folderName: selectedFolder.name,
          folderColor: selectedFolder.color,
          time: time,
          count: count || '1',
          behavior: behavior,
          weather: weather,
          photo: photoData,
          manualRarity: manualRarity || null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        // In IndexedDB speichern
        await saveNewObservationToDB(newObservation);
        
        // NEU: Vergebe XP für neue Beobachtung
        await awardXPForNewObservation();
        
        // UI aktualisieren
        await loadData();
        
        // NEU: Synchronisiere geteilte Listen
        await syncSharedListsAfterNewObservation();
        
        // Eingabefelder zurücksetzen
        resetInputFields();
        
        // Standard-Ordner wieder auswählen (ersten Ordner)
        if (folderSelect && folders.length > 0) {
          folderSelect.value = folders[0].id;
          updateSelectedFolderInfo();
        }
        
        showNotification(`Beobachtung "${species}" im Ordner "${selectedFolder.name}" gespeichert!`, 3000);
        
      } catch (error) {
        console.error('Fehler beim Speichern:', error);
        showNotification('Fehler beim Speichern: ' + error.message, 5000);
      }
    }
    
    // ---------- Modifizierte setMapPointForNew Funktion ----------
    function setMapPointForNew() {
      const species = document.getElementById('birdSpeciesInput').value;
      const date = document.getElementById('obsDate').value;
      const time = document.getElementById('obsTime').value;
      const count = document.getElementById('obsCount').value;
      const behavior = document.getElementById('obsBehavior').value;
      const weather = document.getElementById('obsWeather').value;
      const folderSelect = document.getElementById('folderSelect');
      const selectedFolderId = folderSelect ? folderSelect.value : '';
      
      if (!species || !date) {
        showNotification('Bitte Vogelart und Datum eingeben!', 3000);
        return;
      }
      
      // NEU: Validierung ob Vogel in Datenbank existiert
      if (!birdDatabase[species]) {
        showNotification('❌ "' + species + '" ist nicht in der Vogeldatenbank! Bitte wähle eine gültige Art.', 4000);
        return;
      }
      
      if (!selectedFolderId) {
        showNotification('Bitte wählen Sie einen Ordner aus!', 3000);
        return;
      }
      
      // Temporäre Daten speichern mit Ordner-ID
      tempObservationData = {
        species: species,
        date: date,
        time: time,
        count: count,
        behavior: behavior,
        weather: weather,
        folderId: selectedFolderId
      };
      
      showNotification('Klicke auf die Karte, um den Standort für ' + species + ' festzulegen. Klicke dann auf "Beobachtung speichern".');
      document.querySelector('.nav button[data-page="karte"]').click();
    }
    
    // ---------- POLYGON-FUNKTIONALITÄT ----------
    
    // Funktion zum Starten des Polygon-Zeichnens für eine Liste
    function startDrawingPolygonForList() {
      // Speichere den aktuellen Listen-Status
      currentPolygonForList = {
        name: document.getElementById('listName').value,
        description: document.getElementById('listDescription').value,
        tags: [...listTags],
        color: selectedListColor
      };
      
      // Öffne das Polygon-Zeichen-Modal
      document.getElementById('polygonDrawingModal').style.display = 'flex';
      
      // Initialisiere die Karte für das Polygon-Zeichnen
      setTimeout(() => {
        initPolygonMap();
      }, 100);
    }
    
    // Karte für Polygon-Zeichnen initialisieren
    function initPolygonMap() {
      const mapContainer = document.getElementById('polygonMap');
      
      if (polygonMap) {
        polygonMap.remove();
      }
      
      // Standard-View auf Deutschland
      polygonMap = L.map('polygonMap').setView([51.2, 10.4], 6);
      
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
      }).addTo(polygonMap);
      
      // Event-Listener für Kartenklicks
      polygonMap.on('click', function(e) {
        if (!polygonDrawingMode) return;
        
        addPolygonPoint(e.latlng.lat, e.latlng.lng);
      });
      
      // Starte den Zeichenmodus
      polygonDrawingMode = true;
      currentPolygonPoints = [];
      updateDrawingStatus();
      
      // Falls bereits ein Polygon existiert, lade es
      const existingPolygon = document.getElementById('polygonData').value;
      if (existingPolygon) {
        try {
          const points = JSON.parse(existingPolygon);
          if (Array.isArray(points) && points.length >= 3) {
            currentPolygonPoints = points;
            drawPolygonOnMap();
            updateDrawingStatus();
          }
        } catch (e) {
          console.error('Fehler beim Laden des Polygons:', e);
        }
      }
    }
    
    // Polygon-Punkt hinzufügen
    function addPolygonPoint(lat, lng) {
      currentPolygonPoints.push([lat, lng]);
      
      // Marker hinzufügen
      const marker = L.marker([lat, lng], {
        draggable: true,
        icon: L.divIcon({
          className: 'polygon-marker',
          html: `<div style="background:${selectedListColor};width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>`,
          iconSize: [16, 16]
        })
      }).addTo(polygonMap);
      
      // Drag-Event für Marker
      marker.on('dragend', function(e) {
        const index = polygonMarkers.indexOf(marker);
        if (index !== -1) {
          const newLatLng = marker.getLatLng();
          currentPolygonPoints[index] = [newLatLng.lat, newLatLng.lng];
          drawPolygonOnMap();
          updateDrawingStatus();
        }
      });
      
      marker.on('click', function(e) {
        // Bei Klick auf Marker: Punkt löschen
        const index = polygonMarkers.indexOf(marker);
        if (index !== -1) {
          currentPolygonPoints.splice(index, 1);
          polygonMap.removeLayer(marker);
          polygonMarkers.splice(index, 1);
          drawPolygonOnMap();
          updateDrawingStatus();
        }
      });
      
      polygonMarkers.push(marker);
      
      // Polygon zeichnen
      drawPolygonOnMap();
      updateDrawingStatus();
    }
    
    // Polygon auf der Karte zeichnen
    function drawPolygonOnMap() {
      // Altes Polygon entfernen
      if (polygonLayer) {
        polygonMap.removeLayer(polygonLayer);
      }
      
      if (currentPolygonPoints.length >= 3) {
        // Polygon schließen (erster Punkt = letzter Punkt)
        const closedPoints = [...currentPolygonPoints];
        if (currentPolygonPoints.length > 0) {
          closedPoints.push(currentPolygonPoints[0]);
        }
        
        polygonLayer = L.polygon(closedPoints, {
          color: selectedListColor,
          weight: 2,
          opacity: 0.8,
          fillColor: selectedListColor,
          fillOpacity: 0.2
        }).addTo(polygonMap);
      }
    }
    
    // Zeichen-Status aktualisieren
    function updateDrawingStatus() {
      const statusElement = document.getElementById('drawingStatus');
      if (statusElement) {
        statusElement.textContent = `● ${currentPolygonPoints.length} Punkte gesetzt (mind. 3 erforderlich)`;
        
        if (currentPolygonPoints.length < 3) {
          statusElement.style.color = 'var(--danger)';
        } else {
          statusElement.style.color = 'var(--success)';
        }
      }
    }
    
    // Polygon-Zeichnen zurücksetzen
    function resetPolygonDrawing() {
      // Marker entfernen
      polygonMarkers.forEach(marker => {
        polygonMap.removeLayer(marker);
      });
      polygonMarkers = [];
      
      // Polygon entfernen
      if (polygonLayer) {
        polygonMap.removeLayer(polygonLayer);
        polygonLayer = null;
      }
      
      // Punkte zurücksetzen
      currentPolygonPoints = [];
      updateDrawingStatus();
    }
    
    // Polygon-Zeichnen abschließen
    function finishPolygonDrawing() {
      if (currentPolygonPoints.length < 3) {
        showNotification('Ein Polygon benötigt mindestens 3 Punkte!', 3000);
        return;
      }
      
      // Polygon-Daten speichern
      document.getElementById('polygonData').value = JSON.stringify(currentPolygonPoints);
      
      // Zurück zum Listen-Modal
      closePolygonDrawing();
      
      // Polygon-Details im Listen-Modal anzeigen
      updatePolygonDisplay();
      
      showNotification(`Polygon mit ${currentPolygonPoints.length} Punkten gespeichert!`, 3000);
    }
    
    // Polygon-Zeichen-Modal schließen
    function closePolygonDrawing() {
      document.getElementById('polygonDrawingModal').style.display = 'none';
      polygonDrawingMode = false;
    }
    
    // Polygon-Display im Listen-Modal aktualisieren
    function updatePolygonDisplay() {
      const polygonData = document.getElementById('polygonData').value;
      const statusElement = document.getElementById('polygonStatus');
      const pointsList = document.getElementById('polygonPointsList');
      const summaryElement = document.getElementById('polygonSummary');
      const drawBtn = document.getElementById('drawPolygonBtn');
      const clearBtn = document.getElementById('clearPolygonBtn');
      const finishBtn = document.getElementById('finishPolygonBtn');
      
      if (polygonData) {
        try {
          const points = JSON.parse(polygonData);
          
          // Status anzeigen
          statusElement.style.display = 'flex';
          document.getElementById('polygonPointCount').textContent = `${points.length} Punkte`;
          
          // Punkte-Liste anzeigen
          pointsList.style.display = 'block';
          pointsList.innerHTML = '';
          
          points.forEach((point, index) => {
            const pointElement = document.createElement('div');
            pointElement.className = 'polygon-point';
            pointElement.innerHTML = `
              <span>Punkt ${index + 1}</span>
              <span class="coords">${point[0].toFixed(6)}, ${point[1].toFixed(6)}</span>
            `;
            pointsList.appendChild(pointElement);
          });
          
          // Zusammenfassung anzeigen
          summaryElement.style.display = 'block';
          
          // Fläche berechnen (vereinfacht)
          const area = calculatePolygonArea(points);
          document.getElementById('polygonArea').textContent = 
            `Gebiet: ~${area.toFixed(2)} km² (${points.length} Punkte)`;
          
          // Buttons anpassen
          drawBtn.textContent = '✏️ Polygon bearbeiten';
          clearBtn.style.display = 'inline-block';
          
        } catch (e) {
          console.error('Fehler beim Parsen des Polygons:', e);
        }
      } else {
        statusElement.style.display = 'none';
        pointsList.style.display = 'none';
        summaryElement.style.display = 'none';
        clearBtn.style.display = 'none';
        drawBtn.textContent = '📐 Polygon zeichnen';
      }
    }
    
    // Polygon löschen
    function clearPolygon() {
      if (confirm('Möchten Sie das Polygon wirklich löschen?')) {
        document.getElementById('polygonData').value = '';
        updatePolygonDisplay();
        showNotification('Polygon gelöscht!', 3000);
      }
    }
    
    // Polygon-Zeichnen beenden (Alternative für Button im Listen-Modal)
    function finishDrawingPolygon() {
      closePolygonDrawing();
    }
    
    // Polygon-Fläche berechnen (vereinfachte Berechnung)
    function calculatePolygonArea(points) {
      if (points.length < 3) return 0;
      
      let area = 0;
      const n = points.length;
      
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += points[i][1] * points[j][0];
        area -= points[i][0] * points[j][1];
      }
      
      area = Math.abs(area) / 2;
      
      // Umrechnung in km² (sehr vereinfacht)
      return area * 111.32 * 111.32; // 1 Grad ≈ 111.32 km
    }
    
    // Prüft ob ein Punkt in einem Polygon liegt (Punkt-in-Polygon Algorithmus)
    function isPointInPolygon(point, polygon) {
      const x = point[0], y = point[1];
      let inside = false;
      
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0], yi = polygon[i][1];
        const xj = polygon[j][0], yj = polygon[j][1];
        
        const intersect = ((yi > y) != (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        
        if (intersect) inside = !inside;
      }
      
      return inside;
    }
    
    // Beobachtungen nach Polygon filtern
    function filterObservationsByPolygon(observations, polygon) {
      if (!polygon || polygon.length < 3) {
        return observations; // Kein Polygon = alle Beobachtungen
      }
      
      return observations.filter(obs => {
        if (!obs.lat || !obs.lng) return false;
        
        try {
          const lat = parseFloat(obs.lat);
          const lng = parseFloat(obs.lng);
          
          if (isNaN(lat) || isNaN(lng)) return false;
          
          return isPointInPolygon([lat, lng], polygon);
        } catch (e) {
          console.error('Fehler beim Filtern nach Polygon:', e);
          return false;
        }
      });
    }
    
    // ---------- MODIFIZIERTE: filterObservationsByList Funktion MIT POLYGON-FILTER UND ERSTBEOBACHTUNGEN ----------
    async function filterObservationsByList(observations, list) {
      if (!list) return observations;
      
      let filtered = [...observations];
      
      // HINWEIS: Wir filtern NICHT nach tickable hier, damit alle Beobachtungen sichtbar bleiben
      // Nur die Artenzählung wird später angepasst
      
      // NEU: Filter nach Zeitraum (timeRange hat Vorrang vor filters.dateFrom/dateTo)
      if (list.timeRange) {
        if (list.timeRange.from) {
          filtered = filtered.filter(obs => obs.date >= list.timeRange.from);
        }
        if (list.timeRange.to) {
          filtered = filtered.filter(obs => obs.date <= list.timeRange.to);
        }
      }
      
      // Filter nach Vogelart
      if (list.filters && list.filters.species && list.filters.species.length > 0) {
        filtered = filtered.filter(obs => 
          list.filters.species.includes(obs.bird)
        );
      }
      
      // Filter nach Datum (alte Filter-Methode, falls timeRange nicht gesetzt)
      if (!list.timeRange && list.filters) {
        if (list.filters.dateFrom) {
          filtered = filtered.filter(obs => obs.date >= list.filters.dateFrom);
        }
        if (list.filters.dateTo) {
          filtered = filtered.filter(obs => obs.date <= list.filters.dateTo);
        }
      }
      
      // Filter nach Zugverhalten (vereinfacht)
      if (list.filters && list.filters.migratory) {
        filtered = filtered.filter(obs => {
          const speciesInfo = birdDatabase[obs.bird];
          return speciesInfo && speciesInfo.migratory && speciesInfo.migratory.includes('Zug');
        });
      }
      
      // NEU: Filter nach Bundesland
      if (list.filters && list.filters.state) {
        // Prüfe ob Geocoding bereits fehlgeschlagen ist
        const corsFailed = sessionStorage.getItem('geocoding_cors_failed');
        if (corsFailed === 'true') {
          console.warn('⚠️ Bundesland-Filter übersprungen (Geocoding nicht verfügbar)');
          // Zeige nur Beobachtungen, die bereits ein Bundesland haben
          filtered = filtered.filter(obs => {
            return obs.state && obs.state.toLowerCase() === list.filters.state.toLowerCase();
          });
        } else {
          // Wir müssen hier für jede Beobachtung das Bundesland ermitteln
          const stateFiltered = [];
          for (const obs of filtered) {
            if (obs.lat && obs.lng) {
              // Prüfe ob bereits gespeichert
              let obsState = obs.state;
              
              // Falls noch nicht gespeichert, hole es vom Server
              if (!obsState) {
                try {
                  obsState = await getStateFromCoordinates(
                    parseFloat(obs.lat),
                    parseFloat(obs.lng)
                  );
                  
                  // Speichere das Bundesland in der Beobachtung für zukünftige Verwendung
                  if (obsState) {
                    obs.state = obsState;
                    await saveToIndexedDB('observations', obs);
                  }
                } catch (error) {
                  console.warn('Fehler beim Ermitteln des Bundeslandes:', error);
                  obsState = null;
                }
              }
              
              // Vergleiche mit Filter (case-insensitive und normalisiert)
              if (obsState && obsState.toLowerCase() === list.filters.state.toLowerCase()) {
                stateFiltered.push(obs);
              }
            }
          }
          filtered = stateFiltered;
        }
      }
      
      // NEU: Filter nach Polygon - KORRIGIERT
      if (list.polygon && Array.isArray(list.polygon) && list.polygon.length >= 3) {
        filtered = filterObservationsByPolygon(filtered, list.polygon);
      }
      
      // NEU: Filter nach Beobachtungsmodus (alle vs. nur Erstbeobachtungen)
      if (list.observationMode === 'first') {
        // Nur Erstbeobachtungen: Gruppiere nach Vogelart und behalte nur die erste (älteste) Beobachtung pro Art
        const firstObservations = new Map();
        
        // Sortiere nach Datum (älteste zuerst)
        const sortedFiltered = filtered.sort((a, b) => {
          const dateA = new Date(a.date || '9999-12-31');
          const dateB = new Date(b.date || '9999-12-31');
          return dateA - dateB;
        });
        
        sortedFiltered.forEach(obs => {
          if (!firstObservations.has(obs.bird)) {
            firstObservations.set(obs.bird, obs);
          }
        });
        
        filtered = Array.from(firstObservations.values());
      }
      
      return filtered;
    }
    
    // ---------- Initialisierung ----------
    window.addEventListener('load', async function() {
      try {
        // IndexedDB initialisieren
        await initDatabase();
        
        // Legacy localStorage-Daten migrieren (falls noch nicht geschehen)
        const isMigrated = localStorage.getItem('indexedDB_migrated');
        if (!isMigrated && (localStorage.getItem('vogelData') || localStorage.getItem('userLists'))) {
          showNotification('Migriere Daten zu IndexedDB...', 3000);
          // Lösche alte localStorage Daten nach Migration
          localStorage.removeItem('vogelData');
          localStorage.removeItem('userLists');
          localStorage.setItem('indexedDB_migrated', 'true');
        }
        
        // Weitere Initialisierungen
        initMap();
        initSpeciesDatabase();
        
        // Daten laden
        await loadData();
        await loadUserLists();
        
        // NEU: Ordnerauswahl initialisieren
        await initFolderSelect();
        
        // NEU: Verwaiste Marker bereinigen
        await cleanupOrphanedMarkers();
        
        // NEU: Filter-Arten-Select initialisieren
        await initFilterSpeciesSelect();
        
        // NEU: Filter-Bundesland-Select initialisieren
        await initFilterStateSelect();
        
        // NEU: Bestehende Beobachtungen ohne Bundesland aktualisieren (im Hintergrund)
        // Dies läuft asynchron ohne zu blockieren
        updateObservationsWithMissingStates().then(() => {
          // Nach dem Update die Filter-Auswahl aktualisieren
          initFilterStateSelect();
        });
        
        // NEU: Schnellstatistik initialisieren
        await updateQuickStats();
        
        updateStorageInfo();
        setupEventListeners();
        
        // Keine automatischen Testdaten mehr
        // WICHTIG: Lösche alte Testdaten falls vorhanden
        const hadTestData = await cleanupTestData();
        if (hadTestData) {
          // Wenn Testdaten gelöscht wurden, lade Daten neu
          await loadData();
          updateDashboard();
          updateChart();
        }
        
      } catch (error) {
        console.error('Initialisierungsfehler:', error);
        showNotification('Fehler bei der Initialisierung. Bitte Seite neu laden.', 5000);
      }
    });
    
    // ---------- Modifizierte loadData Funktion ----------
    async function loadData() {
      try {
        // Lade Daten aus IndexedDB
        const folders = await getAllFromIndexedDB('folders');
        const observations = await getAllObservationsWithDetails();
        
        // Gruppiere Beobachtungen nach Ordnern für die UI
        const folderMap = {};
        observations.forEach(obs => {
          if (!folderMap[obs.folderId]) {
            folderMap[obs.folderId] = {
              id: obs.folderId,
              name: obs.folderName || 'Unbekannt',
              color: obs.folderColor || colorPalette[0],
              observations: []
            };
          }
          folderMap[obs.folderId].observations.push(obs);
        });
        
        // UI aktualisieren
        updateUIWithData(folderMap);
        updateMarkersFromData();
        updateChart();
        updateAdvancedStatistics();
        updateDashboard();
        
      } catch (error) {
        console.error('Fehler beim Laden der Daten:', error);
        // Fallback: Leere UI anzeigen
        document.getElementById('folders').innerHTML = '<div class="muted">Keine Daten geladen</div>';
      }
    }
    
    // Hilfsfunktion: UI mit Daten aktualisieren
    function updateUIWithData(folderMap) {
      const foldersDiv = document.getElementById('folders');
      foldersDiv.innerHTML = '';
      
      if (Object.keys(folderMap).length === 0) {
        // Zeige eine freundliche Nachricht statt automatisch einen Ordner zu erstellen
        foldersDiv.innerHTML = `
          <div class="card" style="text-align:center;padding:40px 20px;">
            <div style="font-size:48px;margin-bottom:12px;">🐦</div>
            <h3 style="margin-bottom:8px;">Willkommen bei BirdCount!</h3>
            <p class="muted" style="margin-bottom:20px;">Du hast noch keine Beobachtungen erfasst.</p>
            <button class="btn" onclick="addFolder()">➕ Ersten Ordner erstellen</button>
          </div>
        `;
        return;
      }
      
      Object.values(folderMap).forEach(folderData => {
        const folder = document.createElement('div');
        folder.className = 'folder card';
        folder.dataset.folderId = folderData.id;
        folder.style.marginTop = '12px';
        folder.style.borderLeft = `4px solid ${folderData.color}`;
        
        folder.innerHTML = `
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
            <div class="folder-color-indicator" style="width:16px;height:16px;border-radius:4px;background:${folderData.color};cursor:pointer;" 
                 onclick="changeFolderColor('${folderData.id}')" title="Farbe ändern"></div>
            <h3 contenteditable="true" style="margin:0;flex:1;">${escapeHtml(folderData.name)}</h3>
          </div>
          <div class="maps">
            <div class="mapbox">
              <h4>Beobachtungen</h4>
              <table class="input-table">
                <thead>
                  <tr>
                    <th>Vogelart</th>
                    <th>Datum</th>
                    <th>Koordinaten</th>
                    <th style="width:40px;"></th>
                  </tr>
                </thead>
                <tbody>
                  ${folderData.observations.map(obs => `
                    <tr data-id="${obs.id}">
                      <td><input type="text" class="bird-input" value="${escapeHtml(obs.bird)}" placeholder="Vogelart" 
                           data-time="${obs.time || ''}" 
                           data-count="${obs.count || ''}"
                           data-behavior="${obs.behavior || ''}"
                           data-weather="${obs.weather || ''}"
                           data-photo="${obs.photo || ''}" /></td>
                      <td><input type="date" value="${obs.date || ''}" /></td>
                      <td>
                        <div style="display:flex;gap:4px;align-items:center;">
                          <input type="text" class="lat-input" value="${obs.lat || ''}" placeholder="Lat" style="width:80px;font-family:monospace;" />
                          <input type="text" class="lng-input" value="${obs.lng || ''}" placeholder="Lng" style="width:80px;font-family:monospace;" />
                          <span class="map-point-indicator" onclick="setMapPointForRow(this)" title="Punkt auf Karte setzen">🗺️</span>
                        </div>
                      </td>
                      <td>
                        <div style="display:flex;gap:4px;align-items:center;">
                          <div class="obs-toggle-container">
                            <div class="obs-toggle tickable ${obs.tickable !== false ? 'active' : ''}" 
                                 onclick="toggleTickable('${obs.id}')"
                                 title="${obs.tickable !== false ? 'Tickbar' : 'Nicht tickbar'}">
                              ${obs.tickable !== false ? '✓' : ''}
                            </div>
                            <div class="obs-toggle selffound ${obs.selffound ? 'active' : ''}" 
                                 onclick="toggleSelffound('${obs.id}')"
                                 title="${obs.selffound ? 'Selbst gefunden' : 'Nicht selbst gefunden'}">
                              ${obs.selffound ? '🔴' : ''}
                            </div>
                          </div>
                          <button class="small-btn" onclick="openQuickRarityEditor('${obs.id}', '${escapeHtml(obs.bird)}')" title="Seltenheit ändern" style="padding:4px 8px;background:rgba(124,58,237,0.1);border:1px solid rgba(124,58,237,0.3);">⭐</button>
                          <button class="small-btn" onclick="removeRow(this)" style="background:var(--danger);">🗑️</button>
                        </div>
                      </td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              <div style="margin-top:8px;display:flex;gap:8px;">
                <button class="small-btn" onclick="addRow(this)">➕ Zeile</button>
              </div>
            </div>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;">
            <button class="small-btn" onclick="addMap(this)">➕ Neue Mappe</button>
            <button class="small-btn" onclick="removeFolder(this)">🗑️ Ordner löschen</button>
          </div>`;
        
        foldersDiv.appendChild(folder);
        attachFolderListeners(folder);
        
        // Wende Farbcodierung auf alle Vogel-Inputs an
        folder.querySelectorAll('.bird-input').forEach(input => {
          updateBirdInputColor(input);
          input.addEventListener('input', function() {
            updateBirdInputColor(this);
          });
        });
      });
    }
    
    // ---------- Foto-Komprimierung ----------
    async function compressImage(file, maxWidth = 1920, maxHeight = 1080, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // Berechne neue Dimensionen
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth || height > maxHeight) {
              const ratio = Math.min(maxWidth / width, maxHeight / height);
              width = width * ratio;
              height = height * ratio;
            }
            
            // Erstelle Canvas und zeichne skaliertes Bild
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Konvertiere zu komprimiertem Base64
            const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
            
            // Berechne Kompressions-Rate
            const originalSize = e.target.result.length;
            const compressedSize = compressedDataUrl.length;
            const savedPercent = Math.round((1 - compressedSize / originalSize) * 100);
            
            console.log(`📦 Bild komprimiert: ${Math.round(originalSize/1024)}KB → ${Math.round(compressedSize/1024)}KB (${savedPercent}% gespart)`);
            
            resolve(compressedDataUrl);
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // ---------- Event Listener Setup ----------
    function setupEventListeners() {
      // NEU: Bild-Upload mit Komprimierung
      document.getElementById('obsImage').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (file) {
          try {
            // Zeige Loading-Indikator
            const preview = document.getElementById('imagePreview');
            preview.style.opacity = '0.5';
            
            // Komprimiere Bild
            const compressedDataUrl = await compressImage(file);
            
            // Zeige Vorschau
            preview.src = compressedDataUrl;
            preview.style.display = 'block';
            preview.style.opacity = '1';
            
            // Speichere komprimierte Daten
            let photoDataInput = document.getElementById('obsPhotoData');
            if (!photoDataInput) {
              photoDataInput = document.createElement('input');
              photoDataInput.type = 'hidden';
              photoDataInput.id = 'obsPhotoData';
              document.getElementById('eingabe').appendChild(photoDataInput);
            }
            photoDataInput.value = compressedDataUrl;
            
            showNotification('✅ Foto komprimiert und hinzugefügt', 2000);
          } catch (error) {
            console.error('Fehler bei Bildkomprimierung:', error);
            showNotification('❌ Fehler beim Laden des Fotos', 3000);
          }
        } else {
          // Falls keine Datei ausgewählt wurde, Vorschau ausblenden
          document.getElementById('imagePreview').style.display = 'none';
          document.getElementById('imagePreview').src = '';
          
          // Foto-Daten löschen
          const photoDataInput = document.getElementById('obsPhotoData');
          if (photoDataInput) {
            photoDataInput.value = '';
          }
        }
      });
      
      // Import Datei
      document.getElementById('importFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          importData(file);
        }
      });
      
      // Vogelart-Eingabe
      document.getElementById('birdSpeciesInput').addEventListener('input', function(e) {
        const value = e.target.value;
        if (value.length > 2) {
          showSpeciesInfo(value);
        } else {
          document.getElementById('speciesInfo').style.display = 'none';
        }
      });
      
      // Global Search
      document.getElementById('globalSearch').addEventListener('input', function(e) {
        performGlobalSearch(e.target.value);
      });
      
      // Druck-Button
      document.getElementById('printBtn').addEventListener('click', function() {
        window.print();
      });
      
      // Export All Button
      document.getElementById('exportAllBtn').addEventListener('click', function() {
        exportAllData();
      });
      
      // Chart Controls
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          chartSettings.mode = this.getAttribute('data-preset');
          updateChart();
        });
      });
      
      document.querySelectorAll('.agg-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.agg-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          chartSettings.aggregation = this.getAttribute('data-aggregation');
          updateChart();
        });
      });
      
      // Time Range Slider
      document.getElementById('timeRangeSlider').addEventListener('input', function() {
        chartSettings.customDays = parseInt(this.value);
        chartSettings.mode = 'custom';
        document.getElementById('timeRangeValue').textContent = `${chartSettings.customDays} Tage`;
        updateChart();
      });
      
      // Heatmap Toggle
      document.getElementById('heatmapToggle').addEventListener('click', toggleHeatmap);
      
      // Cluster Toggle
      document.getElementById('clusterToggle').addEventListener('click', toggleCluster);
      
      // NEU: Neuer Ordner Button Event Listener
      document.getElementById('addFolderBtn').addEventListener('click', addFolder);
      
      // NEU: Checkbox für leere Tage
      document.getElementById('emptyDaysCheckbox').addEventListener('change', function() {
        chartSettings.showEmptyDays = this.checked;
        updateChart();
      });
      
      // NEU: Event Listener für "Zurück"-Button, um temporäre Daten zu löschen
      document.getElementById('exitMapView').addEventListener('click', function() {
        tempObservationData = null;
        clearMapCoordinates();
      });
      
      // NEU: Liste erstellen Button
      document.getElementById('createListBtn').addEventListener('click', openCreateListModal);
      
      // NEU: Tag Input Event Listener
      document.getElementById('tagInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && this.value.trim() !== '') {
          addTag(this.value.trim());
          this.value = '';
          e.preventDefault();
        }
      });
      
      // NEU: Filter Checkboxen
      document.querySelectorAll('#filterDetails input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', function() {
          const anyChecked = Array.from(document.querySelectorAll('#filterDetails input[type="checkbox"]'))
            .some(cb => cb.checked);
          document.getElementById('filterDetails').style.display = anyChecked ? 'block' : 'none';
        });
      });
      
      // NEU: Farbauswahl
      document.querySelectorAll('.color-option').forEach(option => {
        option.addEventListener('click', function() {
          document.querySelectorAll('.color-option').forEach(o => o.style.border = 'none');
          this.style.border = '2px solid white';
          selectedListColor = this.dataset.color;
        });
      });
      
      // NEU: Listen Suche
      document.getElementById('listSearch').addEventListener('input', function(e) {
        filterListsBySearch(e.target.value);
      });
      
      // NEU: Ordnerauswahl Event Listener
      const folderSelect = document.getElementById('folderSelect');
      if (folderSelect) {
        folderSelect.addEventListener('change', updateSelectedFolderInfo);
      }
      
      // NEU: Karten-Layer Wechsel
      const mapLayerSelect = document.getElementById('mapLayerSelect');
      if (mapLayerSelect) {
        mapLayerSelect.addEventListener('change', function() {
          changeMapLayer(this.value);
        });
      }
    }
    
    // ---------- Navigation ----------
    // ==================== NAVIGATION (OPTIMIERT MIT EVENT DELEGATION) ====================
    // Navigation wird jetzt mit Event Delegation in der DOMContentLoaded Funktion gehandhabt
    // Siehe oben: "PERFORMANCE-OPTIMIERUNG: Event Delegation für Navigation"
    // Das ist schneller als einzelne Event Listener auf jedem Button
    
    // Falls du die alte Methode bevorzugst, auskommentieren:
    /*
    document.querySelectorAll('.nav button').forEach(btn => {
      btn.addEventListener('click', async () => {
        // Mobile Menü schließen wenn auf Navigation geklickt wird
        if (window.innerWidth <= 700) {
          closeMobileMenu();
        }
        
        // Beim Wechseln der Seite temporäre Daten löschen, wenn wir nicht zur Karte gehen
        const page = btn.getAttribute('data-page');
        if (page !== 'karte') {
          tempObservationData = null;
        }
        
        document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        if (page === 'karte') {
          document.documentElement.classList.add('map-full');
        } else {
          document.documentElement.classList.remove('map-full');
        }

        document.querySelectorAll('main section').forEach(s => s.style.display = 'none');
        const el = document.getElementById(page);
        if (el) el.style.display = 'block';

        if (page === 'diagramme') {
          updateYearSelection();
          await initMemberFilter(); // Mitglieder-Filter initialisieren
          updateChart();
        } else if (page === 'statistiken') {
          updateAdvancedStatistics();
        } else if (page === 'beobachtungen') {
          await renderObservationManager();
        } else if (page === 'eingabe') {
          // NEU: Ordnerauswahl aktualisieren
          await initFolderSelect();
          // NEU: Koordinaten-Anzeige aktualisieren
          updateMapCoordinatesDisplay();
        } else if (page === 'listen') {
          await loadUserLists();
          await renderLists();
        } else if (page === 'arten') {
          loadSpeciesDatabase();
        } else if (page === 'tools') {
          updateSystemInfo();
        } else if (page === 'group-compare') {
          await renderGroupComparison();
        } else if (page === 'home') {
          updateDashboard();
        } else if (page === 'challenges') {
          // Challenge-Daten laden und anzeigen
          await loadChallengeProgress();
          await loadCustomChallenges(); // NEU: Lade benutzerdefinierte Challenges
          updateChallengeDisplay();
          await renderChallenges();
        }

        setTimeout(() => {
          if (window.mapObj && typeof window.mapObj.invalidateSize === 'function') {
            window.mapObj.invalidateSize();
          }
        }, 220);
      });
    });
    */ // Ende des alten Navigation-Codes (auskommentiert)
    
    // ==================== NAVIGATION (ENDE) ====================

    // Mobile sidebar toggle
    const openSidebarBtn = document.getElementById('openSidebar');
    const sidebar = document.querySelector('.sidebar');
    
    if (openSidebarBtn && sidebar) {
      openSidebarBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        sidebar.classList.toggle('mobile-visible');
      });
      
      document.addEventListener('click', (e) => {
        if (!sidebar.contains(e.target) && e.target !== openSidebarBtn) {
          sidebar.classList.remove('mobile-visible');
        }
      });
    }

    if (window.innerWidth <= 700) {
      document.getElementById('mobileNavToggle').style.display = 'flex';
    }

    // Exit full-map view button
    document.getElementById('exitMapView').addEventListener('click', () => {
      document.documentElement.classList.remove('map-full');
      document.querySelectorAll('.nav button').forEach(b => b.classList.remove('active'));
      const homeBtn = document.querySelector('.nav button[data-page="home"]');
      if (homeBtn) homeBtn.classList.add('active');
      document.querySelectorAll('main section').forEach(s => s.style.display = 'none');
      document.getElementById('home').style.display = 'block';
      setTimeout(() => {
        if (window.mapObj) window.mapObj.invalidateSize();
      }, 200);
    });

    // Theme-System mit mehreren Optionen
    function initThemeSystem() {
      const root = document.documentElement;
      const savedTheme = localStorage.getItem('selectedTheme') || 'dark';
      root.setAttribute('data-theme', savedTheme);
      
      // Markiere aktives Theme
      updateActiveThemeButton(savedTheme);
      
      // Event-Listener für alle Theme-Buttons
      document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const theme = btn.getAttribute('data-theme');
          root.setAttribute('data-theme', theme);
          localStorage.setItem('selectedTheme', theme);
          updateActiveThemeButton(theme);
          
          // Update Chart falls vorhanden
          if (typeof chart !== 'undefined' && chart) {
            updateChart();
          }
          
          showNotification(`Theme gewechselt: ${btn.textContent}`, 2000);
        });
      });
    }
    
    function updateActiveThemeButton(theme) {
      document.querySelectorAll('.theme-btn').forEach(btn => {
        if (btn.getAttribute('data-theme') === theme) {
          btn.style.background = 'var(--accent)';
          btn.style.color = 'white';
        } else {
          btn.style.background = 'transparent';
          btn.style.color = 'var(--soft)';
        }
      });
    }
    
    // Initialisiere Theme-System beim Laden
    initThemeSystem();

    // ---------- NEUE FUNKTION: Setzt alle Eingabefelder zurück ----------
    function resetInputFields() {
      // Text-Inputs zurücksetzen
      document.getElementById('birdSpeciesInput').value = '';
      document.getElementById('obsDate').valueAsDate = new Date();
      document.getElementById('obsTime').value = '';
      document.getElementById('obsCount').value = '';
      document.getElementById('obsBehavior').value = '';
      document.getElementById('obsWeather').value = '';
      
      // Seltenheits-Regler zurücksetzen
      resetInputRaritySlider();
      
      // Bildvorschau zurücksetzen
      const imagePreview = document.getElementById('imagePreview');
      imagePreview.style.display = 'none';
      imagePreview.src = '';
      
      // Datei-Input zurücksetzen
      document.getElementById('obsImage').value = '';
      
      // Versteckte Foto-Daten zurücksetzen
      const photoDataInput = document.getElementById('obsPhotoData');
      if (photoDataInput) {
        photoDataInput.value = '';
      }
      
      // Vogelarten-Info ausblenden
      document.getElementById('speciesInfo').style.display = 'none';
      
      // NEU: Koordinaten zurücksetzen
      clearMapCoordinates();
      
      // Referenz auf Foto aus dem Vogelart-Input entfernen
      const birdInput = document.getElementById('birdSpeciesInput');
      if (birdInput) {
        birdInput.removeAttribute('data-photo');
      }
      
      // Temporäre Beobachtungsdaten zurücksetzen
      tempObservationData = null;
      
      console.log('Eingabefelder zurückgesetzt');
    }
    
    // ---------- BEACHTUNGSÜBERSICHT MIT FOTO-LIGHTBOX ----------
    function showAllObservations() {
      const container = document.getElementById('detailsPerDate');
      
      getAllObservationsWithDetails().then(observations => {
        if (observations.length === 0) {
          container.innerHTML = '<div class="muted">Keine Beobachtungen vorhanden</div>';
          return;
        }
        
        // Sortieren nach Datum (neueste zuerst)
        observations.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Filter-Buttons
        const filterHtml = `
          <div class="observation-filters">
            <button class="observation-filter-btn active" onclick="filterObservations('all')">Alle</button>
            <button class="observation-filter-btn" onclick="filterObservations('today')">Heute</button>
            <button class="observation-filter-btn" onclick="filterObservations('week')">Diese Woche</button>
            <button class="observation-filter-btn" onclick="filterObservations('month')">Dieser Monat</button>
            <button class="observation-filter-btn" onclick="filterObservations('year')">Dieses Jahr</button>
          </div>
        `;
        
        let html = `
          <div class="feature-section">
            <h3 style="margin-top:0;">📋 Alle Beobachtungen (${observations.length})</h3>
            ${filterHtml}
            <div class="observations-overview" id="observationsList">
        `;
        
        observations.forEach(obs => {
          const speciesInfo = birdDatabase[obs.bird] || {};
          
          // Foto-Thumbnail falls vorhanden
          const photoThumbnail = obs.photo ? 
            `<img src="${obs.photo}" class="photo-thumbnail" onclick="event.stopPropagation(); openPhotoLightbox('${obs.photo}', '${obs.bird} - ${formatDateForDisplay(obs.date)}')" alt="Foto">` : 
            '';
          
          html += `
            <div class="observation-card" onclick="showObservationDetail('${obs.id}')">
              <div class="observation-header">
                <div style="display:flex;align-items:center;gap:8px;">
                  <div>
                    <div class="observation-species ${getRarityStyle(obs.bird, obs.manualRarity).rarityClass}">${getRarityStyle(obs.bird, obs.manualRarity).rarityIcon}${obs.bird}</div>
                    <div class="observation-scientific">${speciesInfo.scientific || ''}</div>
                  </div>
                  <button class="small-btn" onclick="event.stopPropagation(); openQuickRarityEditor('${obs.id}', '${obs.bird}')" 
                          style="padding:4px 8px;font-size:14px;background:rgba(124,58,237,0.1);border:1px solid rgba(124,58,237,0.3);" 
                          title="Seltenheit ändern">
                    ⭐
                  </button>
                </div>
                <div class="observation-date">${formatDateForDisplay(obs.date)}</div>
              </div>
              
              <div class="observation-meta">
                <div class="observation-meta-item">
                  <span class="icon">🕒</span>
                  <span>${obs.time || '--:--'}</span>
                </div>
                <div class="observation-meta-item">
                  <span class="icon">📍</span>
                  <span>${obs.folderName || 'Unbekannt'}</span>
                </div>
                <div class="observation-meta-item">
                  <span class="icon">🔢</span>
                  <span>${obs.count || '1'}</span>
                </div>
                ${obs.photo ? `
                  <div class="observation-meta-item has-photo" onclick="event.stopPropagation(); openPhotoLightbox('${obs.photo}', '${obs.bird} - ${formatDateForDisplay(obs.date)}')">
                    <span class="icon">📸</span>
                    <span>Foto ansehen</span>
                    ${photoThumbnail}
                  </div>
                ` : ''}
                <div class="observation-meta-item">
                  <div class="obs-toggle-container">
                    <div class="obs-toggle tickable ${obs.tickable !== false ? 'active' : ''}" 
                         onclick="event.stopPropagation(); toggleTickable('${obs.id}')"
                         title="${obs.tickable !== false ? 'Tickbar' : 'Nicht tickbar'}">
                      ${obs.tickable !== false ? '✓' : ''}
                    </div>
                    <div class="obs-toggle selffound ${obs.selffound ? 'active' : ''}" 
                         onclick="event.stopPropagation(); toggleSelffound('${obs.id}')"
                         title="${obs.selffound ? 'Selbst gefunden' : 'Nicht selbst gefunden'}">
                      ${obs.selffound ? '🔴' : ''}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `;
        });
        
        html += `
            </div>
          </div>
        `;
        
        container.innerHTML = html;
      });
    }
    
    function filterObservations(filter) {
      const buttons = document.querySelectorAll('.observation-filter-btn');
      buttons.forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      getAllObservationsWithDetails().then(observations => {
        let filtered = [...observations];
        
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const weekAgo = new Date(today);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const monthAgo = new Date(today);
        monthAgo.setMonth(monthAgo.getMonth() - 1);
        const yearAgo = new Date(today);
        yearAgo.setFullYear(yearAgo.getFullYear() - 1);
        
        switch(filter) {
          case 'today':
            filtered = observations.filter(obs => {
              const obsDate = new Date(obs.date);
              return obsDate >= today;
            });
            break;
          case 'week':
            filtered = observations.filter(obs => {
              const obsDate = new Date(obs.date);
              return obsDate >= weekAgo;
            });
            break;
          case 'month':
            filtered = observations.filter(obs => {
              const obsDate = new Date(obs.date);
              return obsDate >= monthAgo;
            });
            break;
          case 'year':
            filtered = observations.filter(obs => {
              const obsDate = new Date(obs.date);
              return obsDate >= yearAgo;
            });
            break;
          // 'all' bleibt ungefiltert
        }
        
        updateObservationsList(filtered);
      });
    }
    
    function updateObservationsList(observations) {
      const container = document.getElementById('observationsList');
      
      if (observations.length === 0) {
        container.innerHTML = '<div class="muted" style="text-align:center;padding:40px;">Keine Beobachtungen gefunden</div>';
        return;
      }
      
      let html = '';
      
      observations.forEach(obs => {
        const speciesInfo = birdDatabase[obs.bird] || {};
        
        // Foto-Thumbnail falls vorhanden
        const photoThumbnail = obs.photo ? 
          `<img src="${obs.photo}" class="photo-thumbnail" onclick="event.stopPropagation(); openPhotoLightbox('${obs.photo}', '${obs.bird} - ${formatDateForDisplay(obs.date)}')" alt="Foto">` : 
          '';
        
        html += `
          <div class="observation-card" onclick="showObservationDetail('${obs.id}')">
            <div class="observation-header">
              <div style="display:flex;align-items:center;gap:8px;">
                <div>
                  <div class="observation-species ${getRarityStyle(obs.bird, obs.manualRarity).rarityClass}">${getRarityStyle(obs.bird, obs.manualRarity).rarityIcon}${obs.bird}</div>
                  <div class="observation-scientific">${speciesInfo.scientific || ''}</div>
                </div>
                <button class="small-btn" onclick="event.stopPropagation(); openQuickRarityEditor('${obs.id}', '${obs.bird}')" 
                        style="padding:4px 8px;font-size:14px;background:rgba(124,58,237,0.1);border:1px solid rgba(124,58,237,0.3);" 
                        title="Seltenheit ändern">
                  ⭐
                </button>
              </div>
              <div class="observation-date">${formatDateForDisplay(obs.date)}</div>
            </div>
            
            <div class="observation-meta">
              <div class="observation-meta-item">
                <span class="icon">🕒</span>
                <span>${obs.time || '--:--'}</span>
              </div>
              <div class="observation-meta-item">
                <span class="icon">📍</span>
                <span>${obs.folderName || 'Unbekannt'}</span>
              </div>
              <div class="observation-meta-item">
                <span class="icon">🔢</span>
                <span>${obs.count || '1'}</span>
              </div>
              ${obs.photo ? `
                <div class="observation-meta-item has-photo" onclick="event.stopPropagation(); openPhotoLightbox('${obs.photo}', '${obs.bird} - ${formatDateForDisplay(obs.date)}')">
                  <span class="icon">📸</span>
                  <span>Foto ansehen</span>
                  ${photoThumbnail}
                </div>
              ` : ''}
              <div class="observation-meta-item">
                <div class="obs-toggle-container">
                  <div class="obs-toggle tickable ${obs.tickable !== false ? 'active' : ''}" 
                       onclick="event.stopPropagation(); toggleTickable('${obs.id}')"
                       title="${obs.tickable !== false ? 'Tickbar' : 'Nicht tickbar'}">
                    ${obs.tickable !== false ? '✓' : ''}
                  </div>
                  <div class="obs-toggle selffound ${obs.selffound ? 'active' : ''}" 
                       onclick="event.stopPropagation(); toggleSelffound('${obs.id}')"
                       title="${obs.selffound ? 'Selbst gefunden' : 'Nicht selbst gefunden'}">
                    ${obs.selffound ? '🔴' : ''}
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }
    
    // ---------- BEACHTUNGSDETAIL-ANSICHT MIT FOTO-KLICK ----------
    function showObservationDetail(observationId) {
      currentObservationId = observationId;
      
      getAllObservationsWithDetails().then(observations => {
        const observation = observations.find(o => o.id === observationId);
        
        if (!observation) {
          showNotification('Beobachtung nicht gefunden!', 3000);
          return;
        }
        
        const speciesInfo = birdDatabase[observation.bird] || {};
        
        // Modal Titel setzen
        document.getElementById('detailModalTitle').textContent = observation.bird;
        
        // Details setzen
        const currentRarity = observation.manualRarity !== null && observation.manualRarity !== undefined
          ? observation.manualRarity
          : (speciesInfo.status === 'sehr selten' ? 2 : 
             speciesInfo.status === 'selten' ? 1 : 
             speciesInfo.status && speciesInfo.status.toLowerCase() === 'escape' ? 3 : 0);
        
        const detailsHtml = `
          <div class="detail-row">
            <div class="detail-label">Vogelart:</div>
            <div class="detail-value ${getRarityStyle(observation.bird, observation.manualRarity).rarityClass}">${getRarityStyle(observation.bird, observation.manualRarity).rarityIcon}${observation.bird}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Wissenschaftlich:</div>
            <div class="detail-value">${speciesInfo.scientific || '-'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Seltenheit:</div>
            <div class="detail-value" style="display:flex;align-items:center;gap:12px;">
              <input type="range" id="obsRaritySlider" min="0" max="3" value="${currentRarity}" 
                     style="flex:1;accent-color:var(--accent);" 
                     oninput="updateObsRarityLabel(this.value)">
              <span id="obsRarityLabel" style="min-width:100px;font-weight:600;"></span>
              <button class="small-btn" onclick="saveObservationRarity('${observation.id}')" style="background:var(--success);">
                💾 Speichern
              </button>
            </div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Datum:</div>
            <div class="detail-value">${formatDateForDisplay(observation.date)}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Uhrzeit:</div>
            <div class="detail-value">${observation.time || '-'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Anzahl:</div>
            <div class="detail-value">${observation.count || '1'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Verhalten:</div>
            <div class="detail-value">${observation.behavior || '-'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Wetter:</div>
            <div class="detail-value">${observation.weather || '-'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Standort:</div>
            <div class="detail-value">${observation.folderName || '-'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Koordinaten:</div>
            <div class="detail-value">${observation.lat && observation.lng ? 
              `${observation.lat}, ${observation.lng}` : 'Keine Koordinaten'}</div>
          </div>
        `;
        
        document.getElementById('detailModalContent').innerHTML = detailsHtml;
        
        // Rarity Label initial setzen
        updateObsRarityLabel(currentRarity);
        
        // Foto anzeigen/verbergen
        const photoContainer = document.getElementById('detailPhotoContainer');
        const photoElement = document.getElementById('detailPhoto');
        
        if (observation.photo) {
          photoElement.src = observation.photo;
          photoContainer.style.display = 'block';
          
          // Foto klickbar machen für Lightbox
          photoElement.style.cursor = 'pointer';
          photoElement.onclick = () => openPhotoLightbox(observation.photo, `${observation.bird} - ${formatDateForDisplay(observation.date)}`);
        } else {
          photoContainer.style.display = 'none';
        }
        
        // Karte initialisieren/anzeigen
        const mapContainer = document.getElementById('detailMap');
        const noMapContainer = document.getElementById('detailNoMap');
        
        if (observation.lat && observation.lng) {
          mapContainer.style.display = 'block';
          noMapContainer.style.display = 'none';
          
          // Karte initialisieren
          setTimeout(() => {
            initDetailMap(observation.lat, observation.lng, observation.bird);
          }, 100);
        } else {
          mapContainer.style.display = 'none';
          noMapContainer.style.display = 'block';
        }
        
        // Modal anzeigen
        document.getElementById('observationDetailModal').style.display = 'flex';
      });
    }
    
    function initDetailMap(lat, lng, title) {
      // Alte Karte entfernen
      if (detailMap) {
        detailMap.remove();
      }
      
      // Neue Karte erstellen
      detailMap = L.map('detailMap').setView([parseFloat(lat), parseFloat(lng)], 13);
      
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
      }).addTo(detailMap);
      
      // Marker hinzufügen
      L.marker([parseFloat(lat), parseFloat(lng)])
        .addTo(detailMap)
        .bindPopup(`<strong>${escapeHtml(title)}</strong>`)
        .openPopup();
    }
    
    function closeObservationDetail() {
      document.getElementById('observationDetailModal').style.display = 'none';
      currentObservationId = null;
      
      // Karte entfernen
      if (detailMap) {
        detailMap.remove();
        detailMap = null;
      }
    }
    
    // NEU: Bearbeitung aus Detail-Modal öffnen
    function editObservation() {
      if (!currentObservationId) {
        showNotification('Keine Beobachtung ausgewählt', 3000);
        return;
      }
      
      // Schließe Detail-Modal
      closeObservationDetail();
      
      // Öffne Bearbeitungs-Modal
      openEditModal(currentObservationId);
    }
    
    window.editObservation = editObservation;
    
    // Funktion zum Löschen der aktuellen Beobachtung
    async function deleteCurrentObservation() {
      if (!currentObservationId) {
        showNotification('Keine Beobachtung ausgewählt', 3000);
        return;
      }
      
      if (!confirm('Möchtest du diese Beobachtung wirklich löschen?')) {
        return;
      }
      
      try {
        // Prüfe ob im Gruppenmodus
        const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        
        if (isGroupMode) {
          // Firebase-Modus
          const groupId = window.currentSelectedGroup;
          const obsRef = window.FBD.ref(`groups/${groupId}/observations/${currentObservationId}`);
          
          // Lösche aus Firebase
          await obsRef.remove();
          
          showNotification('✅ Beobachtung aus Gruppe gelöscht', 3000);
          
          // Modal schließen
          closeObservationDetail();
          
          // UI aktualisieren - finde aktive Seite und lade sie neu
          setTimeout(() => {
            const activeButton = document.querySelector('.nav button.active');
            if (activeButton) {
              const activePage = activeButton.dataset.page;
              console.log('Aktualisiere aktive Seite:', activePage);
              
              // Triggere Seitenwechsel um neu zu laden
              activeButton.click();
            }
            
            // Aktualisiere Challenge falls auf der Seite
            if (document.getElementById('compareRarity2026View') && 
                document.getElementById('compareRarity2026View').style.display !== 'none') {
              renderRarityChallenge2026();
            }
          }, 500);
          
        } else {
          // Lokaler Modus (IndexedDB)
          
          // 1. Marker von der Karte entfernen, falls vorhanden
          if (window.markers && window.markers.has(currentObservationId)) {
            const marker = window.markers.get(currentObservationId);
            if (marker) {
              // Aus dem Cluster entfernen
              if (window.markerCluster) {
                window.markerCluster.removeLayer(marker);
              }
              // Von der Karte entfernen
              marker.remove();
              // Aus der Map entfernen
              window.markers.delete(currentObservationId);
            }
          }
          
          // 2. Aus IndexedDB löschen
          await deleteObservationFromDB(currentObservationId);
          
          showNotification('✅ Beobachtung gelöscht', 2000);
          
          // Modal schließen
          closeObservationDetail();
          
          // 3. UI aktualisieren - finde aktive Seite und lade sie neu
          setTimeout(() => {
            const activeButton = document.querySelector('.nav button.active');
            if (activeButton) {
              const activePage = activeButton.dataset.page;
              console.log('Aktualisiere aktive Seite:', activePage);
              
              // Triggere Seitenwechsel um neu zu laden
              activeButton.click();
            }
            
            // Zusätzliche Updates
            if (typeof updateMarkerList === 'function') updateMarkerList();
            if (typeof updateDashboard === 'function') updateDashboard();
            if (typeof updateChart === 'function') updateChart();
            if (typeof updateAdvancedStatistics === 'function') updateAdvancedStatistics();
          }, 500);
        }
        
      } catch (error) {
        console.error('Fehler beim Löschen:', error);
        showNotification('❌ Fehler beim Löschen: ' + error.message, 3000);
      }
    }
    
    // Funktion zum Aktualisieren des Seltenheits-Labels im Detail-Modal
    function updateObsRarityLabel(value) {
      const label = document.getElementById('obsRarityLabel');
      const rarityNames = ['Häufig', 'Selten', 'Sehr selten', 'Escape'];
      const colors = ['var(--text)', '#ef4444', '#dc2626', '#3b82f6'];
      
      if (label) {
        label.textContent = rarityNames[value];
        label.style.color = colors[value];
      }
    }
    
    // Funktion zum Speichern der geänderten Seltenheit
    async function saveObservationRarity(observationId) {
      try {
        const slider = document.getElementById('obsRaritySlider');
        const newRarity = parseInt(slider.value);
        
        // Hole die Beobachtung aus der Datenbank
        const observation = await getFromIndexedDB('observations', observationId);
        
        if (!observation) {
          showNotification('❌ Beobachtung nicht gefunden', 3000);
          return;
        }
        
        // Aktualisiere die manualRarity
        observation.manualRarity = newRarity;
        observation.updatedAt = new Date().toISOString();
        
        // Speichere in IndexedDB
        await saveToIndexedDB('observations', observation);
        
        // UI aktualisieren
        await updateDashboard();
        await updateChart();
        await updateAdvancedStatistics();
        await loadData();
        
        // Erfolgsbenachrichtigung
        const rarityNames = ['Häufig', 'Selten', 'Sehr selten', 'Escape'];
        showNotification(`✅ Seltenheit zu "${rarityNames[newRarity]}" geändert!`, 3000);
        
        // Detail-Modal aktualisieren
        showObservationDetail(observationId);
        
      } catch (error) {
        console.error('Fehler beim Speichern der Seltenheit:', error);
        showNotification('❌ Fehler beim Speichern', 3000);
      }
    }
    
    // Schnell-Editor für Seltenheit
    async function openQuickRarityEditor(observationId, birdName) {
      try {
        // Prüfe ob im Gruppenmodus
        const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        let observation = null;
        
        if (isGroupMode) {
          // Lade aus Firebase
          const groupId = window.currentSelectedGroup;
          const snapshot = await window.FBD.ref(`groups/${groupId}/observations/${observationId}`).once('value');
          
          if (!snapshot.exists()) {
            showNotification('❌ Beobachtung nicht gefunden', 3000);
            return;
          }
          
          observation = snapshot.val();
          observation.id = observationId;
        } else {
          // Lade aus IndexedDB
          observation = await getFromIndexedDB('observations', observationId);
          
          if (!observation) {
            showNotification('❌ Beobachtung nicht gefunden', 3000);
            return;
          }
        }
        
        const speciesInfo = birdDatabase[observation.bird] || {};
        
        // Bestimme aktuelle Seltenheit
        let currentRarity = 0;
        if (observation.rarity) {
          // Konvertiere String-Seltenheit zu Number
          const rarityMap = {
            'häufig': 0,
            'selten': 1,
            'sehr selten': 2,
            'escape': 3
          };
          currentRarity = rarityMap[observation.rarity.toLowerCase()] || 0;
        } else if (speciesInfo.status) {
          const rarityMap = {
            'häufig': 0,
            'selten': 1,
            'sehr selten': 2,
            'escape': 3
          };
          currentRarity = rarityMap[speciesInfo.status.toLowerCase()] || 0;
        }
        
        // Erstelle Modal
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.cssText = 'display:flex;position:fixed;inset:0;background:rgba(2,6,23,0.85);backdrop-filter:blur(8px);z-index:10000;align-items:center;justify-content:center;';
        modal.onclick = (e) => {
          if (e.target === modal) modal.remove();
        };
        
        modal.innerHTML = `
          <div class="card" style="max-width:500px;width:90%;padding:24px;" onclick="event.stopPropagation();">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
              <h3 style="margin:0;">⭐ Seltenheit ändern</h3>
              <button class="small-btn" onclick="this.closest('.modal-overlay').remove()" style="background:var(--danger);">✕</button>
            </div>
            
            <div style="margin-bottom:16px;">
              <div style="font-weight:600;margin-bottom:8px;">${escapeHtml(birdName)}</div>
              <div style="font-size:13px;color:var(--muted);">${speciesInfo.scientific || ''}</div>
            </div>
            
            <div style="margin-bottom:20px;">
              <label style="display:block;margin-bottom:8px;font-weight:600;">Seltenheitsgrad:</label>
              <div style="display:flex;align-items:center;gap:12px;">
                <input type="range" id="quickRaritySlider" min="0" max="3" value="${currentRarity}" 
                       style="flex:1;accent-color:var(--accent);" 
                       oninput="updateQuickRarityLabel(this.value)">
                <span id="quickRarityLabel" style="min-width:100px;font-weight:600;"></span>
              </div>
              
              <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:12px;font-size:12px;text-align:center;">
                <div style="color:var(--text);">Häufig</div>
                <div style="color:#ef4444;">Selten</div>
                <div style="color:#dc2626;">Sehr selten</div>
                <div style="color:#3b82f6;">Escape</div>
              </div>
            </div>
            
            <div style="display:flex;gap:8px;">
              <button class="btn ghost" onclick="this.closest('.modal-overlay').remove()" style="flex:1;">Abbrechen</button>
              <button class="btn" onclick="saveQuickRarity('${observationId}')" style="flex:1;background:var(--success);">
                💾 Speichern
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Label initial setzen
        updateQuickRarityLabel(currentRarity);
        
      } catch (error) {
        console.error('Fehler beim Öffnen des Editors:', error);
        showNotification('❌ Fehler beim Öffnen', 3000);
      }
    }
    
    // Label-Update für Quick-Editor
    function updateQuickRarityLabel(value) {
      const label = document.getElementById('quickRarityLabel');
      const rarityNames = ['Häufig', 'Selten', 'Sehr selten', 'Escape'];
      const colors = ['var(--text)', '#ef4444', '#dc2626', '#3b82f6'];
      
      if (label) {
        label.textContent = rarityNames[value];
        label.style.color = colors[value];
      }
    }
    
    // Speichern aus Quick-Editor
    async function saveQuickRarity(observationId) {
      try {
        const slider = document.getElementById('quickRaritySlider');
        const newRarityNum = parseInt(slider.value);
        
        // Konvertiere Number zu String
        const rarityNames = ['häufig', 'selten', 'sehr selten', 'escape'];
        const newRarity = rarityNames[newRarityNum];
        
        // Prüfe ob im Gruppenmodus
        const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        
        if (isGroupMode) {
          // NEU: Prüfe ob Firebase verfügbar ist
          if (!window.FBA || !window.FBD) {
            showNotification('❌ Firebase nicht verfügbar', 2000);
            console.error('Firebase ist nicht initialisiert');
            return;
          }
          
          // NEU: Prüfe Berechtigung
          let user = null;
          try {
            user = window.FBA.currentUser;
          } catch (authError) {
            console.error('Auth-Fehler:', authError);
            showNotification('❌ Nicht angemeldet', 2000);
            return;
          }
          
          if (!user) {
            showNotification('❌ Nicht angemeldet', 2000);
            return;
          }
          
          const groupId = window.currentSelectedGroup;
          const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
          
          // Lade Beobachtung
          const snapshot = await obsRef.once('value');
          const obs = snapshot.val();
          
          if (!obs) {
            showNotification('❌ Beobachtung nicht gefunden', 3000);
            return;
          }
          
          // Prüfe ob Owner oder Admin
          const isOwner = obs.userId === user.uid || obs.createdBy === user.email;
          
          let isAdmin = false;
          try {
            const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${user.uid}`).once('value');
            isAdmin = memberSnapshot.exists() && memberSnapshot.val().role === 'admin';
          } catch (error) {
            console.warn('Konnte Admin-Status nicht prüfen:', error);
          }
          
          if (!isOwner && !isAdmin) {
            showNotification('❌ Keine Berechtigung (nur eigene Beobachtungen oder Admin)', 2000);
            return;
          }
          
          // Speichere in Firebase
          await obsRef.update({
            rarity: newRarity,
            updatedAt: new Date().toISOString()
          });
          
          // Modal schließen
          document.querySelector('.modal-overlay').remove();
          
          // UI aktualisieren
          await renderObservationManager();
          
          // Raritäten-Challenge aktualisieren
          if (typeof renderRarityChallenge2026 === 'function') {
            await renderRarityChallenge2026();
          }
          
          showNotification(`✅ Seltenheit zu "${newRarity}" geändert!`, 3000);
          
        } else {
          // IndexedDB-Modus
          const observation = await getFromIndexedDB('observations', observationId);
          
          if (!observation) {
            showNotification('❌ Beobachtung nicht gefunden', 3000);
            return;
          }
          
          // Aktualisiere die rarity
          observation.rarity = newRarity;
          observation.updatedAt = new Date().toISOString();
          
          // Speichere in IndexedDB
          await saveToIndexedDB('observations', observation);
          
          // Modal schließen
          document.querySelector('.modal-overlay').remove();
          
          // UI aktualisieren
          await updateDashboard();
          await updateChart();
          await updateAdvancedStatistics();
          await loadData();
          showAllObservations();
          
          showNotification(`✅ Seltenheit zu "${newRarity}" geändert!`, 3000);
        }
        
      } catch (error) {
        console.error('Fehler beim Speichern:', error);
        showNotification('❌ Fehler beim Speichern', 3000);
      }
    }
    
    function editObservation() {
      if (!currentObservationId) return;
      
      // Finde die entsprechende Zeile und fokussiere sie
      const row = document.querySelector(`[data-id="${currentObservationId}"]`);
      if (row) {
        // Zur Eingabe-Seite wechseln
        document.querySelector('.nav button[data-page="eingabe"]').click();
        
        // Die Zeile in den Viewport scrollen
        setTimeout(() => {
          row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Visuellen Hinweis geben
          row.style.animation = 'highlightRow 2s';
          
          // Temporäre CSS für Highlight
          if (!document.getElementById('highlightStyle')) {
            const style = document.createElement('style');
            style.id = 'highlightStyle';
            style.textContent = `
              @keyframes highlightRow {
                0% { background-color: rgba(6, 182, 212, 0.1); }
                100% { background-color: transparent; }
              }
            `;
            document.head.appendChild(style);
          }
        }, 300);
      }
      
      closeObservationDetail();
    }
    
    // ---------- MODIFIZIERTE: Listen-Funktionalität MIT POLYGON-ERWEITERUNG ----------
    async function loadUserListsFromDB() {
      try {
        // Lösche alte localStorage Listen sofort (falls vorhanden)
        const oldLocalStorageLists = localStorage.getItem('userLists');
        if (oldLocalStorageLists) {
          try {
            const parsedLists = JSON.parse(oldLocalStorageLists);
            // Prüfe, ob es die alten Demo-Listen sind
            const hasOldLists = parsedLists.some(list => 
              list.id === 'list_1' || list.id === 'list_2' || list.id === 'list_3'
            );
            if (hasOldLists) {
              console.log('Lösche alte Listen aus localStorage');
              localStorage.removeItem('userLists');
            }
          } catch (e) {
            console.error('Fehler beim Parsen alter Listen:', e);
            localStorage.removeItem('userLists');
          }
        }
        
        const savedLists = await getAllFromIndexedDB('lists');
        if (savedLists && savedLists.length > 0) {
          // Entferne alte automatisch erstellte Listen
          const listsToDelete = [];
          const cleanedLists = [];
          
          for (const list of savedLists) {
            // Lösche Listen mit den alten Default-IDs
            if (list.id === 'list_1' || list.id === 'list_2' || list.id === 'list_3') {
              listsToDelete.push(list.id);
            } else {
              cleanedLists.push(list);
            }
          }
          
          // Lösche alle alten Listen aus IndexedDB
          if (listsToDelete.length > 0) {
            console.log('Lösche alte automatische Listen:', listsToDelete);
            for (const listId of listsToDelete) {
              try {
                await deleteFromIndexedDB('lists', listId);
              } catch (err) {
                console.error('Fehler beim Löschen alter Liste:', listId, err);
              }
            }
          }
          
          userLists = cleanedLists;
        } else {
          // Keine automatischen Listen mehr erstellen
          userLists = [];
        }
      } catch (error) {
        console.error('Fehler beim Laden der Listen:', error);
        userLists = [];
      }
    }
    
    function saveUserLists() {
      // Speichere alle Listen in IndexedDB
      userLists.forEach(async (list) => {
        await saveListToDB(list);
      });
    }
    
    async function renderLists() {
      const listsGrid = document.getElementById('listsGrid');
      
      // Lade IMMER die persönlichen Listen aus IndexedDB
      await loadUserLists();
      
      // Prüfe ob wir im Gruppenmodus sind
      const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
      
      if (userLists.length === 0) {
        listsGrid.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">📋</div>
            <div class="empty-state-title">Noch keine Listen</div>
            <div class="empty-state-description">
              ${isGroupMode 
                ? 'Du hast noch keine persönlichen Listen erstellt. Deine persönlichen Listen werden auch in der Gruppenansicht angezeigt.' 
                : 'Erstelle deine erste Liste, um Vogelbeobachtungen zu organisieren und zu analysieren.'}
            </div>
            <button class="btn" onclick="openCreateListModal()">Erste Liste erstellen</button>
          </div>
        `;
        return;
      }
      
      let html = '';
      
      // Info-Banner im Gruppenmodus
      if (isGroupMode) {
        html += `
          <div class="card" style="margin-bottom:16px;background:rgba(124,58,237,0.1);border:1px solid rgba(124,58,237,0.3);">
            <div style="display:flex;align-items:center;gap:12px;">
              <div style="font-size:24px;">👤</div>
              <div>
                <div style="font-weight:600;margin-bottom:4px;">Deine persönlichen Listen</div>
                <div style="font-size:13px;color:var(--muted);">
                  Diese Listen sind nur für dich sichtbar und werden mit deinen persönlichen Beobachtungen berechnet.
                </div>
              </div>
            </div>
          </div>
        `;
      }
      
      // KORREKTUR: Statistiken für alle Listen gleichzeitig laden
      const statsPromises = userLists.map(list => calculateListStats(list));
      const allStats = await Promise.all(statsPromises);
      
      // NEU: Sortiere Listen - Angepinnte zuerst
      const sortedLists = [...userLists].sort((a, b) => {
        // Zuerst nach pinned sortieren
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;
        // Dann nach Erstellungsdatum (neueste zuerst)
        return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
      });
      
      sortedLists.forEach((list, index) => {
        const originalIndex = userLists.findIndex(l => l.id === list.id);
        const stats = allStats[originalIndex];
        
        // Polygon-Indikator
        const hasPolygon = list.polygon && list.polygon.length >= 3;
        // NEU: Erstbeobachtungs-Indikator
        const isFirstOnly = list.observationMode === 'first';
        // NEU: Zeitraum-Indikator
        const hasTimeRange = list.timeRange && (list.timeRange.from || list.timeRange.to);
        // NEU: Bundesland-Indikator
        const hasStateFilter = list.filters && list.filters.state;
        // NEU: Pin-Status
        const isPinned = list.pinned || false;
        
        html += `
          <div class="list-card ${isPinned ? 'pinned-list' : ''}" onclick="openListDetail('${list.id}')" style="cursor:pointer;${isPinned ? 'border: 2px solid var(--accent); box-shadow: 0 8px 24px rgba(6,182,212,0.3);' : ''}">
            ${isPinned ? '<div class="pin-indicator">📌</div>' : ''}
            <div class="list-header">
              <h3 class="list-title">${escapeHtml(list.name)}</h3>
              <span class="list-badge" style="background: ${list.color};">
                ${isGroupMode ? '👤 Persönlich' : (list.type === 'personal' ? 'Persönlich' : 'Geteilt')}
              </span>
            </div>
            
            <div class="list-description">${escapeHtml(list.description || 'Keine Beschreibung')}</div>
            
            <div class="list-tags">
              ${list.tags.map(tag => `<span class="list-tag">${escapeHtml(tag)}</span>`).join('')}
              ${hasPolygon ? `<span class="list-tag" style="background: var(--accent);">🗺️ Polygon</span>` : ''}
              ${isFirstOnly ? `<span class="list-tag" style="background: var(--accent-2);">📊 Erstbeobachtungen</span>` : ''}
              ${hasTimeRange ? `<span class="list-tag" style="background: var(--success);">📅 Zeitraum</span>` : ''}
              ${hasStateFilter ? `<span class="list-tag" style="background: var(--accent);">🏛️ ${escapeHtml(list.filters.state)}</span>` : ''}
            </div>
            
            <div class="list-stats">
              <div class="stat-item">
                <div class="stat-value">${stats.observationCount}</div>
                <div class="stat-label">Beobachtungen</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stats.speciesCount}</div>
                <div class="stat-label">Arten</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stats.daysCount}</div>
                <div class="stat-label">Tage</div>
              </div>
            </div>
            
            <div class="list-actions">
              <button class="small-btn ${isPinned ? 'pinned-btn' : ''}" onclick="event.stopPropagation(); togglePinList('${list.id}')" style="${isPinned ? 'background: var(--accent); color: white;' : ''}" title="${isPinned ? 'Liste loslösen' : 'Liste anpinnen'}">
                ${isPinned ? '📌' : '📍'}
              </button>
              <button class="small-btn" onclick="event.stopPropagation(); openListDetail('${list.id}')" style="flex:1;">📋 Anzeigen</button>
              <button class="small-btn" onclick="event.stopPropagation(); exportList('${list.id}')" style="background: ${list.color};">📤</button>
            </div>
          </div>
        `;
      });
      
      listsGrid.innerHTML = html;
    }
    
    async function calculateListStats(list) {
      try {
        // Verwende IMMER persönliche Beobachtungen für Listen
        const observations = await getPersonalObservationsWithDetails();
        const filteredObs = await filterObservationsByList(observations, list);
        
        // Zähle nur tickbare Arten für speciesCount
        const tickableObs = filteredObs.filter(o => o.tickable !== false);
        
        return {
          observationCount: filteredObs.length, // Alle Beobachtungen
          speciesCount: new Set(tickableObs.map(o => o.bird)).size, // Nur tickbare Arten
          daysCount: new Set(filteredObs.map(o => o.date)).size
        };
      } catch (error) {
        console.error('Fehler beim Berechnen der Listen-Statistiken:', error);
        return { observationCount: 0, speciesCount: 0, daysCount: 0 };
      }
    }
    
    // Initialisiere die Polygon-Anzeige beim Öffnen des Listen-Modals
    function openCreateListModal() {
      document.getElementById('createListModal').style.display = 'flex';
      document.getElementById('listName').value = '';
      document.getElementById('listDescription').value = '';
      listTags = [];
      selectedListColor = '#06b6d4';
      updateTagDisplay();
      
      // Setze Bearbeitungs-Flags zurück (für neue Liste)
      window.isEditingList = false;
      window.editingListId = null;
      
      // Setze Modal-Titel und Button-Text für Erstellungsmodus zurück
      document.getElementById('createListModalTitle').textContent = '📋 Neue Liste erstellen';
      document.getElementById('saveListButton').textContent = 'Liste erstellen';
      
      // Arten-Select füllen
      const speciesSelect = document.getElementById('listSpeciesFilter');
      speciesSelect.innerHTML = '<option value="">Alle Arten</option>';
      Object.keys(birdDatabase).forEach(species => {
        const option = document.createElement('option');
        option.value = species;
        option.textContent = species;
        speciesSelect.appendChild(option);
      });
      
      // Farbauswahl zurücksetzen
      document.querySelectorAll('.color-option').forEach(o => o.style.border = 'none');
      document.querySelector('.color-option[data-color="#06b6d4"]').style.border = '2px solid white';
      
      // NEU: Beobachtungsmodus auf Standard zurücksetzen
      document.getElementById('modeAllObservations').checked = true;
      
      // NEU: Zeitraum zurücksetzen
      document.getElementById('listTimeRangeFrom').value = '';
      document.getElementById('listTimeRangeTo').value = '';
      
      // NEU: Bundesland-Filter zurücksetzen
      document.getElementById('listStateFilter').value = '';
      
      // NEU: Polygon-Anzeige initialisieren
      updatePolygonDisplay();
    }
    
    function closeCreateListModal() {
      document.getElementById('createListModal').style.display = 'none';
      
      // Setze Bearbeitungs-Flags zurück
      window.isEditingList = false;
      window.editingListId = null;
    }
    
    function addTag(tag) {
      if (tag && !listTags.includes(tag)) {
        listTags.push(tag);
        updateTagDisplay();
      }
    }
    
    function removeTag(index) {
      listTags.splice(index, 1);
      updateTagDisplay();
    }
    
    function updateTagDisplay() {
      const container = document.getElementById('tagInputContainer');
      const tagsHtml = listTags.map((tag, index) => `
        <div class="tag-pill">
          ${escapeHtml(tag)}
          <button type="button" class="tag-remove" onclick="removeTag(${index})">×</button>
        </div>
      `).join('');
      
      const input = document.getElementById('tagInput');
      container.innerHTML = tagsHtml + `<input type="text" id="tagInput" placeholder="Tag hinzufügen...">`;
      
      // Event Listener wieder hinzufügen
      const newInput = document.getElementById('tagInput');
      newInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && this.value.trim() !== '') {
          addTag(this.value.trim());
          this.value = '';
          e.preventDefault();
        }
      });
    }
    
    // ---------- MODIFIZIERTE: saveNewList Funktion MIT POLYGON-UNTERSTÜTZUNG ----------
    async function saveNewList() {
      const name = document.getElementById('listName').value.trim();
      const description = document.getElementById('listDescription').value.trim();
      const polygonData = document.getElementById('polygonData').value;
      
      if (!name) {
        showNotification('Bitte gib einen Listenname ein!', 3000);
        return;
      }
      
      // NEU: Beobachtungsmodus auslesen
      const observationMode = document.querySelector('input[name="observationMode"]:checked').value;
      
      // NEU: Zeitraum auslesen
      const timeRangeFrom = document.getElementById('listTimeRangeFrom').value;
      const timeRangeTo = document.getElementById('listTimeRangeTo').value;
      
      // Prüfe ob wir eine bestehende Liste bearbeiten
      const isEditing = window.isEditingList && window.editingListId;
      const listId = isEditing ? window.editingListId : 'list_' + Date.now();
      
      console.log('saveNewList - isEditing:', isEditing, 'listId:', listId);
      
      const listData = {
        id: listId,
        name: name,
        description: description,
        color: selectedListColor,
        tags: [...listTags],
        filters: {},
        polygon: null, // Wird unten gesetzt
        observationMode: observationMode, // NEU: Speichern des Modus
        timeRange: { // NEU: Zeitraum speichern
          from: timeRangeFrom || null,
          to: timeRangeTo || null
        },
        pinned: false, // NEU: Pin-Status
        updatedAt: new Date().toISOString().split('T')[0],
        observationCount: 0,
        type: 'personal'
      };
      
      // Behalte das ursprüngliche Erstellungsdatum bei, falls wir bearbeiten
      if (isEditing) {
        const existingList = userLists.find(l => l.id === listId);
        if (existingList && existingList.createdAt) {
          listData.createdAt = existingList.createdAt;
        } else {
          listData.createdAt = new Date().toISOString().split('T')[0];
        }
        // NEU: Pin-Status beibehalten beim Bearbeiten
        if (existingList && existingList.pinned) {
          listData.pinned = existingList.pinned;
        }
      } else {
        listData.createdAt = new Date().toISOString().split('T')[0];
      }
      
      // KOMPLETT NEU: Polygon-Daten parsen und speichern
      if (polygonData) {
        try {
          const parsedPolygon = JSON.parse(polygonData);
          if (Array.isArray(parsedPolygon) && parsedPolygon.length >= 3) {
            listData.polygon = parsedPolygon;
          }
        } catch (e) {
          console.error('Fehler beim Parsen des Polygons:', e);
        }
      }
      
      // Filter sammeln
      const filters = {};
      
      if (document.getElementById('filterBySpecies').checked) {
        const species = document.getElementById('listSpeciesFilter').value;
        if (species) {
          filters.species = [species];
        }
      }
      
      if (document.getElementById('filterByDate').checked) {
        const dateFrom = document.getElementById('listDateFrom').value;
        const dateTo = document.getElementById('listDateTo').value;
        if (dateFrom) filters.dateFrom = dateFrom;
        if (dateTo) filters.dateTo = dateTo;
      }
      
      // NEU: Bundesland-Filter hinzufügen
      const selectedState = document.getElementById('listStateFilter').value;
      if (selectedState) {
        filters.state = selectedState;
      }
      
      listData.filters = filters;
      
      // Statistiken berechnen
      const stats = await calculateListStats(listData);
      listData.observationCount = stats.observationCount;
      
      // Entweder Liste aktualisieren oder neu hinzufügen
      if (isEditing) {
        // Liste aktualisieren
        const index = userLists.findIndex(l => l.id === listId);
        if (index !== -1) {
          userLists[index] = listData;
        }
        await saveListToDB(listData);
        await renderLists();
        closeCreateListModal();
        
        showNotification(`Liste "${name}" erfolgreich aktualisiert!`, 3000);
      } else {
        // Neue Liste erstellen
        userLists.push(listData);
        await saveListToDB(listData);
        await renderLists();
        closeCreateListModal();
        
        showNotification(`Liste "${name}" erfolgreich erstellt!`, 3000);
      }
    }
    
    // ---------- MODIFIZIERTE: openListDetail Funktion MIT POLYGON-ANZEIGE ----------
    async function openListDetail(listId, viewMode = 'observations') {
      const list = userLists.find(l => l.id === listId);
      if (!list) return;
      
      currentListId = listId;
      window.currentListViewMode = viewMode; // Speichere aktuellen View Mode
      
      document.getElementById('detailListName').textContent = list.name;
      document.getElementById('detailListDescription').textContent = list.description || 'Keine Beschreibung';
      
      // Tags anzeigen
      const tagsContainer = document.getElementById('detailListTags');
      const tagsHtml = list.tags.map(tag => 
        `<span class="list-tag">${escapeHtml(tag)}</span>`
      ).join('');
      
      // NEU: Zeige Beobachtungsmodus als Tag an
      const modeTag = list.observationMode === 'first' 
        ? '<span class="list-tag" style="background: var(--accent-2);">📊 Nur Erstbeobachtungen</span>'
        : '<span class="list-tag" style="background: var(--muted); opacity: 0.6;">📊 Alle Beobachtungen</span>';
      
      // NEU: Zeige Zeitraum als Tag an
      let timeRangeTag = '';
      if (list.timeRange && (list.timeRange.from || list.timeRange.to)) {
        const fromDate = list.timeRange.from ? new Date(list.timeRange.from).toLocaleDateString('de-DE') : '...';
        const toDate = list.timeRange.to ? new Date(list.timeRange.to).toLocaleDateString('de-DE') : '...';
        timeRangeTag = `<span class="list-tag" style="background: var(--success);">📅 ${fromDate} - ${toDate}</span>`;
      }
      
      // NEU: Zeige Bundesland-Filter als Tag an
      let stateTag = '';
      if (list.filters && list.filters.state) {
        stateTag = `<span class="list-tag" style="background: var(--accent);">🏛️ ${escapeHtml(list.filters.state)}</span>`;
      }
      
      tagsContainer.innerHTML = tagsHtml + modeTag + timeRangeTag + stateTag;
      
      // Update View Mode Buttons
      document.querySelectorAll('.list-view-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = 'var(--muted)';
        if (btn.dataset.view === viewMode) {
          btn.classList.add('active');
          btn.style.background = 'var(--accent)';
          btn.style.color = 'white';
        }
      });
      
      // NEU: Bestehende Polygon-Anzeige entfernen (falls vorhanden)
      const existingPolygonDisplay = document.querySelector('.list-observations-table .polygon-display');
      if (existingPolygonDisplay) {
        existingPolygonDisplay.remove();
      }
      
      // NEU: Polygon-Info anzeigen (falls vorhanden) - NUR EINMAL
      if (list.polygon && list.polygon.length >= 3) {
        const polygonInfoContainer = document.createElement('div');
        polygonInfoContainer.className = 'polygon-display';
        polygonInfoContainer.id = 'listPolygonDisplay'; // ID hinzufügen für einfacheres Entfernen
        
        // Fläche berechnen
        const area = calculatePolygonArea(list.polygon);
        
        polygonInfoContainer.innerHTML = `
          <h4 style="margin:0 0 8px 0; display:flex; align-items:center; gap:8px;">
            <span>🗺️</span> 
            <span>Geografischer Filter aktiv</span>
          </h4>
          <div style="margin-bottom:8px;">Polygon mit ${list.polygon.length} Punkten</div>
          <div style="margin-bottom:8px;"><strong>Gebietsgröße:</strong> ${area.toFixed(2)} km²</div>
          <div class="polygon-coordinates">
            ${list.polygon.map((p, i) => `Punkt ${i+1}: ${p[0].toFixed(6)}, ${p[1].toFixed(6)}`).join('\n')}
          </div>
        `;
        
        // Vor dem Beobachtungsbereich einfügen
        const observationsContainer = document.querySelector('.list-observations-table');
        if (observationsContainer) {
          observationsContainer.insertBefore(polygonInfoContainer, observationsContainer.firstChild);
        }
      } else {
        // Falls vorhandene Polygon-Anzeige entfernen
        const existingPolygonDisplay = document.getElementById('listPolygonDisplay');
        if (existingPolygonDisplay) {
          existingPolygonDisplay.remove();
        }
      }
      
      // Beobachtungen laden - verwende IMMER persönliche Beobachtungen für Listen
      const observations = await getPersonalObservationsWithDetails();
      const filteredObs = await filterObservationsByList(observations, list);
      
      const obsContainer = document.getElementById('listObservations');
      if (filteredObs.length === 0) {
        obsContainer.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">🔍</div>
            <div class="empty-state-title">Keine Beobachtungen gefunden</div>
            <div class="empty-state-description">
              ${list.polygon ? 
                'Keine Beobachtungen im definierten Gebiet gefunden.' : 
                'Diese Liste enthält noch keine Beobachtungen oder die Filterkriterien treffen auf keine vorhandenen Daten zu.'}
            </div>
          </div>
        `;
      } else {
        // Rendere je nach View Mode
        if (viewMode === 'simple') {
          renderSimpleListView(filteredObs, list, obsContainer);
        } else if (viewMode === 'lifelist') {
          renderLifeListView(filteredObs, list, obsContainer);
        } else {
          renderObservationsView(filteredObs, list, obsContainer);
        }
      }
      
      document.getElementById('listDetailView').style.display = 'block';
    }
    
    function renderSimpleListView(filteredObs, list, container) {
      // Nur tickbare Arten für die Liste
      const tickableObs = filteredObs.filter(o => o.tickable !== false);
      
      // Erstelle Set mit einzigartigen Arten
      const uniqueSpecies = {};
      tickableObs.forEach(obs => {
        if (!uniqueSpecies[obs.bird]) {
          uniqueSpecies[obs.bird] = {
            bird: obs.bird,
            scientific: (birdDatabase[obs.bird] || {}).scientific,
            rarity: getRarityStyle(obs.bird, obs.manualRarity),
            firstDate: obs.date
          };
        } else {
          // Behalte frühestes Datum
          if (obs.date < uniqueSpecies[obs.bird].firstDate) {
            uniqueSpecies[obs.bird].firstDate = obs.date;
          }
        }
      });
      
      // Sortiere alphabetisch
      const sortedSpecies = Object.values(uniqueSpecies).sort((a, b) => a.bird.localeCompare(b.bird));
      
      let html = `
        <div class="card" style="margin-bottom:20px;">
          <h4>📊 Statistik für diese Liste</h4>
          <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-top:12px;">
            <div style="text-align:center;">
              <div style="font-size:24px;font-weight:700;color:var(--accent);">${filteredObs.length}</div>
              <div style="font-size:12px;color:var(--muted);">Beobachtungen</div>
            </div>
            <div style="text-align:center;">
              <div style="font-size:24px;font-weight:700;color:var(--accent-2);">${sortedSpecies.length}</div>
              <div style="font-size:12px;color:var(--muted);">Arten</div>
            </div>
          </div>
        </div>
        
        <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(min(100%, 300px),1fr));gap:12px;">
      `;
      
      sortedSpecies.forEach((species, index) => {
        html += `
          <div class="card" style="background:rgba(255,255,255,0.02);padding:16px;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
              <div style="font-size:24px;font-weight:700;color:var(--accent);min-width:40px;text-align:center;">
                ${index + 1}
              </div>
              <div style="flex:1;">
                <div class="observation-species ${species.rarity.rarityClass}" style="font-size:16px;font-weight:600;margin-bottom:4px;">
                  ${species.rarity.rarityIcon}${species.bird}
                </div>
                ${species.scientific ? `
                  <div style="font-size:12px;color:var(--muted);font-style:italic;">
                    ${species.scientific}
                  </div>
                ` : ''}
              </div>
            </div>
            <div style="font-size:11px;color:var(--muted);margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.05);">
              Erstbeobachtung: ${formatDateForDisplay(species.firstDate)}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function renderLifeListView(filteredObs, list, container) {
      // Nur tickbare Arten für die Life List
      const tickableObs = filteredObs.filter(o => o.tickable !== false);
      
      // Erstelle Set mit einzigartigen Arten und ihrem ersten Sichtungsdatum
      const uniqueSpecies = {};
      tickableObs.forEach(obs => {
        if (!uniqueSpecies[obs.bird]) {
          uniqueSpecies[obs.bird] = {
            bird: obs.bird,
            scientific: (birdDatabase[obs.bird] || {}).scientific,
            rarity: getRarityStyle(obs.bird, obs.manualRarity),
            firstDate: obs.date,
            firstLocation: obs.folderName || 'Unbekannt'
          };
        } else {
          // Behalte frühestes Datum
          if (obs.date < uniqueSpecies[obs.bird].firstDate) {
            uniqueSpecies[obs.bird].firstDate = obs.date;
            uniqueSpecies[obs.bird].firstLocation = obs.folderName || 'Unbekannt';
          }
        }
      });
      
      // Hole aktuelle Sortierung (Standard: chronologisch)
      const currentSort = window.lifeListSortMode || 'chronological';
      
      // Sortiere je nach Modus
      let sortedSpecies;
      if (currentSort === 'alphabetical') {
        sortedSpecies = Object.values(uniqueSpecies).sort((a, b) => a.bird.localeCompare(b.bird));
      } else {
        // Chronologisch (nach Erstbeobachtungsdatum)
        sortedSpecies = Object.values(uniqueSpecies).sort((a, b) => {
          const dateCompare = a.firstDate.localeCompare(b.firstDate);
          if (dateCompare !== 0) return dateCompare;
          // Bei gleichem Datum: alphabetisch sortieren
          return a.bird.localeCompare(b.bird);
        });
      }
      
      let html = `
        <div class="card" style="margin-bottom:20px;">
          <h4>🔢 Life List - Chronologische Artenliste</h4>
          <p style="font-size:13px;color:var(--muted);margin:8px 0 12px 0;">
            Diese Ansicht zeigt dir die Reihenfolge, in der du die Arten zum ersten Mal beobachtet hast.
          </p>
          
          <!-- Sortier-Buttons -->
          <div style="display:flex;gap:8px;margin-bottom:16px;">
            <button class="small-btn ${currentSort === 'chronological' ? 'active' : ''}" 
                    onclick="setLifeListSort('chronological')"
                    style="background:${currentSort === 'chronological' ? 'var(--accent)' : 'transparent'};
                           border:1px solid ${currentSort === 'chronological' ? 'var(--accent)' : 'rgba(255,255,255,0.08)'};">
              📅 Chronologisch
            </button>
            <button class="small-btn ${currentSort === 'alphabetical' ? 'active' : ''}" 
                    onclick="setLifeListSort('alphabetical')"
                    style="background:${currentSort === 'alphabetical' ? 'var(--accent)' : 'transparent'};
                           border:1px solid ${currentSort === 'alphabetical' ? 'var(--accent)' : 'rgba(255,255,255,0.08)'};">
              🔤 Alphabetisch
            </button>
          </div>
          
          <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;">
            <div style="text-align:center;">
              <div style="font-size:24px;font-weight:700;color:var(--accent);">${filteredObs.length}</div>
              <div style="font-size:12px;color:var(--muted);">Beobachtungen</div>
            </div>
            <div style="text-align:center;">
              <div style="font-size:24px;font-weight:700;color:var(--accent-2);">${sortedSpecies.length}</div>
              <div style="font-size:12px;color:var(--muted);">Arten</div>
            </div>
          </div>
        </div>
        
        <div style="display:flex;flex-direction:column;gap:10px;">
      `;
      
      sortedSpecies.forEach((species, index) => {
        html += `
          <div class="card" style="background:rgba(255,255,255,0.02);padding:14px;display:flex;align-items:center;gap:16px;">
            <div style="font-size:28px;font-weight:700;color:var(--accent);min-width:60px;text-align:center;background:rgba(255,255,255,0.05);padding:10px;border-radius:8px;">
              #${index + 1}
            </div>
            <div style="flex:1;">
              <div class="observation-species ${species.rarity.rarityClass}" style="font-size:17px;font-weight:600;margin-bottom:4px;">
                ${species.rarity.rarityIcon} ${species.bird}
              </div>
              ${species.scientific ? `
                <div style="font-size:13px;color:var(--muted);font-style:italic;margin-bottom:6px;">
                  ${species.scientific}
                </div>
              ` : ''}
              <div style="display:flex;gap:16px;font-size:12px;color:var(--soft);margin-top:6px;">
                <div style="display:flex;align-items:center;gap:6px;">
                  <span>📅</span>
                  <span>${formatDateForDisplay(species.firstDate)}</span>
                </div>
                <div style="display:flex;align-items:center;gap:6px;">
                  <span>📍</span>
                  <span>${species.firstLocation}</span>
                </div>
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function renderObservationsView(filteredObs, list, container) {
        let html = '';
        
        // Statistiken anzeigen - nur tickbare Arten zählen
        const tickableObs = filteredObs.filter(o => o.tickable !== false);
        const stats = {
          total: filteredObs.length, // Alle Beobachtungen
          species: new Set(tickableObs.map(o => o.bird)).size, // Nur tickbare Arten
          area: list.polygon ? calculatePolygonArea(list.polygon).toFixed(2) + ' km²' : 'Kein Gebiet'
        };
        
        html += `
          <div class="card" style="margin-bottom: 20px;">
            <h4>📊 Statistik für diese Liste</h4>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px;">
              <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: 700; color: var(--accent);">${stats.total}</div>
                <div style="font-size: 12px; color: var(--muted);">Beobachtungen</div>
              </div>
              <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: 700; color: var(--accent-2);">${stats.species}</div>
                <div style="font-size: 12px; color: var(--muted);">Arten</div>
              </div>
              <div style="text-align: center;">
                <div style="font-size: 24px; font-weight: 700; color: var(--success);">${stats.area}</div>
                <div style="font-size: 12px; color: var(--muted);">Gebietsgröße</div>
              </div>
            </div>
          </div>
        `;
        
        filteredObs.forEach((obs, index) => {
          const speciesInfo = birdDatabase[obs.bird] || {};
          const rarity = getRarityStyle(obs.bird, obs.manualRarity);
          html += `
            <div class="observation-row">
              <div class="observation-species ${rarity.rarityClass}">
                ${rarity.rarityIcon}${obs.bird}
                <div class="observation-scientific">${speciesInfo.scientific || ''}</div>
              </div>
              <div class="observation-date">${formatDateForDisplay(obs.date)}</div>
              <div class="observation-location">${obs.folderName || 'Unbekannt'}</div>
              <div class="observation-actions">
                <div class="obs-toggle-container" style="margin-right:8px;">
                  <div class="obs-toggle tickable ${obs.tickable !== false ? 'active' : ''}" 
                       onclick="event.stopPropagation(); toggleTickable('${obs.id}')"
                       title="${obs.tickable !== false ? 'Tickbar' : 'Nicht tickbar'}">
                    ${obs.tickable !== false ? '✓' : ''}
                  </div>
                  <div class="obs-toggle selffound ${obs.selffound ? 'active' : ''}" 
                       onclick="event.stopPropagation(); toggleSelffound('${obs.id}')"
                       title="${obs.selffound ? 'Selbst gefunden' : 'Nicht selbst gefunden'}">
                    ${obs.selffound ? '🔴' : ''}
                  </div>
                </div>
                <button class="small-btn" onclick="openQuickRarityEditor('${obs.id}', '${obs.bird}')" title="Seltenheit ändern">⭐</button>
                <button class="small-btn" onclick="showObservationOnMap('${obs.id}')">🗺️</button>
                <button class="small-btn" onclick="showObservationDetail('${obs.id}')">👁️</button>
              </div>
            </div>
          `;
        });
        container.innerHTML = html;
    }
    
    function switchListView(viewMode) {
      if (!currentListId) return;
      openListDetail(currentListId, viewMode);
    }
    
    function setLifeListSort(sortMode) {
      window.lifeListSortMode = sortMode;
      if (!currentListId) return;
      // View neu rendern
      openListDetail(currentListId, 'lifelist');
    }
    
    // Globale Funktionen verfügbar machen
    window.switchListView = switchListView;
    window.setLifeListSort = setLifeListSort;
    
    function closeListDetail() {
      document.getElementById('listDetailView').style.display = 'none';
      currentListId = null;
      
      // NEU: Polygon-Anzeige entfernen
      const existingPolygonDisplay = document.querySelector('.list-observations-table .polygon-display');
      if (existingPolygonDisplay) {
        existingPolygonDisplay.remove();
      }
    }
    
    // Beim Bearbeiten einer Liste: Polygon-Daten laden
    function editCurrentList() {
      if (!currentListId) return;
      
      const list = userLists.find(l => l.id === currentListId);
      if (!list) return;
      
      // Öffne das Bearbeitungs-Modal (setzt zunächst alles zurück)
      openCreateListModal();
      
      // NACH dem Modal-Öffnen: Setze Flag, dass wir eine Liste bearbeiten
      window.isEditingList = true;
      window.editingListId = currentListId;
      
      // Ändere Modal-Titel und Button-Text für Bearbeitungsmodus
      document.getElementById('createListModalTitle').textContent = '✏️ Liste bearbeiten';
      document.getElementById('saveListButton').textContent = 'Änderungen speichern';
      
      // Werte setzen
      document.getElementById('listName').value = list.name;
      document.getElementById('listDescription').value = list.description || '';
      
      // Tags setzen
      listTags = [...(list.tags || [])];
      updateTagDisplay();
      
      // Farbe setzen
      selectedListColor = list.color || '#06b6d4';
      document.querySelectorAll('.color-option').forEach(o => {
        o.style.border = 'none';
        if (o.dataset.color === selectedListColor) {
          o.style.border = '2px solid white';
        }
      });
      
      // Filter setzen
      if (list.filters) {
        if (list.filters.species && list.filters.species.length > 0) {
          document.getElementById('filterBySpecies').checked = true;
          document.getElementById('listSpeciesFilter').value = list.filters.species[0];
        }
        
        if (list.filters.dateFrom) {
          document.getElementById('filterByDate').checked = true;
          document.getElementById('listDateFrom').value = list.filters.dateFrom;
        }
        
        if (list.filters.dateTo) {
          document.getElementById('filterByDate').checked = true;
          document.getElementById('listDateTo').value = list.filters.dateTo;
        }
      }
      
      // Polygon-Daten setzen - WICHTIG!
      if (list.polygon && Array.isArray(list.polygon) && list.polygon.length >= 3) {
        document.getElementById('polygonData').value = JSON.stringify(list.polygon);
        updatePolygonDisplay();
      } else {
        document.getElementById('polygonData').value = '';
        updatePolygonDisplay();
      }
      
      // NEU: Beobachtungsmodus setzen
      const observationMode = list.observationMode || 'all';
      if (observationMode === 'first') {
        document.getElementById('modeFirstObservations').checked = true;
      } else {
        document.getElementById('modeAllObservations').checked = true;
      }
      
      // NEU: Zeitraum setzen
      if (list.timeRange) {
        document.getElementById('listTimeRangeFrom').value = list.timeRange.from || '';
        document.getElementById('listTimeRangeTo').value = list.timeRange.to || '';
      } else {
        document.getElementById('listTimeRangeFrom').value = '';
        document.getElementById('listTimeRangeTo').value = '';
      }
      
      showNotification('Liste zum Bearbeiten geladen', 2000);
    }
    
    async function exportCurrentList() {
      if (!currentListId) return;
      
      const list = userLists.find(l => l.id === currentListId);
      if (!list) return;
      
      try {
        // Verwende IMMER persönliche Beobachtungen für Listen
        const observations = await getPersonalObservationsWithDetails();
        const filteredObs = await filterObservationsByList(observations, list);
        
        const exportData = {
          list: list,
          observations: filteredObs,
          exportDate: new Date().toISOString(),
          totalCount: filteredObs.length
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `birdcount_list_${list.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showNotification(`Liste "${list.name}" erfolgreich exportiert!`, 3000);
      } catch (error) {
        console.error('Fehler beim Export:', error);
        showNotification('Export fehlgeschlagen!', 3000);
      }
    }
    
    async function deleteCurrentList() {
      if (!currentListId) return;
      
      if (confirm('Möchten Sie diese Liste wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.')) {
        try {
          // Aus IndexedDB löschen
          await deleteFromIndexedDB('lists', currentListId);
          
          // Aus lokaler Liste entfernen
          userLists = userLists.filter(l => l.id !== currentListId);
          
          await renderLists();
          closeListDetail();
          showNotification('Liste erfolgreich gelöscht!', 3000);
        } catch (error) {
          console.error('Fehler beim Löschen:', error);
          showNotification('Löschen fehlgeschlagen!', 3000);
        }
      }
    }
    
    function exportList(listId) {
      const list = userLists.find(l => l.id === listId);
      if (!list) return;
      
      openListDetail(listId);
      setTimeout(exportCurrentList, 100);
    }
    
    // NEU: Liste anpinnen/loslösen
    async function togglePinList(listId) {
      const list = userLists.find(l => l.id === listId);
      if (!list) return;
      
      // Toggle pinned status
      list.pinned = !list.pinned;
      
      // In IndexedDB speichern
      await saveListToDB(list);
      
      // Liste neu rendern
      await renderLists();
      
      // Benachrichtigung anzeigen
      if (list.pinned) {
        showNotification(`📌 "${list.name}" wurde angepinnt`, 2000);
      } else {
        showNotification(`📍 "${list.name}" wurde losgelöst`, 2000);
      }
    }
    
    function filterLists(category) {
      showNotification(`Filter: ${category}`, 2000);
    }
    
    async function filterListsBySearch(query) {
      if (!query) {
        await renderLists();
        return;
      }
      
      const filteredLists = userLists.filter(list => 
        list.name.toLowerCase().includes(query.toLowerCase()) ||
        list.description.toLowerCase().includes(query.toLowerCase()) ||
        list.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()))
      );
      
      const listsGrid = document.getElementById('listsGrid');
      
      if (filteredLists.length === 0) {
        listsGrid.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">🔍</div>
            <div class="empty-state-title">Keine Listen gefunden</div>
            <div class="empty-state-description">Keine Listen entsprechen deiner Suche nach "${query}".</div>
          </div>
        `;
        return;
      }
      
      let html = '';
      
      // KORREKTUR: Stats für alle Listen gleichzeitig laden
      const statsPromises = filteredLists.map(list => calculateListStats(list));
      const allStats = await Promise.all(statsPromises);
      
      // NEU: Sortiere auch gefilterte Listen - Angepinnte zuerst
      const sortedFilteredLists = [...filteredLists].sort((a, b) => {
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;
        return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
      });
      
      sortedFilteredLists.forEach((list, index) => {
        const originalIndex = filteredLists.findIndex(l => l.id === list.id);
        const stats = allStats[originalIndex];
        
        // Polygon-Indikator
        const hasPolygon = list.polygon && list.polygon.length >= 3;
        // NEU: Erstbeobachtungs-Indikator
        const isFirstOnly = list.observationMode === 'first';
        // NEU: Zeitraum-Indikator
        const hasTimeRange = list.timeRange && (list.timeRange.from || list.timeRange.to);
        // NEU: Pin-Status
        const isPinned = list.pinned || false;
        
        html += `
          <div class="list-card ${isPinned ? 'pinned-list' : ''}" onclick="openListDetail('${list.id}')" style="cursor:pointer;${isPinned ? 'border: 2px solid var(--accent); box-shadow: 0 8px 24px rgba(6,182,212,0.3);' : ''}">
            ${isPinned ? '<div class="pin-indicator">📌</div>' : ''}
            <div class="list-header">
              <h3 class="list-title">${escapeHtml(list.name)}</h3>
              <span class="list-badge" style="background: ${list.color};">${list.type === 'personal' ? 'Persönlich' : 'Geteilt'}</span>
            </div>
            
            <div class="list-description">${escapeHtml(list.description || 'Keine Beschreibung')}</div>
            
            <div class="list-tags">
              ${list.tags.map(tag => `<span class="list-tag">${escapeHtml(tag)}</span>`).join('')}
              ${hasPolygon ? `<span class="list-tag" style="background: var(--accent);">🗺️ Polygon</span>` : ''}
              ${isFirstOnly ? `<span class="list-tag" style="background: var(--accent-2);">📊 Erstbeobachtungen</span>` : ''}
              ${hasTimeRange ? `<span class="list-tag" style="background: var(--success);">📅 Zeitraum</span>` : ''}
            </div>
            
            <div class="list-stats">
              <div class="stat-item">
                <div class="stat-value">${stats.observationCount}</div>
                <div class="stat-label">Beobachtungen</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stats.speciesCount}</div>
                <div class="stat-label">Arten</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stats.daysCount}</div>
                <div class="stat-label">Tage</div>
              </div>
            </div>
            
            <div class="list-actions">
              <button class="small-btn ${isPinned ? 'pinned-btn' : ''}" onclick="event.stopPropagation(); togglePinList('${list.id}')" style="${isPinned ? 'background: var(--accent); color: white;' : ''}" title="${isPinned ? 'Liste loslösen' : 'Liste anpinnen'}">
                ${isPinned ? '📌' : '📍'}
              </button>
              <button class="small-btn" onclick="event.stopPropagation(); openListDetail('${list.id}')" style="flex:1;">📋 Anzeigen</button>
              <button class="small-btn" onclick="event.stopPropagation(); exportList('${list.id}')" style="background: ${list.color};">📤</button>
            </div>
          </div>
        `;
      });
      
      listsGrid.innerHTML = html;
    }
    
    // Hilfsfunktion: Beobachtung auf Karte zeigen
    function showObservationOnMap(observationId) {
      getAllObservationsWithDetails().then(observations => {
        const observation = observations.find(o => o.id === observationId);
        
        if (observation && observation.lat && observation.lng) {
          // Zur Karte navigieren
          document.querySelector('.nav button[data-page="karte"]').click();
          
          // Marker setzen
          setTimeout(() => {
            if (window.mapObj) {
              window.mapObj.setView([observation.lat, observation.lng], 15);
              
              // Temporären Marker anzeigen
              const marker = L.marker([observation.lat, observation.lng]).addTo(window.mapObj);
              marker.bindPopup(`<strong>${observation.bird}</strong><br>${observation.date}`).openPopup();
              
              // Marker nach 10 Sekunden entfernen
              setTimeout(() => {
                window.mapObj.removeLayer(marker);
              }, 10000);
            }
          }, 500);
        }
      });
    }
    
    // ---------- Arten-Datenbank ----------
    function initSpeciesDatabase() {
      const datalist = document.getElementById('birdSpeciesList');
      datalist.innerHTML = '';
      
      Object.keys(birdDatabase).forEach(species => {
        const option = document.createElement('option');
        option.value = species;
        datalist.appendChild(option);
      });
    }
    
    function showSpeciesInfo(speciesName) {
      const species = birdDatabase[speciesName];
      if (!species) {
        document.getElementById('speciesInfo').style.display = 'none';
        return;
      }
      
      // Automatisch Seltenheits-Regler anpassen
      const status = species.status || '';
      const raritySlider = document.getElementById('inputRarity');
      const rarityLabel = document.getElementById('inputRarityLabel');
      
      if (raritySlider && rarityLabel) {
        const normalizedStatus = status.toLowerCase();
        
        if (normalizedStatus === 'escape') {
          raritySlider.value = 3;
          rarityLabel.textContent = 'Escape';
          rarityLabel.style.color = '#3b82f6';
        } else if (status === 'sehr selten') {
          raritySlider.value = 2;
          rarityLabel.textContent = 'Sehr selten';
          rarityLabel.style.color = '#dc2626';
        } else if (status === 'selten') {
          raritySlider.value = 1;
          rarityLabel.textContent = 'Selten';
          rarityLabel.style.color = '#ef4444';
        } else {
          raritySlider.value = 0;
          rarityLabel.textContent = 'Häufig';
          rarityLabel.style.color = 'var(--text)';
        }
      }
      
      document.getElementById('speciesInfo').style.display = 'block';
      document.getElementById('speciesName').innerHTML = `
        <strong>${speciesName}</strong> ${species.scientific ? `<small style="color:var(--muted);">(${species.scientific})</small>` : ''}
      `;
      
      // Nur Felder mit Werten anzeigen
      let detailsHtml = '';
      
      if (species.family) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Familie:</div>
            <div>${species.family}</div>
          </div>`;
      }
      
      if (species.size) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Größe:</div>
            <div>${species.size}</div>
          </div>`;
      }
      
      if (species.status) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Status:</div>
            <div>${species.status}</div>
          </div>`;
      }
      
      if (species.redList) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Rote Liste:</div>
            <div>${species.redList}</div>
          </div>`;
      }
      
      if (species.migratory) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Zugverhalten:</div>
            <div>${species.migratory}</div>
          </div>`;
      }
      
      if (species.description) {
        detailsHtml += `
          <div class="species-detail">
            <div class="label">Beschreibung:</div>
            <div>${species.description}</div>
          </div>`;
      }
      
      if (!detailsHtml) {
        detailsHtml = '<div class="muted" style="text-align:center;padding:10px;">Keine Details verfügbar</div>';
      }
      
      document.getElementById('speciesDetails').innerHTML = detailsHtml;
    }
    
    function openSpeciesGuide() {
      const modal = document.getElementById('speciesGuideModal');
      modal.style.display = 'flex';
      
      const content = document.getElementById('speciesGuideContent');
      content.innerHTML = `
        <div style="margin-bottom:16px;">
          <p>Verwende diese Merkmale zur Vogelbestimmung:</p>
        </div>
        
        <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:12px;">
          <div class="card">
            <strong>🔍 Größe</strong>
            <div style="font-size:13px;margin-top:4px;">
              • Sehr klein (9-12 cm)<br>
              • Klein (13-18 cm)<br>
              • Mittel (19-28 cm)<br>
              • Groß (29-45 cm)<br>
              • Sehr groß (46+ cm)
            </div>
          </div>
          
          <div class="card">
            <strong>🎨 Farbe</strong>
            <div style="font-size:13px;margin-top:4px;">
              • Schwarz/Weiß<br>
              • Braun/Tarnfarbe<br>
              • Bunt (mehrere Farben)<br>
              • Rot/Orange<br>
              • Blau/Türkis
            </div>
          </div>
        </div>
      `;
    }

    // ---------- Wetter-Funktionen ----------
    function getCurrentWeather() {
      const conditions = ['sunny', 'cloudy', 'rainy', 'snowy'];
      const randomCondition = conditions[Math.floor(Math.random() * conditions.length)];
      const weather = weatherConditions[randomCondition];
      
      document.getElementById('obsWeather').value = `${weather.icon} ${weather.desc}, ${weather.temp}`;
      
      showNotification('Wetterdaten aktualisiert!', 2000);
    }

    // ---------- Datenverwaltung ----------
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const str = String(text);
      return str.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]);
    }
    
    // Konvertiere E-Mail zu Firebase-sicherem Schlüssel
    // Firebase erlaubt keine . # $ [ ] in Pfaden
    function emailToFirebaseKey(email) {
      if (!email) return '';
      // Ersetze . durch , (Standard Firebase-Konvention)
      return email.replace(/\./g, ',');
    }
    
    // Konvertiere Firebase-Schlüssel zurück zu E-Mail
    function firebaseKeyToEmail(key) {
      if (!key) return '';
      return key.replace(/,/g, '.');
    }
    
    // ---------- Kartenfunktionen ----------
    
    // Erstelle TileLayer basierend auf dem Typ
    function createTileLayer(layerType) {
      let layers = [];
      
      switch(layerType) {
        case 'osm':
          layers.push(L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
          }));
          break;
          
        case 'topo':
          layers.push(L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 17,
            attribution: '© OpenTopoMap'
          }));
          break;
          
        case 'satellite':
          layers.push(L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '© Esri'
          }));
          break;
          
        case 'hybrid':
          // Satellitenbild als Basis
          layers.push(L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '© Esri, OpenStreetMap'
          }));
          // Straßen und Labels darüber
          layers.push(L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            opacity: 0.35, // Transparenz für bessere Lesbarkeit
            className: 'hybrid-labels'
          }));
          break;
          
        default:
          layers.push(L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap'
          }));
      }
      
      // Wenn mehrere Layer, gebe LayerGroup zurück, sonst einzelnen Layer
      return layers.length > 1 ? L.layerGroup(layers) : layers[0];
    }
    
    // Wechsle Karten-Layer
    function changeMapLayer(layerType) {
      if (!window.mapObj) return;
      
      // Entferne aktuellen Layer
      if (currentTileLayer) {
        window.mapObj.removeLayer(currentTileLayer);
      }
      
      // Erstelle und füge neuen Layer hinzu
      currentTileLayer = createTileLayer(layerType);
      currentTileLayer.addTo(window.mapObj);
      
      // Speichere Einstellung
      localStorage.setItem('mapLayer', layerType);
      
      console.log('🗺️ Karten-Layer gewechselt zu:', layerType);
      showNotification('Karten-Ansicht geändert: ' + layerType, 2000);
    }
    
    function initMap() {
      if (window.mapObj) return;
      
      window.mapObj = L.map('map').setView([51.2, 10.4], 6);
      
      // Lade gespeicherte Karten-Layer-Einstellung
      const savedLayer = localStorage.getItem('mapLayer') || 'osm';
      
      // Erstelle den initialen TileLayer basierend auf gespeicherter Einstellung
      currentTileLayer = createTileLayer(savedLayer);
      currentTileLayer.addTo(window.mapObj);
      
      // Setze Select-Wert
      const mapLayerSelect = document.getElementById('mapLayerSelect');
      if (mapLayerSelect) {
        mapLayerSelect.value = savedLayer;
      }
      
      // Marker Cluster
      markerCluster = L.markerClusterGroup();
      window.mapObj.addLayer(markerCluster);
      
      // Drag-Mode Toggle
      document.getElementById('toggleDragMode').addEventListener('click', function() {
        dragMode = !dragMode;
        this.textContent = dragMode ? 'Verschieben: An' : 'Verschieben: Aus';
        
        // NEU: Aktualisiere alle Marker basierend auf dragMode UND markersLocked
        window.markers.forEach((marker, id) => {
          if (marker && marker.dragging) {
            if (dragMode && !markersLocked) {
              marker.dragging.enable();
            } else {
              marker.dragging.disable();
            }
          }
        });
      });
      
      // NEU: Marker Lock/Unlock Toggle
      window.toggleMarkersLock = function() {
        markersLocked = !markersLocked;
        const btn = document.getElementById('toggleMarkersLock');
        const hint = document.getElementById('markerLockHint');
        
        if (markersLocked) {
          btn.textContent = '🔒 Marker gesperrt';
          btn.style.background = 'var(--danger)';
          if (hint) hint.style.display = 'block';
          showNotification('Marker sind jetzt gesperrt', 2000);
        } else {
          btn.textContent = '🔓 Marker entsperrt';
          btn.style.background = 'var(--success)';
          if (hint) hint.style.display = 'none';
          showNotification('Marker können jetzt verschoben werden', 2000);
        }
        
        // Aktualisiere alle existierenden Marker
        window.markers.forEach((marker, id) => {
          if (marker && marker.dragging) {
            if (markersLocked) {
              marker.dragging.disable();
            } else if (dragMode) {
              // Nur aktivieren wenn dragMode auch AN ist
              marker.dragging.enable();
            }
          }
        });
      };

      // Alle Marker löschen - KORRIGIERT
      document.getElementById('clearMarkers').addEventListener('click', async function() {
        if (confirm('Alle Marker löschen? Diese Aktion löscht auch alle zugehörigen Beobachtungen!')) {
          try {
            // Lösche alle Marker von der Karte
            window.markers.forEach(marker => {
              if (marker && marker.remove) marker.remove();
            });
            window.markers.clear();
            
            // Cluster leeren
            if (markerCluster) {
              markerCluster.clearLayers();
            }
            
            // Lösche alle Beobachtungen aus IndexedDB
            const observations = await getAllObservationsWithDetails();
            for (const obs of observations) {
              await deleteObservationFromDB(obs.id);
            }
            
            // Daten neu laden, um die UI zu aktualisieren
            await loadData();
            
            updateMarkerList();
            showNotification('Alle Marker und Beobachtungen gelöscht!', 2000);
          } catch (error) {
            console.error('Fehler beim Löschen aller Marker:', error);
            showNotification('Fehler beim Löschen aller Marker', 3000);
          }
        }
      });
      
      // MODIFIZIERT: Karten-Klick-Event mit Integration in Eingaben
      window.mapObj.on('click', async function(e) {
        if (activeRowForMapClick !== null) {
          // Koordinaten in Tabellenzeile eintragen
          const row = activeRowForMapClick;
          const latInput = row.querySelector('.lat-input');
          const lngInput = row.querySelector('.lng-input');
          
          if (latInput && lngInput) {
            latInput.value = e.latlng.lat.toFixed(6);
            lngInput.value = e.latlng.lng.toFixed(6);
            
            // Daten speichern (erstellt automatisch Marker)
            saveData();
            
            activeRowForMapClick = null;
            showNotification('Punkt auf Karte gesetzt!', 2000);
          }
        } else if (tempObservationData !== null) {
          // MODIFIZIERT: Koordinaten nur in versteckte Inputs speichern, nicht sofort speichern
          document.getElementById('tempLat').value = e.latlng.lat.toFixed(6);
          document.getElementById('tempLng').value = e.latlng.lng.toFixed(6);
          
          // Zurück zur Eingabemaske
          document.querySelector('.nav button[data-page="eingabe"]').click();
          
          // Koordinaten-Anzeige aktualisieren
          updateMapCoordinatesDisplay();
          
          const speciesName = tempObservationData?.species || 'diese Art';
          showNotification(`Koordinaten für ${speciesName} gesetzt. Klicke auf "Beobachtung speichern" zum Speichern.`, 3000);
          
          // Temporäre Daten beibehalten, bis gespeichert wird
        } else {
          // NEU: Direktes Erstellen einer Vogelbeobachtung vom Kartenklick
          showVogelModalForMapClick(e.latlng);
        }
      });

      // Modal Event Handler
      document.getElementById('modalCancel').addEventListener('click', function() {
        document.getElementById('modalBackdrop').style.display = 'none';
        window.tempMarkerCoords = null;
        resetRaritySlider();
        
        // Original-Überschrift und Labels zurücksetzen
        document.getElementById('modalTitle').textContent = "Vogelbeobachtung eingeben";
        document.getElementById('modalLabel1').textContent = "Vogelart *";
        document.getElementById('modalLabel2').textContent = "Beobachtungsdatum";
        document.getElementById('modalName').placeholder = "z.B. Amsel, Rotkehlchen...";
        document.getElementById('modalOk').textContent = "Speichern";
      });

      document.getElementById('modalOk').addEventListener('click', function() {
        const birdName = document.getElementById('modalName').value.trim();
        const date = document.getElementById('modalDate').value;
        const raritySlider = document.getElementById('modalRarity');
        const rarityValue = raritySlider ? raritySlider.value : '0';
        
        // Konvertiere Slider-Wert zu Status-String
        let manualRarity = null;
        if (rarityValue === '1') {
          manualRarity = 'Selten';
        } else if (rarityValue === '2') {
          manualRarity = 'Sehr selten';
        } else if (rarityValue === '3') {
          manualRarity = 'Escape';
        }
        // Bei 0 (häufig) bleibt manualRarity null, dann wird Standard aus DB verwendet
        
        if (!birdName) {
          showNotification('Bitte eine Vogelart eingeben!', 3000);
          return;
        }
        
        // NEU: Validierung ob Vogel in Datenbank existiert
        if (!birdDatabase[birdName]) {
          showNotification('❌ Diese Vogelart ist nicht in der Datenbank! Bitte wähle eine gültige Art aus.', 4000);
          return;
        }
        
        if (!window.tempMarkerCoords) {
          showNotification('Koordinaten fehlen!', 3000);
          return;
        }
        
        // Vogelbeobachtung in die erste verfügbare Tabelle eintragen
        addObservationFromMap(birdName, date, window.tempMarkerCoords.lat, window.tempMarkerCoords.lng, manualRarity);
        
        // Modal verstecken und Regler zurücksetzen
        document.getElementById('modalBackdrop').style.display = 'none';
        resetRaritySlider();
        window.tempMarkerCoords = null;
      });
      
      // Event Listener für automatische Seltenheits-Anpassung im Modal
      document.getElementById('modalName').addEventListener('input', function(e) {
        const birdName = e.target.value.trim();
        const species = birdDatabase[birdName];
        
        if (species) {
          const status = species.status || '';
          const raritySlider = document.getElementById('modalRarity');
          const rarityLabel = document.getElementById('rarityLabel');
          
          if (raritySlider && rarityLabel) {
            const normalizedStatus = status.toLowerCase();
            
            if (normalizedStatus === 'escape') {
              raritySlider.value = 3;
              rarityLabel.textContent = 'Escape';
              rarityLabel.style.color = '#3b82f6';
            } else if (status === 'sehr selten') {
              raritySlider.value = 2;
              rarityLabel.textContent = 'Sehr selten';
              rarityLabel.style.color = '#dc2626';
            } else if (status === 'selten') {
              raritySlider.value = 1;
              rarityLabel.textContent = 'Selten';
              rarityLabel.style.color = '#ef4444';
            } else {
              raritySlider.value = 0;
              rarityLabel.textContent = 'Häufig';
              rarityLabel.style.color = 'var(--text)';
            }
          }
        }
      });
      
      // Initial Marker-Liste aktualisieren
      setTimeout(updateMarkerList, 100);
    }
    
    // Hilfsfunktion: Beobachtung aus Tabellenzeile speichern
    async function saveObservationFromRow(row) {
      const id = row.getAttribute('data-id');
      const bird = row.cells[0].querySelector('input').value;
      
      // NEU: Validierung ob Vogel in Datenbank existiert
      if (!birdDatabase[bird]) {
        showNotification('❌ "' + bird + '" ist nicht in der Vogeldatenbank! Bitte wähle eine gültige Art.', 4000);
        return;
      }
      
      const date = row.cells[1].querySelector('input').value;
      const lat = row.cells[2].querySelector('.lat-input').value;
      const lng = row.cells[2].querySelector('.lng-input').value;
      
      const folder = row.closest('.folder');
      const folderId = folder ? folder.dataset.folderId : 'default_folder';
      const folderName = folder ? folder.querySelector('h3').textContent : 'Standard-Ordner';
      const folderColor = folder ? folder.style.borderLeftColor : colorPalette[0];
      
      const observation = {
        id: id,
        bird: bird,
        date: date,
        lat: lat,
        lng: lng,
        folderId: folderId,
        folderName: folderName,
        folderColor: folderColor,
        time: row.cells[0].querySelector('input').getAttribute('data-time') || '',
        count: row.cells[0].querySelector('input').getAttribute('data-count') || '1',
        behavior: row.cells[0].querySelector('input').getAttribute('data-behavior') || '',
        weather: row.cells[0].querySelector('input').getAttribute('data-weather') || '',
        photo: row.cells[0].querySelector('input').getAttribute('data-photo') || '',
        userName: getUserNameForObservation(), // NEU: Benutzername hinzufügen
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      await saveNewObservationToDB(observation);
      
      // NEU: Vergebe XP für neue Beobachtung
      await awardXPForNewObservation();
      
      // NEU: Synchronisiere geteilte Listen
      await syncSharedListsAfterNewObservation();
      
      updateMarkersFromData();
      updateDashboard();
    }
    
    // NEUE FUNKTION: Modal für Vogelbeobachtung bei Kartenklick
    function showVogelModalForMapClick(latlng) {
      // Modal-Daten vorbereiten
      const modalBackdrop = document.getElementById('modalBackdrop');
      const modalName = document.getElementById('modalName');
      const modalDate = document.getElementById('modalDate');
      
      // Platzhalter für Vogelart
      modalName.placeholder = "z.B. Amsel, Rotkehlchen...";
      modalName.value = "";
      
      // Aktuelles Datum setzen
      modalDate.value = new Date().toISOString().split('T')[0];
      
      // Temporäre Koordinaten speichern
      window.tempMarkerCoords = latlng;
      
      // Modal anzeigen
      modalBackdrop.style.display = 'flex';
    }
    
    // AKTUALISIERT: Beobachtung von Kartenklick in Tabelle eintragen
    async function addObservationFromMap(birdName, date, lat, lng, manualRarity = null) {
      try {
        // NEU: Validierung ob Vogel in Datenbank existiert
        if (!birdDatabase[birdName]) {
          showNotification('❌ "' + birdName + '" ist nicht in der Vogeldatenbank! Bitte wähle eine gültige Art.', 4000);
          return;
        }
        
        console.log("💾 ===== SPEICHERE BEOBACHTUNG =====");
        
        // Prüfe ZUERST window.currentSelectedGroup (globale Variable)
        var selectedGroup = window.currentSelectedGroup || "personal";
        
        // Fallback: Prüfe Select-Element
        if(!window.currentSelectedGroup){
          console.log("⚠️ window.currentSelectedGroup nicht gesetzt, prüfe Select-Element...");
          var groupSelect = document.getElementById("fbGroupSelect");
          if(groupSelect){
            selectedGroup = groupSelect.value;
            
            // NEU: Setze User-Farben zurück wenn Gruppe wechselt
            if (window.currentSelectedGroup !== selectedGroup) {
              resetUserColors();
            }
            
            window.currentSelectedGroup = selectedGroup;
            console.log("📋 Aus Select-Element gelesen und in window.currentSelectedGroup gespeichert:", selectedGroup);
          }
        }
        
        var isGroupMode = selectedGroup !== "personal" && selectedGroup !== null && selectedGroup !== undefined;
        
        console.log("   window.currentSelectedGroup:", window.currentSelectedGroup);
        console.log("   Ausgewählte Gruppe:", selectedGroup);
        console.log("   Ist Gruppen-Modus:", isGroupMode);
        console.log("   Firebase Auth vorhanden:", !!window.FBA);
        console.log("   Current User vorhanden:", !!(window.FBA && window.FBA.currentUser));
        
        if(isGroupMode && window.FBA && window.FBA.currentUser){
          // Speichere in Firebase für Gruppe
          var user = window.FBA.currentUser;
          var userName = user.displayName || user.email.split("@")[0];
          
          var observation = {
            bird: birdName,
            date: date,
            lat: lat.toFixed(6),
            lng: lng.toFixed(6),
            time: new Date().toTimeString().substr(0, 5),
            count: '1',
            behavior: '',
            weather: '',
            rarity: manualRarity || (birdDatabase[birdName] ? birdDatabase[birdName].status : null),  // Automatisch aus DB lesen
            userId: user.uid,
            userName: userName,
            userEmail: user.email,
            createdAt: firebase.database.ServerValue.TIMESTAMP
          };
          
          console.log("🔵 Speichere in Firebase-Gruppe:", selectedGroup);
          console.log("   Pfad:", "groups/" + selectedGroup + "/observations");
          console.log("   Beobachtung:", JSON.stringify(observation, null, 2));
          
          try{
            // NEU: Entferne undefined Werte für Firebase
            const cleanedObservation = removeUndefinedFields(observation);
            var ref = await window.FBD.ref("groups/" + selectedGroup + "/observations").push(cleanedObservation);
            console.log("✅ In Firebase gespeichert! Key:", ref.key);
            
            // NEU: Vergebe XP für neue Beobachtung
            await awardXPForNewObservation();
            
            showNotification(`✅ "${birdName}" in Gruppe gespeichert!`, 3000);
            
            // Aktualisiere Challenge falls auf der Seite
            if (document.getElementById('compareRarity2026View') && 
                document.getElementById('compareRarity2026View').style.display !== 'none') {
              console.log('🔄 Challenge wird aktualisiert...');
              setTimeout(() => renderRarityChallenge2026(), 1000);
            }
            
            // Navigation zurück
            setTimeout(() => {
              document.querySelector('.nav button[data-page="home"]').click();
            }, 500);
            
            return;
          }catch(e){
            console.error("❌ Firebase Fehler:", e);
            console.log("   Error Code:", e.code);
            console.log("   Error Message:", e.message);
            alert("❌ Fehler beim Speichern in Firebase:\n\n" + e.message + "\n\nFällt zurück auf lokale Speicherung.");
            // Falle durch zu lokaler Speicherung
          }
        } else {
          if(isGroupMode){
            console.log("⚠️ Gruppen-Modus aktiv aber Bedingungen nicht erfüllt!");
            console.log("   selectedGroup:", selectedGroup);
            console.log("   isGroupMode:", isGroupMode);
            console.log("   FBA:", !!window.FBA);
            console.log("   currentUser:", window.FBA ? !!window.FBA.currentUser : "N/A");
          } else {
            console.log("📱 Persönlicher Modus erkannt (selectedGroup:", selectedGroup, ")");
          }
        }
        
        console.log("💾 Speichere lokal (persönlicher Modus)");
        
        // Originaler Code für persönliche Beobachtungen
        // Finde oder erstelle einen Ordner
        let folderId = 'default_folder';
        let folderName = 'Standard-Ordner';
        const folders = await getAllFromIndexedDB('folders');
        if (folders.length > 0) {
          folderId = folders[0].id;
          folderName = folders[0].name;
        } else {
          // Erstelle Standard-Ordner
          const newFolder = {
            id: 'folder_' + Date.now(),
            name: 'Standard-Ordner',
            color: colorPalette[0],
            createdAt: new Date().toISOString()
          };
          await saveFolderToDB(newFolder);
          folderId = newFolder.id;
          folderName = newFolder.name;
        }
        
        // Erstelle neue Beobachtung
        const newObservation = {
          id: 'obs_' + Date.now(),
          bird: birdName,
          date: date,
          lat: lat.toFixed(6),
          lng: lng.toFixed(6),
          folderId: folderId,
          folderName: folderName,
          folderColor: colorPalette[0],
          time: new Date().toTimeString().substr(0, 5),
          count: '1',
          behavior: '',
          weather: '',
          userName: getUserNameForObservation(), // NEU: Benutzername hinzufügen
          rarity: manualRarity || (birdDatabase[birdName] ? birdDatabase[birdName].status : null),  // Automatisch aus DB lesen
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        // In IndexedDB speichern
        await saveNewObservationToDB(newObservation);
        
        // NEU: Vergebe XP für neue Beobachtung
        await awardXPForNewObservation();
        
        // UI aktualisieren
        await loadData();
        
        // NEU: Synchronisiere geteilte Listen
        await syncSharedListsAfterNewObservation();
        
        // Dashboard aktualisieren
        updateDashboard();
        
        // Erfolgsmeldung
        showNotification(`Vogelbeobachtung "${birdName}" erfolgreich gespeichert!`, 3000);
        
        // Optional: Zurück zum Dashboard navigieren
        setTimeout(() => {
          document.querySelector('.nav button[data-page="home"]').click();
        }, 500);
      } catch (error) {
        console.error('Fehler beim Speichern:', error);
        showNotification('Fehler beim Speichern der Beobachtung', 3000);
      }
    }
    
    function createMarker(id, lat, lng, name, date, observationData = {}) {
      // Prüfen, ob Marker bereits existiert
      if (window.markers.has(id)) {
        return window.markers.get(id);
      }
      
      // NEU: Im Gruppenmodus - erstelle farbigen Marker basierend auf userId
      let markerIcon = null;
      if (observationData.userId) {
        const userColor = getUserColor(observationData.userId);
        markerIcon = L.divIcon({
          className: 'custom-marker',
          html: `<div style="
            width: 25px;
            height: 25px;
            background: ${userColor};
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
          "></div>`,
          iconSize: [25, 25],
          iconAnchor: [12, 12],
          popupAnchor: [0, -12]
        });
      }
      
      // NEU: Marker sind nur draggable wenn dragMode AN ist UND Marker NICHT gesperrt sind
      const markerOptions = {
        draggable: dragMode && !markersLocked
      };
      
      if (markerIcon) {
        markerOptions.icon = markerIcon;
      }
      
      const marker = L.marker([lat, lng], markerOptions);
      
      // Erstelle detailliertes Popup mit allen verfügbaren Informationen
      const popupContent = createDetailedPopup(name, date, lat, lng, observationData);
      
      marker.bindPopup(popupContent, {
        maxWidth: 320,
        className: 'detailed-observation-popup'
      });
      
      window.markers.set(id, marker);
      markerCluster.addLayer(marker);
      
      // Drag Event für Updates
      marker.on('dragend', function() {
        updateMarkerList();
      });
      
      return marker;
    }
    
    function createDetailedPopup(name, date, lat, lng, data = {}) {
      const birdName = escapeHtml(name || 'Unbekannte Art');
      const dateStr = date ? escapeHtml(formatDateForDisplay(date)) : 'Kein Datum';
      const timeStr = data.time ? escapeHtml(data.time) : null;
      
      let popup = `
        <div class="observation-popup">
          <div class="observation-popup-header">
            <div class="observation-popup-icon">🐦</div>
            <div class="observation-popup-title">
              <h3>${birdName}</h3>
              <div class="date">${dateStr}${timeStr ? ' • ' + timeStr : ''}</div>
            </div>
          </div>
      `;
      
      // NEU: Benutzerinformationen im Gruppenmodus
      if (data.userId && data.userName) {
        const userColor = getUserColor(data.userId);
        popup += `
          <div class="observation-popup-section" style="background:rgba(${parseInt(userColor.slice(1,3), 16)},${parseInt(userColor.slice(3,5), 16)},${parseInt(userColor.slice(5,7), 16)},0.1);border-left:3px solid ${userColor};">
            <div class="observation-popup-section-title">Beobachter</div>
            <div class="observation-popup-value" style="display:flex;align-items:center;gap:8px;">
              <div style="width:12px;height:12px;background:${userColor};border-radius:50%;border:2px solid white;"></div>
              <span>👤 ${escapeHtml(data.userName)}</span>
            </div>
          </div>
        `;
      }
      
      // Anzahl
      if (data.count) {
        popup += `
          <div class="observation-popup-section">
            <div class="observation-popup-section-title">Anzahl</div>
            <div class="observation-popup-value">🔢 ${escapeHtml(data.count)} Individuen</div>
          </div>
        `;
      }
      
      // Verhalten
      if (data.behavior) {
        popup += `
          <div class="observation-popup-section">
            <div class="observation-popup-section-title">Verhalten</div>
            <div class="observation-popup-value">💭 ${escapeHtml(data.behavior)}</div>
          </div>
        `;
      }
      
      // Wetter
      if (data.weather) {
        popup += `
          <div class="observation-popup-section">
            <div class="observation-popup-section-title">Wetterbedingungen</div>
            <div class="observation-popup-value">🌤️ ${escapeHtml(data.weather)}</div>
          </div>
        `;
      }
      
      // Bundesland
      if (data.state) {
        popup += `
          <div class="observation-popup-section">
            <div class="observation-popup-section-title">Bundesland</div>
            <div class="observation-popup-value">📍 ${escapeHtml(data.state)}</div>
          </div>
        `;
      }
      
      // Foto
      if (data.photo) {
        popup += `
          <div class="observation-popup-section">
            <div class="observation-popup-section-title">Foto 📷</div>
            <div style="position: relative;">
              <img src="${escapeHtml(data.photo)}" 
                   alt="Beobachtungsfoto" 
                   class="observation-popup-photo" 
                   onerror="this.parentElement.innerHTML='<div style=\\'padding:20px;text-align:center;color:rgba(255,255,255,0.5);\\'>❌ Foto konnte nicht geladen werden</div>'"
                   onclick="window.open('${escapeHtml(data.photo)}', '_blank')"
                   title="Klicken zum Vergrößern"
                   loading="lazy">
            </div>
          </div>
        `;
      }
      
      // Koordinaten
      popup += `
        <div class="observation-popup-section">
          <div class="observation-popup-section-title">Koordinaten</div>
          <div class="observation-popup-coords">
            <div class="observation-popup-coord">
              <div class="observation-popup-coord-label">Breitengrad</div>
              <div class="observation-popup-coord-value">${lat.toFixed(6)}</div>
            </div>
            <div class="observation-popup-coord">
              <div class="observation-popup-coord-label">Längengrad</div>
              <div class="observation-popup-coord-value">${lng.toFixed(6)}</div>
            </div>
          </div>
        </div>
      `;
      
      popup += `</div>`;
      
      return popup;
    }
    
    function formatDateForDisplay(iso) {
      if (!iso) return '';
      try {
        // Parse das Datum manuell um UTC-Probleme zu vermeiden
        // Format: YYYY-MM-DD
        const parts = iso.split('-');
        if (parts.length === 3) {
          const year = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10);
          const day = parseInt(parts[2], 10);
          
          // Erstelle Datum in lokaler Zeitzone (nicht UTC)
          const d = new Date(year, month - 1, day);
          
          if (!isNaN(d.getTime())) {
            return d.toLocaleDateString('de-DE');
          }
        }
        
        // Fallback: Versuche normale Date-Konvertierung
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          return d.toLocaleDateString('de-DE');
        }
        
        return iso;
      } catch(e) {
        return iso;
      }
    }
    
    function locateUser() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          window.mapObj.setView([position.coords.latitude, position.coords.longitude], 14);
          showNotification('Zu deinem Standort navigiert.');
        }, function() {
          showNotification('Standort konnte nicht ermittelt werden.', 3000);
        });
      } else {
        showNotification('Geolocation wird nicht unterstützt.', 3000);
      }
    }
    
    // ---------- Karte exportieren/drucken ----------
    async function exportMapAsImage() {
      try {
        showNotification('📸 Erstelle Kartenexport...', 2000);
        
        // Erstelle einen Screenshot der Karte mit html2canvas
        const mapElement = document.getElementById('map');
        
        // Einfache Lösung ohne externe Library
        // Nutze Browser's native Screenshot-Capability
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Hole die Karten-Größe
        const rect = mapElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        // Erstelle einen temporären Canvas mit der Karte
        try {
          // Versuche mit html2canvas wenn verfügbar
          if (typeof html2canvas !== 'undefined') {
            const capturedCanvas = await html2canvas(mapElement);
            const link = document.createElement('a');
            link.download = `vogelkarte_${new Date().toISOString().split('T')[0]}.png`;
            link.href = capturedCanvas.toDataURL();
            link.click();
            showNotification('✅ Karte als Bild gespeichert', 3000);
          } else {
            // Fallback: Browser-Screenshot-Anleitung
            alert('📸 Karte als Bild speichern:\n\n' +
                  '1. Drücke Print Screen (Druck-Taste)\n' +
                  '2. Öffne ein Bildbearbeitungsprogramm\n' +
                  '3. Füge das Bild ein (Strg+V)\n' +
                  '4. Schneide den Kartenbereich zu\n\n' +
                  'Oder nutze Browser-Drucken (Strg+P) und\n' +
                  '"Als PDF speichern"');
          }
        } catch (err) {
          console.error('Fehler beim Screenshot:', err);
          // Fallback zu Print-Dialog
          window.print();
        }
      } catch (error) {
        console.error('Fehler beim Karten-Export:', error);
        showNotification('❌ Fehler beim Export', 3000);
      }
    }
    
    function printMap() {
      // Zeige Optionen-Dialog
      const choice = confirm(
        '🖨️ Karte drucken/exportieren:\n\n' +
        'OK = Als Bild speichern (Screenshot)\n' +
        'Abbrechen = Drucken-Dialog öffnen'
      );
      
      if (choice) {
        // Als Bild exportieren
        exportMapAsImage();
      } else {
        // Browser-Drucken
        // Füge temporäre Print-Styles hinzu
        const style = document.createElement('style');
        style.id = 'print-styles';
        style.innerHTML = `
          @media print {
            body * { visibility: hidden; }
            #map, #map * { visibility: visible; }
            #map { 
              position: absolute;
              left: 0;
              top: 0;
              width: 100%;
              height: 100%;
            }
          }
        `;
        document.head.appendChild(style);
        
        // Drucke
        window.print();
        
        // Entferne Print-Styles nach Drucken
        setTimeout(() => {
          const printStyle = document.getElementById('print-styles');
          if (printStyle) printStyle.remove();
        }, 1000);
      }
    }
    
    async function updateMarkerList() {
      const markerList = document.getElementById('markerList');
      markerList.innerHTML = '';
      
      if (window.markers.size === 0) {
        markerList.innerHTML = '<div class="muted">Keine Punkte</div>';
        return;
      }
      
      window.markers.forEach((marker, id) => {
        const latlng = marker.getLatLng();
        const popup = marker.getPopup();
        const content = popup ? popup.getContent() : '';
        
        // Extrahiere Name aus Popup-Content (suche nach h3 statt strong)
        let name = 'Unbenannt';
        if (content) {
          // Versuche zuerst h3 zu finden
          let match = content.match(/<h3>(.*?)<\/h3>/);
          if (match) {
            name = match[1];
          } else {
            // Fallback: versuche strong
            match = content.match(/<strong>(.*?)<\/strong>/);
            if (match) {
              name = match[1];
            }
          }
        }
        
        const markerItem = document.createElement('div');
        markerItem.className = 'marker-item';
        markerItem.innerHTML = `
            <div>
                <strong class="${getRarityStyle(name).rarityClass}">${getRarityStyle(name).rarityIcon}${escapeHtml(name)}</strong>
                <div class="marker-meta">${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}</div>
            </div>
            <button class="small-btn" onclick="removeMarker('${id}')" style="background:var(--danger);">🗑️</button>
        `;
        
        markerList.appendChild(markerItem);
      });
    }
    
    // KORRIGIERT: Marker löschen - KOMPLETT ÜBERARBEITET
    async function removeMarker(id) {
      if (window.markers.has(id)) {
        const marker = window.markers.get(id);
        
        // Marker von der Karte entfernen
        if (marker && marker.remove) {
          marker.remove();
        }
        
        // Marker aus der Map entfernen
        window.markers.delete(id);
        
        // Marker aus Cluster entfernen
        if (markerCluster) {
          markerCluster.removeLayer(marker);
        }
        
        // Wenn es eine Zeile mit dieser ID gibt, dann entferne sie auch und lösche aus IndexedDB
        if (!id.startsWith('custom_')) {
          const row = document.querySelector(`[data-id="${id}"]`);
          if (row) {
            // Zeile entfernen
            row.remove();
            // Aus IndexedDB löschen
            await deleteObservationFromDB(id);
            // Dashboard aktualisieren
            updateDashboard();
            // Chart und Statistiken aktualisieren
            updateChart();
            updateAdvancedStatistics();
          }
        }
        
        // Aus der Liste entfernen
        updateMarkerList();
        
        showNotification('Marker gelöscht!', 2000);
      }
    }
    
    // ---------- HEATMAP FUNKTIONALITÄT ----------
    async function toggleHeatmap() {
      const btn = document.getElementById('heatmapToggle');
      const btnTools = document.getElementById('heatmapToggleTools');
      
      if (heatmapLayer) {
        // Heatmap deaktivieren
        window.mapObj.removeLayer(heatmapLayer);
        heatmapLayer = null;
        
        // Marker-Cluster wieder anzeigen und Marker neu laden
        if (markerCluster) {
          console.log('Stelle Marker-Cluster wieder her...');
          
          // Stelle sicher, dass markerCluster zur Karte hinzugefügt wird
          if (!window.mapObj.hasLayer(markerCluster)) {
            window.mapObj.addLayer(markerCluster);
          }
          
          // Setze Flag um konkurrierende Updates zu verhindern
          isRestoringMarkers = true;
          
          // Lade alle Marker neu
          console.log('Lade Marker neu...');
          await updateMarkersFromData();
          
          // Warte kurz und setze Flag zurück
          setTimeout(() => {
            isRestoringMarkers = false;
            console.log('Marker-Wiederherstellung abgeschlossen');
          }, 500);
        }
        
        if (btn) btn.textContent = '🔥 Heatmap: Aus';
        if (btnTools) btnTools.textContent = '🔥 Heatmap: Aus';
        showNotification('Heatmap deaktiviert - Marker angezeigt', 2000);
        
      } else {
        // Heatmap aktivieren
        try {
          const observations = await getAllObservationsWithDetails();
          
          if (observations.length === 0) {
            showNotification('⚠️ Keine Beobachtungen für Heatmap', 3000);
            return;
          }
          
          // Erstelle Heatmap-Daten (Lat, Lng, Intensität)
          const heatData = observations
            .filter(obs => obs.lat && obs.lng)
            .map(obs => [
              parseFloat(obs.lat),
              parseFloat(obs.lng),
              0.5 // Intensität
            ]);
          
          if (heatData.length === 0) {
            showNotification('⚠️ Keine Koordinaten für Heatmap', 3000);
            return;
          }
          
          console.log('Erstelle Heatmap mit', heatData.length, 'Punkten');
          
          // Erstelle Heatmap-Layer
          heatmapLayer = L.heatLayer(heatData, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            max: 1.0,
            gradient: {
              0.0: '#3b82f6',
              0.5: '#f59e0b',
              1.0: '#ef4444'
            }
          });
          
          // Füge Heatmap zur Karte hinzu
          heatmapLayer.addTo(window.mapObj);
          
          // Verstecke Marker-Cluster
          if (markerCluster && window.mapObj.hasLayer(markerCluster)) {
            window.mapObj.removeLayer(markerCluster);
          }
          
          if (btn) btn.textContent = '🔥 Heatmap: An';
          if (btnTools) btnTools.textContent = '🔥 Heatmap: An';
          showNotification('Heatmap aktiviert - Marker ausgeblendet', 2000);
          
        } catch (error) {
          console.error('Fehler beim Erstellen der Heatmap:', error);
          showNotification('❌ Fehler beim Erstellen der Heatmap', 3000);
        }
      }
    }
    
    function toggleCluster() {
      const btn = document.getElementById('clusterToggle');
      if (!markerCluster) return;
      
      const isVisible = window.mapObj.hasLayer(markerCluster);
      if (isVisible) {
        window.mapObj.removeLayer(markerCluster);
        btn.textContent = '📍 Cluster: Aus';
        showNotification('Clustering deaktiviert', 2000);
      } else {
        window.mapObj.addLayer(markerCluster);
        btn.textContent = '📍 Cluster: An';
        showNotification('Clustering aktiviert', 2000);
      }
    }
    
    // ---------- ERWEITERTE FILTER-FUNKTIONEN ----------
    
    // Filter anwenden
    async function applyFilters() {
      const dateFrom = document.getElementById('filterDateFrom').value;
      const dateTo = document.getElementById('filterDateTo').value;
      const species = document.getElementById('filterSpecies').value;
      const weather = document.getElementById('filterWeather').value;
      const state = document.getElementById('filterState').value;
      
      // Speichere aktuelle Filter
      currentFilters = {
        dateFrom: dateFrom || null,
        dateTo: dateTo || null,
        species: species || null,
        weather: weather || null,
        state: state || null
      };
      
      // Hole alle Beobachtungen
      const observations = await getAllObservationsWithDetails();
      
      // Filtere Beobachtungen
      let filtered = observations.filter(obs => {
        // Filter nach Datum
        if (dateFrom && obs.date < dateFrom) return false;
        if (dateTo && obs.date > dateTo) return false;
        
        // Filter nach Art
        if (species && obs.bird !== species) return false;
        
        // Filter nach Wetter
        if (weather && obs.weather !== weather) return false;
        
        // Filter nach Bundesland
        if (state && obs.state !== state) return false;
        
        return true;
      });
      
      // Aktualisiere Karte mit gefilterten Markern
      updateMapWithFilteredObservations(filtered);
      
      // Aktualisiere Schnellstatistik
      await updateQuickStats();
      
      // Visuelles Feedback für aktive Filter
      const btn = document.querySelector('button[onclick="applyFilters()"]');
      if (btn) {
        btn.style.background = 'var(--success)';
        btn.textContent = '✓ Filter aktiv';
      }
      
      showNotification(`${filtered.length} von ${observations.length} Beobachtungen gefunden`, 3000);
    }
    
    // Filter zurücksetzen
    async function resetFilters() {
      // Felder leeren
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterSpecies').value = '';
      document.getElementById('filterWeather').value = '';
      document.getElementById('filterState').value = '';
      
      // Filter zurücksetzen
      currentFilters = {};
      
      // Alle Marker wieder anzeigen
      const observations = await getAllObservationsWithDetails();
      updateMapWithFilteredObservations(observations);
      
      // Aktualisiere Schnellstatistik
      await updateQuickStats();
      
      // Visuelles Feedback zurücksetzen
      const btn = document.querySelector('button[onclick="applyFilters()"]');
      if (btn) {
        btn.style.background = 'var(--accent)';
        btn.textContent = 'Filter anwenden';
      }
      
      showNotification('Filter zurückgesetzt - alle Beobachtungen angezeigt', 2000);
    }
    
    // Hilfsfunktion: Karte mit gefilterten Beobachtungen aktualisieren
    function updateMapWithFilteredObservations(observations) {
      // Entferne alle Marker
      if (markerCluster) {
        markerCluster.clearLayers();
      }
      window.markers.clear();
      
      // Füge gefilterte Marker hinzu
      observations.forEach(obs => {
        if (obs.lat && obs.lng) {
          // Sammle alle zusätzlichen Beobachtungsdaten
          const observationData = {
            time: obs.time,
            count: obs.count,
            behavior: obs.behavior,
            weather: obs.weather,
            photo: obs.photo,
            state: obs.state
          };
          
          createMarker(obs.id, obs.lat, obs.lng, obs.bird, obs.date, observationData);
        }
      });
      
      updateMarkerList();
    }
    
    // Hilfsfunktion: Distanz zwischen zwei Punkten berechnen (Haversine-Formel)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Erdradius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // NEU: Hilfsfunktion zum Filtern von Nullmeldungen
    // Nullmeldungen (count = 0) sollen nicht in Challenges, Listen oder Analysen einfließen
    function isValidObservation(obs) {
      // Prüfe ob es eine Nullmeldung ist
      if (!obs.count && obs.count !== undefined) return true; // Kein count-Feld = gültig (alte Beobachtungen)
      
      const countNum = parseInt(obs.count) || 0;
      if (countNum === 0 || obs.count === '0') {
        return false; // Nullmeldung = ungültig
      }
      
      return true; // Alle anderen = gültig
    }
    
    // Mache Funktion global verfügbar
    window.isValidObservation = isValidObservation;
    
    // Initialisiere Filter-Arten-Select
    async function initFilterSpeciesSelect() {
      const select = document.getElementById('filterSpecies');
      if (!select) return;
      
      select.innerHTML = '<option value="">Alle Arten</option>';
      
      // Hole alle einzigartigen Vogelarten aus den Beobachtungen
      const observations = await getAllObservationsWithDetails();
      const species = new Set(observations.map(obs => obs.bird).filter(Boolean));
      
      // Sortiere alphabetisch
      const sortedSpecies = Array.from(species).sort();
      
      sortedSpecies.forEach(bird => {
        const option = document.createElement('option');
        option.value = bird;
        option.textContent = bird;
        select.appendChild(option);
      });
    }
    
    // Bundesland-Filter initialisieren
    async function initFilterStateSelect() {
      const select = document.getElementById('filterState');
      if (!select) return;
      
      select.innerHTML = '<option value="">Alle Bundesländer</option>';
      
      // Hole alle einzigartigen Bundesländer aus den Beobachtungen
      const observations = await getAllObservationsWithDetails();
      const states = new Set(observations.map(obs => obs.state).filter(Boolean));
      
      // Sortiere alphabetisch
      const sortedStates = Array.from(states).sort();
      
      sortedStates.forEach(state => {
        const option = document.createElement('option');
        option.value = state;
        option.textContent = state;
        select.appendChild(option);
      });
    }
    
    // ---------- SCHNELLSTATISTIK-FUNKTIONEN ----------
    
    // Schnellstatistik aktualisieren
    async function updateQuickStats() {
      const container = document.getElementById('quickStats');
      if (!container) return;
      
      container.innerHTML = '<div class="muted">Berechne Statistiken...</div>';
      
      try {
        // Hole Beobachtungen basierend auf aktiven Filtern
        const observations = await getAllObservationsWithDetails();
        
        // Wenn Filter aktiv sind, filtere die Beobachtungen
        let filtered = observations;
        if (currentFilters && Object.keys(currentFilters).length > 0) {
          filtered = observations.filter(obs => {
            if (currentFilters.dateFrom && obs.date < currentFilters.dateFrom) return false;
            if (currentFilters.dateTo && obs.date > currentFilters.dateTo) return false;
            if (currentFilters.species && obs.bird !== currentFilters.species) return false;
            if (currentFilters.weather && obs.weather !== currentFilters.weather) return false;
            if (currentFilters.state && obs.state !== currentFilters.state) return false;
            return true;
          });
        }
        
        // Berechne Statistiken
        const totalCount = filtered.length;
        const speciesCount = new Set(filtered.map(obs => obs.bird).filter(Boolean)).size;
        const daysCount = new Set(filtered.map(obs => obs.date).filter(Boolean)).size;
        const foldersCount = new Set(filtered.map(obs => obs.folderId).filter(Boolean)).size;
        
        // Häufigste Art
        const birdCounts = {};
        filtered.forEach(obs => {
          if (obs.bird) {
            birdCounts[obs.bird] = (birdCounts[obs.bird] || 0) + 1;
          }
        });
        
        const mostCommon = Object.entries(birdCounts).sort((a, b) => b[1] - a[1])[0];
        const mostCommonText = mostCommon ? `${mostCommon[0]} (${mostCommon[1]}×)` : 'Keine Daten';
        
        // HTML aufbauen
        container.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px;">
            <div style="text-align: center;">
              <div style="font-size: 24px; font-weight: 700; color: var(--accent);">${totalCount}</div>
              <div style="font-size: 11px; color: var(--muted);">Beobachtungen</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 24px; font-weight: 700; color: var(--accent-2);">${speciesCount}</div>
              <div style="font-size: 11px; color: var(--muted);">Arten</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 24px; font-weight: 700; color: var(--success);">${daysCount}</div>
              <div style="font-size: 11px; color: var(--muted);">Tage</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 24px; font-weight: 700; color: var(--muted);">${foldersCount}</div>
              <div style="font-size: 11px; color: var(--muted);">Ordner</div>
            </div>
          </div>
          <div style="padding: 8px; background: var(--glass); border-radius: 8px; text-align: center;">
            <div style="font-size: 11px; color: var(--muted); margin-bottom: 4px;">Häufigste Art:</div>
            <div style="font-size: 13px; font-weight: 600;">${mostCommonText}</div>
          </div>
        `;
        
      } catch (error) {
        console.error('Fehler beim Berechnen der Schnellstatistik:', error);
        container.innerHTML = '<div class="muted">Fehler beim Laden der Statistik</div>';
      }
    }
    
    // Schnellstatistik exportieren
    async function exportQuickStats() {
      try {
        const observations = await getAllObservationsWithDetails();
        
        // Erstelle CSV
        let csv = 'Datum,Vogelart,Ordner,Koordinaten\n';
        
        observations.forEach(obs => {
          const date = obs.date || '';
          const bird = obs.bird || '';
          const folder = obs.folderName || '';
          const coords = (obs.lat && obs.lng) ? `${obs.lat},${obs.lng}` : '';
          
          csv += `${date},${bird},${folder},"${coords}"\n`;
        });
        
        // Download erstellen
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', `vogelbeobachtungen_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showNotification('Statistik exportiert!', 2000);
        
      } catch (error) {
        console.error('Fehler beim Export:', error);
        showNotification('Export fehlgeschlagen', 3000);
      }
    }
    
    // ---------- DIAGRAMM-FUNKTIONEN ----------
    
    // Variable für ausgewählte Mitglieder (userId -> boolean)
    let selectedMembers = {};
    
    // Mitglieder-Filter initialisieren
    async function initMemberFilter() {
      const container = document.getElementById('memberFilterContainer');
      const checkboxesContainer = document.getElementById('memberCheckboxes');
      
      if (!container || !checkboxesContainer) return;
      
      // Prüfe ob wir im Gruppen-Modus sind
      const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== "personal";
      
      if (!isGroupMode) {
        container.style.display = 'none';
        return;
      }
      
      container.style.display = 'block';
      
      try {
        // NEU: Setze User-Farben zurück für frische Zuweisung
        console.log('🔄 Setze User-Farben zurück');
        resetUserColors();
        
        // Lade alle Gruppen-Beobachtungen
        const observations = await getAllObservationsWithDetails();
        
        // Sammle alle einzigartigen Mitglieder
        const membersMap = new Map();
        observations.forEach(obs => {
          if (obs.userId && obs.userName) {
            if (!membersMap.has(obs.userId)) {
              membersMap.set(obs.userId, {
                userId: obs.userId,
                userName: obs.userName,
                userEmail: obs.userEmail || '',
                count: 0
              });
            }
            membersMap.get(obs.userId).count++;
          }
        });
        
        // Sortiere nach Anzahl der Beobachtungen
        const members = Array.from(membersMap.values()).sort((a, b) => b.count - a.count);
        
        // NEU: Initialisiere Benutzerfarben für alle Mitglieder
        members.forEach(member => {
          getUserColor(member.userId); // Initialisiert die Farbe
        });
        
        // Initialisiere selectedMembers mit allen Mitgliedern
        selectedMembers = {};
        members.forEach(member => {
          selectedMembers[member.userId] = true;
        });
        
        // Erstelle Checkboxen
        checkboxesContainer.innerHTML = '';
        members.forEach(member => {
          const label = document.createElement('label');
          label.style.cssText = 'display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--bg);border-radius:8px;cursor:pointer;font-size:13px;';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = true;
          checkbox.dataset.userId = member.userId;
          checkbox.addEventListener('change', function() {
            selectedMembers[member.userId] = this.checked;
            updateChart();
          });
          
          const text = document.createElement('span');
          text.textContent = `${member.userName} (${member.count})`;
          
          label.appendChild(checkbox);
          label.appendChild(text);
          checkboxesContainer.appendChild(label);
        });
        
        // "Alle auswählen" Button
        document.getElementById('selectAllMembers').onclick = function() {
          document.querySelectorAll('#memberCheckboxes input[type="checkbox"]').forEach(cb => {
            cb.checked = true;
            selectedMembers[cb.dataset.userId] = true;
          });
          updateChart();
        };
        
        // "Alle abwählen" Button
        document.getElementById('deselectAllMembers').onclick = function() {
          document.querySelectorAll('#memberCheckboxes input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            selectedMembers[cb.dataset.userId] = false;
          });
          updateChart();
        };
        
      } catch (error) {
        console.error('Fehler beim Laden der Mitglieder:', error);
        container.style.display = 'none';
      }
    }
    
    function updateYearSelection() {
      const timeRangeSlider = document.getElementById('timeRangeSlider');
      const timeRangeValue = document.getElementById('timeRangeValue');
      
      timeRangeSlider.addEventListener('input', function() {
        chartSettings.customDays = parseInt(this.value);
        chartSettings.mode = 'custom';
        
        if (chartSettings.customDays === 365) {
          timeRangeValue.textContent = 'Dieses Jahr';
        } else if (chartSettings.customDays === 30) {
          timeRangeValue.textContent = 'Letzte 30 Tage';
        } else {
          timeRangeValue.textContent = `${chartSettings.customDays} Tage`;
        }
        
        updateChart();
      });
    }
    
    function hexToRgba(hex, alpha = 1) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    async function updateChart() {
      const canvas = document.getElementById('chartCanvas');
      const ctx = canvas.getContext('2d');
      
      // Vorheriges Diagramm zerstören
      if (chart) {
        chart.destroy();
      }
      
      // Status-Filter auslesen
      const tickableFilterCheckbox = document.getElementById('tickableFilter');
      const selffoundFilterCheckbox = document.getElementById('selffoundFilter');
      const newSpeciesFilterCheckbox = document.getElementById('newSpeciesFilter');
      const onlyTickable = tickableFilterCheckbox ? tickableFilterCheckbox.checked : false;
      const onlySelffound = selffoundFilterCheckbox ? selffoundFilterCheckbox.checked : false;
      const onlyNewSpecies = newSpeciesFilterCheckbox ? newSpeciesFilterCheckbox.checked : false;
      
      // Daten sammeln mit Status-Filtern
      const allObservations = await getAllObservationsWithDetails();
      // NEU: Filtere Nullmeldungen grundsätzlich aus
      let observations = allObservations.filter(obs => isValidObservation(obs));
      
      // NEU: Filter für nur neue Arten (Erstbeobachtungen im Zeitraum)
      if (onlyNewSpecies) {
        // Bestimme den aktuellen Zeitraum basierend auf dem Slider
        const timeRange = parseInt(document.getElementById('timeRangeSlider').value);
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - timeRange);
        
        // Filtere Beobachtungen im gewählten Zeitraum
        const observationsInRange = observations.filter(obs => {
          const obsDate = new Date(obs.date);
          return obsDate >= cutoffDate;
        });
        
        // Sortiere Beobachtungen nach Datum (älteste zuerst)
        observationsInRange.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Tracke welche Arten bereits im Zeitraum gesehen wurden
        const seenSpeciesInRange = new Set();
        const newSpeciesObservations = [];
        
        // Gehe durch alle Beobachtungen chronologisch
        observationsInRange.forEach(obs => {
          const bird = obs.bird;
          
          // Wenn Art noch nicht im Zeitraum gesehen wurde
          if (!seenSpeciesInRange.has(bird)) {
            seenSpeciesInRange.add(bird);
            // Markiere diese Beobachtung als "Erstbeobachtung im Zeitraum"
            newSpeciesObservations.push({
              ...obs,
              isFirstInRange: true
            });
          }
          // Alle weiteren Beobachtungen dieser Art im Zeitraum werden NICHT gezählt
        });
        
        // Ersetze observations mit nur den Erstbeobachtungen
        observations = newSpeciesObservations;
        
        // Info-Box anzeigen
        const newSpeciesInfo = document.getElementById('newSpeciesInfo');
        const newSpeciesCount = document.getElementById('newSpeciesCount');
        const uniqueNewSpecies = observations.length;
        if (newSpeciesInfo && newSpeciesCount) {
          newSpeciesInfo.style.display = 'block';
          newSpeciesCount.textContent = `${uniqueNewSpecies} neue Art${uniqueNewSpecies !== 1 ? 'en' : ''} im Zeitraum (nur erste Beobachtung pro Art)`;
        }
      } else {
        // Info-Box verstecken
        const newSpeciesInfo = document.getElementById('newSpeciesInfo');
        if (newSpeciesInfo) {
          newSpeciesInfo.style.display = 'none';
        }
      }
      
      // Wende weitere Filter an
      if (onlyTickable) {
        observations = observations.filter(obs => obs.tickable !== false);
      }
      if (onlySelffound) {
        observations = observations.filter(obs => obs.selffound === true);
      }
      
      // Update Status-Filter Info
      const statusFilterInfo = document.getElementById('statusFilterInfo');
      if (statusFilterInfo) {
        let filterText = '';
        const filters = [];
        if (onlyNewSpecies) filters.push('Neue Arten');
        if (onlyTickable) filters.push('Tickbar');
        if (onlySelffound) filters.push('Selffound');
        
        if (filters.length > 0) {
          filterText = `(${observations.length} Beobachtungen: ${filters.join(' & ')})`;
        } else {
          filterText = `(${observations.length} Beobachtungen)`;
        }
        statusFilterInfo.textContent = filterText;
      }
      
      // Update Label-Border für aktive Filter
      const tickableLabel = document.getElementById('tickableFilterLabel');
      const selffoundLabel = document.getElementById('selffoundFilterLabel');
      const newSpeciesLabel = document.getElementById('newSpeciesFilterLabel');
      if (tickableLabel) {
        tickableLabel.style.borderColor = onlyTickable ? 'rgba(16,185,129,0.5)' : 'transparent';
      }
      if (selffoundLabel) {
        selffoundLabel.style.borderColor = onlySelffound ? 'rgba(239,68,68,0.5)' : 'transparent';
      }
      if (newSpeciesLabel) {
        newSpeciesLabel.style.borderColor = onlyNewSpecies ? 'rgba(6,182,212,0.5)' : 'transparent';
      }
      
      const { labels, datasets } = getChartData(observations);
      
      if (labels.length === 0 || datasets.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '14px Inter';
        ctx.fillStyle = 'var(--muted)';
        ctx.textAlign = 'center';
        ctx.fillText('Keine Daten für das Diagramm verfügbar', canvas.width / 2, canvas.height / 2);
        
        document.getElementById('chartMax').textContent = '0';
        document.getElementById('chartAvg').textContent = '0';
        document.getElementById('chartTotal').textContent = '0';
        return;
      }
      
      // Chart-Statistiken aktualisieren
      updateChartStats(datasets);
      
      // Theme-basierte Farben
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const gridColor = isDark ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
      const textColor = isDark ? 'var(--soft)' : 'var(--muted)';
      
      // NEU: Setze Cursor auf pointer - Charts sind jetzt immer klickbar
      canvas.style.cursor = 'pointer';
      
      // Chart erstellen
      chart = new Chart(ctx, {
        type: chartSettings.aggregation === 'day' ? 'bar' : 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          onClick: (event, activeElements) => {
            console.log('🖱️ Chart geklickt!');
            console.log('   Active Elements:', activeElements);
            
            // NEU: Zeige Details für angeklickte Säule/Punkt
            if (activeElements.length > 0) {
              const elementIndex = activeElements[0].index;
              console.log('   Element-Index:', elementIndex);
              
              // Prüfe ob "nur neue Arten"-Filter aktiv ist
              const filterCheckbox = document.getElementById('newSpeciesFilter');
              const onlyNewSpecies = filterCheckbox ? filterCheckbox.checked : false;
              
              showObservationsForLabel(elementIndex, chart, onlyNewSpecies);
            } else {
              console.log('   ℹ️ Kein aktives Element gefunden.');
            }
          },
          plugins: {
            legend: {
              position: 'top',
              labels: {
                color: textColor,
                usePointStyle: true,
                pointStyle: 'rect'
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: isDark ? 'rgba(15,23,36,0.9)' : 'rgba(255,255,255,0.9)',
              titleColor: textColor,
              bodyColor: textColor,
              borderColor: 'rgba(255,255,255,0.1)',
              borderWidth: 1,
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  label += context.parsed.y;
                  
                  // NEU: Füge Hinweis hinzu wenn Erstbeobachtungen aktiv sind
                  const filterCheckbox = document.getElementById('newSpeciesFilter');
                  const onlyNewSpecies = filterCheckbox ? filterCheckbox.checked : false;
                  if (onlyNewSpecies && context.parsed.y > 0) {
                    label += ' (Klick für Details)';
                  }
                  
                  return label;
                }
              }
            }
          },
          scales: {
            x: {
              stacked: chartSettings.aggregation === 'day', // Gestapelt für Tagesansicht
              grid: {
                color: gridColor
              },
              ticks: {
                color: textColor,
                maxTicksLimit: chartSettings.aggregation === 'day' ? 15 : 12,
              }
            },
            y: {
              beginAtZero: true,
              stacked: chartSettings.aggregation === 'day', // Gestapelt für Tagesansicht
              grid: {
                color: gridColor
              },
              ticks: {
                color: textColor,
                stepSize: 1,
                precision: 0
              }
            }
          },
          animation: {
            duration: 750,
            easing: 'easeOutQuart'
          }
        }
      });
    }
    
    function getChartData(observations) {
      if (observations.length === 0) {
        return { labels: [], datasets: [] };
      }
      
      // Zeitraum basierend auf chartSettings
      let startDate = new Date();
      let endDate = new Date();
      
      switch(chartSettings.mode) {
        case 'this_year':
          startDate = new Date(new Date().getFullYear(), 0, 1);
          endDate = new Date();
          break;
        case 'last_year':
          startDate = new Date(new Date().getFullYear() - 1, 0, 1);
          endDate = new Date(new Date().getFullYear() - 1, 11, 31);
          break;
        case '30_days':
          startDate.setDate(startDate.getDate() - 30);
          break;
        case '7_days':
          startDate.setDate(startDate.getDate() - 7);
          break;
        case '90_days':
          startDate.setDate(startDate.getDate() - 90);
          break;
        case 'all':
          const dates = observations.map(o => new Date(o.date)).filter(d => !isNaN(d));
          if (dates.length > 0) {
            startDate = new Date(Math.min(...dates));
          }
          break;
        default:
          startDate.setDate(startDate.getDate() - chartSettings.customDays);
      }
      
      // Setze Start- und Endzeit für korrekten Vergleich
      startDate.setHours(0, 0, 0, 0);
      endDate.setHours(23, 59, 59, 999);
      
      // Nach Datum filtern (mit korrekter Datumsverarbeitung)
      let filteredObs = observations.filter(obs => {
        if (!obs.date) return false;
        
        try {
          const [year, month, day] = obs.date.split('-').map(Number);
          const obsDate = new Date(year, month-1, day);
          obsDate.setHours(0, 0, 0, 0);
          
          const obsTimestamp = obsDate.getTime();
          const startTimestamp = startDate.getTime();
          const endTimestamp = endDate.getTime();
          
          return obsTimestamp >= startTimestamp && obsTimestamp <= endTimestamp;
        } catch (e) {
          console.error('Fehler beim Parsen des Datums:', obs.date, e);
          return false;
        }
      });
      
      // Filtere nach ausgewählten Mitgliedern (im Gruppenmodus)
      const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== "personal";
      if (isGroupMode && Object.keys(selectedMembers).length > 0) {
        filteredObs = filteredObs.filter(obs => {
          // Wenn userId vorhanden ist, prüfe ob das Mitglied ausgewählt ist
          if (obs.userId) {
            return selectedMembers[obs.userId] === true;
          }
          // Ohne userId immer anzeigen (Fallback)
          return true;
        });
      }
      
      // Im Gruppenmodus: Nach Benutzern gruppieren, sonst nach Ordnern
      const dataGroups = {};
      
      if (isGroupMode) {
        console.log('📊 Gruppenmodus: Gruppiere nach userId');
        // Gruppiere nach userId für Gruppenmodus
        filteredObs.forEach(obs => {
          const userId = obs.userId || 'unknown';
          if (!dataGroups[userId]) {
            const color = getUserColor(userId);
            dataGroups[userId] = {
              groupName: obs.userName || obs.userEmail || 'Unbekannt',
              groupColor: color,
              observations: []
            };
            console.log(`  👤 User: ${dataGroups[userId].groupName}, Farbe: ${color}`);
          }
          dataGroups[userId].observations.push(obs);
        });
      } else {
        console.log('📊 Persönlicher Modus: Gruppiere nach folderId');
        // Gruppiere nach folderId für normalen Modus
        filteredObs.forEach(obs => {
          const folderId = obs.folderId || 'default';
          if (!dataGroups[folderId]) {
            dataGroups[folderId] = {
              groupName: obs.folderName || 'Standard',
              groupColor: obs.folderColor || colorPalette[0],
              observations: []
            };
          }
          dataGroups[folderId].observations.push(obs);
        });
      }
      
      // NEU: Speichere Beobachtungen nach Label für Click-Handler
      // Gruppiere alle gefilterten Beobachtungen nach ihrem Label (Tag/Woche/Monat/Jahr)
      window.chartObservationsByLabel = {};
      console.log('📊 Speichere Beobachtungen nach Label...');
      console.log('   Anzahl gefilterte Beobachtungen:', filteredObs.length);
      console.log('   Aggregation:', chartSettings.aggregation);
      
      filteredObs.forEach(obs => {
        if (!obs.date) return;
        
        try {
          const [year, month, day] = obs.date.split('-').map(Number);
          const date = new Date(year, month-1, day);
          let label = '';
          
          switch(chartSettings.aggregation) {
            case 'day':
              label = formatDateForDisplay(obs.date);
              break;
            case 'week':
              const weekNumber = getWeekNumber(date);
              label = `KW ${weekNumber} ${date.getFullYear()}`;
              break;
            case 'month':
              const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
              label = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
              break;
            case 'year':
              label = date.getFullYear().toString();
              break;
            default:
              label = formatDateForDisplay(obs.date);
          }
          
          if (!window.chartObservationsByLabel[label]) {
            window.chartObservationsByLabel[label] = [];
          }
          window.chartObservationsByLabel[label].push(obs);
        } catch (e) {
          console.error('Fehler beim Gruppieren der Beobachtungen nach Label:', obs.date, e);
        }
      });
      
      console.log('✅ Beobachtungen gespeichert. Labels:', Object.keys(window.chartObservationsByLabel));
      console.log('   Anzahl pro Label:', Object.entries(window.chartObservationsByLabel).map(([k,v]) => `${k}: ${v.length}`).join(', '));
      
      // Für jede Gruppe eine Zeitreihe erstellen
      const datasets = [];
      const allLabels = [];
      
      Object.entries(dataGroups).forEach(([groupId, groupData]) => {
        const { labels, values } = groupObservationsWithCompleteSeries(
          groupData.observations, 
          chartSettings.aggregation, 
          new Date(startDate), 
          new Date(endDate)
        );
        
        // Labels für alle Gruppen sammeln
        labels.forEach(label => {
          if (!allLabels.includes(label)) {
            allLabels.push(label);
          }
        });
        
        datasets.push({
          label: groupData.groupName,
          data: values,
          labels: labels,
          backgroundColor: chartSettings.aggregation === 'day' ? 
            hexToRgba(groupData.groupColor, 0.7) : 
            hexToRgba(groupData.groupColor, 0.1),
          borderColor: groupData.groupColor,
          borderWidth: chartSettings.aggregation === 'day' ? 1 : 2,
          fill: chartSettings.aggregation !== 'day',
          tension: 0.4,
          borderRadius: chartSettings.aggregation === 'day' ? 4 : 0,
          hoverBackgroundColor: groupData.groupColor
        });
      });
      
      // Labels sortieren (für chronologische Reihenfolge)
      // Intelligente Sortierung basierend auf Aggregationstyp
      if (chartSettings.aggregation === 'day') {
        // Für Tage: Sortiere nach Datum
        allLabels.sort((a, b) => {
          // Parse deutsche Datumsformate: "15.01.2024"
          const parseGermanDate = (dateStr) => {
            const parts = dateStr.split('.');
            if (parts.length === 3) {
              return new Date(parts[2], parts[1] - 1, parts[0]);
            }
            return new Date(dateStr);
          };
          return parseGermanDate(a) - parseGermanDate(b);
        });
      } else if (chartSettings.aggregation === 'month') {
        // Für Monate: Sortiere nach Jahr und Monat
        allLabels.sort((a, b) => {
          // Parse "Jan 2024", "Feb 2024", etc.
          const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
          
          const parseMonth = (label) => {
            const parts = label.split(' ');
            if (parts.length === 2) {
              const monthIndex = monthNames.indexOf(parts[0]);
              const year = parseInt(parts[1]);
              return year * 12 + monthIndex;
            }
            return 0;
          };
          
          return parseMonth(a) - parseMonth(b);
        });
      } else if (chartSettings.aggregation === 'week') {
        // Für Wochen: Sortiere nach Jahr und Kalenderwoche
        allLabels.sort((a, b) => {
          // Parse "KW 12 2024"
          const parseWeek = (label) => {
            const match = label.match(/KW (\d+) (\d+)/);
            if (match) {
              const week = parseInt(match[1]);
              const year = parseInt(match[2]);
              return year * 100 + week;
            }
            return 0;
          };
          
          return parseWeek(a) - parseWeek(b);
        });
      } else if (chartSettings.aggregation === 'year') {
        // Für Jahre: Sortiere numerisch
        allLabels.sort((a, b) => parseInt(a) - parseInt(b));
      } else {
        // Fallback: Alphabetische Sortierung
        allLabels.sort();
      }
      
      // Daten für alle Datensätze auf gleiche Länge bringen
      datasets.forEach(dataset => {
        const alignedData = new Array(allLabels.length).fill(0);
        dataset.data.forEach((value, index) => {
          const label = dataset.labels?.[index];
          if (label) {
            const labelIndex = allLabels.indexOf(label);
            if (labelIndex !== -1) {
              alignedData[labelIndex] = value;
            }
          }
        });
        dataset.data = alignedData;
      });
      
      return { labels: allLabels, datasets };
    }
    
    function updateChartStats(datasets) {
      if (!datasets || datasets.length === 0) return;
      
      // Werte aus allen Datensätzen sammeln
      let allValues = [];
      datasets.forEach(dataset => {
        allValues = allValues.concat(dataset.data);
      });
      
      const nonZeroValues = allValues.filter(v => v > 0);
      
      if (nonZeroValues.length === 0) {
        document.getElementById('chartMax').textContent = '0';
        document.getElementById('chartAvg').textContent = '0';
        document.getElementById('chartTotal').textContent = '0';
        return;
      }
      
      const total = nonZeroValues.reduce((sum, val) => sum + val, 0);
      const max = Math.max(...nonZeroValues);
      const avg = (total / nonZeroValues.length).toFixed(1);
      
      document.getElementById('chartMax').textContent = max;
      document.getElementById('chartAvg').textContent = avg;
      document.getElementById('chartTotal').textContent = total;
    }
    
    function groupObservationsWithCompleteSeries(observations, aggregation, startDate, endDate) {
      const groups = {};
      
      // Zuerst vorhandene Daten gruppieren
      observations.forEach(obs => {
        if (!obs.date) return;
        
        let key = '';
        try {
          const [year, month, day] = obs.date.split('-').map(Number);
          const date = new Date(year, month-1, day);
          
          switch(aggregation) {
            case 'day':
              key = obs.date; // bereits im Format YYYY-MM-DD
              break;
            case 'week':
              const weekNumber = getWeekNumber(date);
              key = `${date.getFullYear()}-${weekNumber.toString().padStart(2, '0')}`;
              break;
            case 'month':
              key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
              break;
            case 'year':
              key = date.getFullYear().toString();
              break;
            default:
              key = obs.date;
          }
          
          if (!groups[key]) {
            groups[key] = 0;
          }
          groups[key]++;
        } catch (e) {
          console.error('Fehler beim Gruppieren des Datums:', obs.date, e);
        }
      });
      
      // Vollständige Zeitreihe generieren
      const allKeys = [];
      const allValues = [];
      const allLabels = [];
      
      let current = new Date(startDate);
      current.setHours(0, 0, 0, 0);
      
      const end = new Date(endDate);
      end.setHours(23, 59, 59, 999);
      
      // Bei Tagesaggregation: Alle Tage im Zeitraum
      if (aggregation === 'day') {
        while (current <= end) {
          const key = formatDateToKey(current, 'day');
          allKeys.push(key);
          allValues.push(groups[key] || 0);
          allLabels.push(formatDateForDisplay(key));
          current.setDate(current.getDate() + 1);
        }
      }
      // Bei Wochenaggregation: Alle Wochen im Zeitraum
      else if (aggregation === 'week') {
        // Zur ersten Woche gehen
        const firstWeek = getWeekNumber(startDate);
        const firstYear = startDate.getFullYear();
        
        let currentYear = firstYear;
        let currentWeek = firstWeek;
        
        while (true) {
          const key = `${currentYear}-${currentWeek.toString().padStart(2, '0')}`;
          const weekEndDate = getDateOfISOWeek(currentWeek, currentYear);
          
          if (weekEndDate > end) break;
          
          allKeys.push(key);
          allValues.push(groups[key] || 0);
          allLabels.push(`KW ${currentWeek} ${currentYear}`);
          
          // Nächste Woche
          currentWeek++;
          if (currentWeek > 52) {
            currentWeek = 1;
            currentYear++;
          }
        }
      }
      // Bei Monatsaggregation: Alle Monate im Zeitraum
      else if (aggregation === 'month') {
        const startYear = startDate.getFullYear();
        const startMonth = startDate.getMonth();
        const endYear = endDate.getFullYear();
        const endMonth = endDate.getMonth();
        
        for (let year = startYear; year <= endYear; year++) {
          const monthStart = (year === startYear) ? startMonth : 0;
          const monthEnd = (year === endYear) ? endMonth : 11;
          
          for (let month = monthStart; month <= monthEnd; month++) {
            const key = `${year}-${String(month + 1).padStart(2, '0')}`;
            allKeys.push(key);
            allValues.push(groups[key] || 0);
            
            const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
            allLabels.push(`${monthNames[month]} ${year}`);
          }
        }
      }
      // Bei Jahresaggregation: Alle Jahre im Zeitraum
      else if (aggregation === 'year') {
        const startYear = startDate.getFullYear();
        const endYear = endDate.getFullYear();
        
        for (let year = startYear; year <= endYear; year++) {
          const key = year.toString();
          allKeys.push(key);
          allValues.push(groups[key] || 0);
          allLabels.push(year.toString());
        }
      }
      
      // Wenn showEmptyDays false ist, entferne leere Werte am Anfang und Ende
      if (!chartSettings.showEmptyDays && allValues.length > 0) {
        let firstNonZero = 0;
        let lastNonZero = allValues.length - 1;
        
        // Finde ersten nicht-leeren Wert
        while (firstNonZero < allValues.length && allValues[firstNonZero] === 0) {
          firstNonZero++;
        }
        
        // Finde letzten nicht-leeren Wert
        while (lastNonZero >= 0 && allValues[lastNonZero] === 0) {
          lastNonZero--;
        }
        
        // Schneide Array zu
        if (firstNonZero <= lastNonZero) {
          return {
            labels: allLabels.slice(firstNonZero, lastNonZero + 1),
            values: allValues.slice(firstNonZero, lastNonZero + 1)
          };
        }
      }
      
      return { labels: allLabels, values: allValues };
    }
    
    // Hilfsfunktion: Datum zu Key formatieren
    function formatDateToKey(date, format) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      
      if (format === 'day') {
        return `${year}-${month}-${day}`;
      }
      return `${year}-${month}`;
    }
    
    // Hilfsfunktion: Datum einer bestimmten Kalenderwoche
    function getDateOfISOWeek(week, year) {
      const simple = new Date(year, 0, 1 + (week - 1) * 7);
      const dow = simple.getDay();
      const ISOweekStart = simple;
      if (dow <= 4) {
        ISOweekStart.setDate(simple.getDate() - simple.getDay() + 1);
      } else {
        ISOweekStart.setDate(simple.getDate() + 8 - simple.getDay());
      }
      return ISOweekStart;
    }
    
    function getWeekNumber(date) {
      const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
      const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
      return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
    }
    
    // ---------- STATISTIK-FUNKTIONEN ----------
    async function updateAdvancedStatistics() {
      const stats = await getDetailedStatistics();
      const statsContainer = document.getElementById('stats');
      
      if (stats.totalObservations === 0) {
        statsContainer.innerHTML = '<p class="muted">Keine Beobachtungen vorhanden</p>';
        return;
      }
      
      let html = `
        <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:12px;margin-bottom:24px;">
          <div class="card">
            <div class="kpi"><div class="value">${stats.totalObservations}</div><div class="muted">Gesamt</div></div>
          </div>
          <div class="card">
            <div class="kpi"><div class="value">${stats.uniqueSpecies}</div><div class="muted">Arten</div></div>
          </div>
          <div class="card">
            <div class="kpi"><div class="value">${stats.uniqueDates}</div><div class="muted">Tage</div></div>
          </div>
          <div class="card">
            <div class="kpi"><div class="value">${stats.averagePerDay}</div><div class="muted">Ø/Tag</div></div>
          </div>
        </div>
        
        <div style="background:var(--glass);padding:16px;border-radius:12px;margin-bottom:24px;">
          <h3>Top 5 Vogelarten</h3>
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:12px;">
      `;
      
      stats.topSpecies.forEach((species, index) => {
        const percentage = Math.round((species.count / stats.totalObservations) * 100);
        const rarity = getRarityStyle(species.name);
        html += `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;">
            <div style="display:flex;align-items:center;gap:12px;">
              <div style="width:32px;height:32px;background:linear-gradient(135deg, var(--accent), var(--accent-2));color:white;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:600;">
                ${index + 1}
              </div>
              <div>
                <div class="${rarity.rarityClass}" style="font-weight:600;">${rarity.rarityIcon}${species.name}</div>
                <div style="font-size:12px;color:var(--muted);">${birdDatabase[species.name]?.scientific || ''}</div>
              </div>
            </div>
            <div style="display:flex;align-items:center;gap:16px;">
              <div style="width:120px;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;">
                <div style="height:100%;background:var(--accent);width:${percentage}%;"></div>
              </div>
              <div style="font-weight:700;font-size:18px;">${species.count}</div>
            </div>
          </div>
        `;
      });
      
      html += `
          </div>
        </div>
      `;
      
      statsContainer.innerHTML = html;
      
      // Monatliche Übersicht aktualisieren
      updateMonthlyOverview();
      
      // Beobachtungsübersicht anzeigen
      showAllObservations();
    }
    
    async function getDetailedStatistics() {
      const allObservations = await getAllObservationsWithDetails();
      // Filter: Nur tickbare Beobachtungen UND keine Nullmeldungen für Statistiken
      const observations = allObservations.filter(obs => 
        obs.tickable !== false && isValidObservation(obs)
      );
      
      const stats = {
        totalObservations: observations.length,
        uniqueSpecies: new Set(observations.map(o => o.bird)).size,
        uniqueDates: new Set(observations.map(o => o.date)).size,
        byMonth: {},
        bySpecies: {},
        topSpecies: []
      };
      
      if (observations.length === 0) return stats;
      
      observations.forEach(obs => {
        if (obs.date) {
          const month = obs.date.substring(5, 7);
          if (!stats.byMonth[month]) stats.byMonth[month] = 0;
          stats.byMonth[month]++;
        }
        
        if (obs.bird) {
          if (!stats.bySpecies[obs.bird]) stats.bySpecies[obs.bird] = 0;
          stats.bySpecies[obs.bird]++;
        }
      });
      
      stats.topSpecies = Object.entries(stats.bySpecies)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([name, count]) => ({ name, count }));
      
      const uniqueDates = [...new Set(observations.map(o => o.date).filter(d => d))];
      stats.averagePerDay = uniqueDates.length > 0 ? 
        (observations.length / uniqueDates.length).toFixed(1) : 0;
      
      return stats;
    }
    
    async function updateMonthlyOverview() {
      const stats = await getDetailedStatistics();
      const container = document.getElementById('monthlyOverview');
      
      if (Object.keys(stats.byMonth).length === 0) {
        container.innerHTML = '<div class="muted">Keine Daten für monatliche Übersicht</div>';
        return;
      }
      
      const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
      let html = '<div style="display:flex;flex-direction:column;gap:8px;">';
      
      for (let month = 1; month <= 12; month++) {
        const monthKey = month.toString().padStart(2, '0');
        const count = stats.byMonth[monthKey] || 0;
        const max = Math.max(...Object.values(stats.byMonth));
        const percentage = max > 0 ? (count / max) * 100 : 0;
        
        html += `
          <div>
            <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
              <span>${monthNames[month-1]}</span>
              <span style="font-weight:600;">${count}</span>
            </div>
            <div style="height:6px;background:rgba(255,255,255,0.05);border-radius:3px;overflow:hidden;">
              <div style="height:100%;background:var(--accent);width:${percentage}%;"></div>
            </div>
          </div>
        `;
      }
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    // ---------- Dashboard & Statistiken ----------
    async function updateDashboard() {
      const stats = await getDetailedStatistics();
      
      document.getElementById('kpiTotal').textContent = stats.totalObservations;
      document.getElementById('kpiSpecies').textContent = stats.uniqueSpecies;
      document.getElementById('kpiDays').textContent = stats.uniqueDates;
      document.getElementById('kpiAvg').textContent = stats.averagePerDay;
      
      const topSpeciesList = document.getElementById('topSpeciesList');
      if (stats.topSpecies.length > 0) {
        let html = '';
        stats.topSpecies.slice(0, 5).forEach(species => {
          const rarity = getRarityStyle(species.name);
          html += `
            <div class="top-species-item">
              <span class="${rarity.rarityClass}">${rarity.rarityIcon}${species.name}</span>
              <span class="species-count">${species.count}</span>
            </div>
          `;
        });
        topSpeciesList.innerHTML = html;
      } else {
        topSpeciesList.innerHTML = '<div class="muted">Keine Beobachtungen</div>';
      }
    }
    
    async function updateStorageInfo() {
      try {
        const stats = await getDatabaseStats();
        if (!stats) return;
        
        const maxKB = 102400; // 100 MB für IndexedDB
        const usedKB = parseInt(stats.totalSize) || 0;
        const percentage = Math.min(100, (usedKB / maxKB) * 100);
        
        document.getElementById('storageProgress').style.width = `${percentage}%`;
        document.getElementById('storageInfo').textContent = 
          `${usedKB} KB / ${maxKB} KB (${Math.round(percentage)}%) - ${stats.totalObservations} Beobachtungen`;
        
        // Systeminfo aktualisieren
        document.getElementById('sysObservations').textContent = stats.totalObservations;
        document.getElementById('sysStorage').textContent = stats.totalSize;
        document.getElementById('sysOffline').textContent = 'IndexedDB';
        
      } catch (error) {
        console.error('Fehler beim Aktualisieren der Storage-Info:', error);
      }
    }
    
    // ---------- TOOLS-FUNKTIONEN ----------
    
    // Backup erstellen
    async function backupData() {
      try {
        const exportData = await exportDatabase();
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `birdcount_backup_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        showNotification('✅ Backup erstellt!', 3000);
      } catch (error) {
        console.error('Fehler beim Backup:', error);
        showNotification('❌ Backup fehlgeschlagen', 3000);
      }
    }
    
    // Backup wiederherstellen
    async function restoreBackup() {
      if (!confirm('⚠️ Alle aktuellen Daten werden durch das Backup ersetzt!\n\nMöchten Sie fortfahren?')) {
        return;
      }
      
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          
          // Lösche alte Daten
          await clearAllData();
          
          // Importiere neue Daten
          if (data.folders && Array.isArray(data.folders)) {
            for (const folder of data.folders) {
              await saveFolderToDB(folder);
            }
          }
          
          if (data.observations && Array.isArray(data.observations)) {
            for (const obs of data.observations) {
              await saveNewObservationToDB(obs);
            }
          }
          
          if (data.lists && Array.isArray(data.lists)) {
            for (const list of data.lists) {
              await saveToIndexedDB('lists', list);
            }
          }
          
          showNotification('✅ Backup wiederhergestellt!', 3000);
          
          // Neu laden
          await loadData();
          updateDashboard();
          
        } catch (error) {
          console.error('Fehler beim Wiederherstellen:', error);
          alert('❌ Fehler beim Wiederherstellen des Backups:\n\n' + error.message);
        }
      };
      
      input.click();
    }
    
    // Cache leeren
    async function clearCache() {
      if (!confirm('⚠️ Alle Daten werden gelöscht!\n\nDies kann nicht rückgängig gemacht werden.\n\nMöchten Sie fortfahren?')) {
        return;
      }
      
      if (!confirm('⚠️ LETZTE WARNUNG!\n\nErstellen Sie zuerst ein Backup!\n\nWirklich alle Daten löschen?')) {
        return;
      }
      
      try {
        await clearAllData();
        localStorage.clear();
        
        showNotification('✅ Cache geleert!', 3000);
        
        // Seite neu laden
        setTimeout(() => {
          window.location.reload();
        }, 1000);
        
      } catch (error) {
        console.error('Fehler beim Leeren:', error);
        showNotification('❌ Fehler beim Leeren', 3000);
      }
    }
    
    // Alle Beobachtungen löschen
    async function deleteAllObservations() {
      // Prüfe ob im Gruppenmodus
      const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
      
      let confirmMessage, warningMessage;
      
      if (isGroupMode) {
        // Im Gruppenmodus: Nur eigene Beobachtungen in der Gruppe löschen
        const user = window.FBA?.currentUser;
        if (!user) {
          showNotification('❌ Nicht angemeldet', 3000);
          return;
        }
        
        confirmMessage = `⚠️ Alle DEINE Beobachtungen in dieser Gruppe löschen?\n\nDies kann nicht rückgängig gemacht werden!\n\nMöchten Sie fortfahren?`;
        warningMessage = `⚠️ LETZTE WARNUNG!\n\nAlle deine Beobachtungen in dieser Gruppe werden gelöscht!\n\nWirklich fortfahren?`;
      } else {
        // Im privaten Modus: Alle Beobachtungen aus IndexedDB löschen
        confirmMessage = `⚠️ ALLE deine privaten Beobachtungen löschen?\n\nDies kann nicht rückgängig gemacht werden!\n\nErstelle zuerst ein Backup!\n\nMöchten Sie fortfahren?`;
        warningMessage = `⚠️ LETZTE WARNUNG!\n\nALLE deine privaten Beobachtungen werden gelöscht!\n\nWirklich fortfahren?`;
      }
      
      // Erste Sicherheitsabfrage
      if (!confirm(confirmMessage)) {
        return;
      }
      
      // Zweite Sicherheitsabfrage
      if (!confirm(warningMessage)) {
        return;
      }
      
      try {
        if (isGroupMode) {
          // Gruppenmodus: Nur eigene Beobachtungen löschen
          const groupId = window.currentSelectedGroup;
          const user = window.FBA.currentUser;
          
          showNotification('Lösche Beobachtungen...', 2000);
          
          // Lade alle Beobachtungen der Gruppe
          const groupObsRef = window.FBD.ref(`groups/${groupId}/observations`);
          const snapshot = await groupObsRef.once('value');
          
          if (!snapshot.exists()) {
            showNotification('ℹ️ Keine Beobachtungen gefunden', 3000);
            return;
          }
          
          const observations = snapshot.val();
          const updates = {};
          let deleteCount = 0;
          
          // Finde und markiere alle eigenen Beobachtungen zum Löschen
          for (const [obsId, obs] of Object.entries(observations)) {
            if (obs.userId === user.uid || obs.createdBy === user.email) {
              updates[`groups/${groupId}/observations/${obsId}`] = null; // null = löschen
              deleteCount++;
            }
          }
          
          if (deleteCount === 0) {
            showNotification('ℹ️ Keine eigenen Beobachtungen gefunden', 3000);
            return;
          }
          
          // Lösche alle auf einmal (Batch-Update)
          await window.FBD.ref().update(updates);
          
          showNotification(`✅ ${deleteCount} Beobachtungen aus Gruppe gelöscht`, 3000);
          
          // Aktualisiere UI
          if (typeof renderRarityChallenge === 'function') {
            await renderRarityChallenge();
          }
          if (typeof renderObservationManager === 'function') {
            await renderObservationManager();
          }
          
        } else {
          // Privater Modus: Alle Beobachtungen aus IndexedDB löschen
          showNotification('Lösche alle Beobachtungen...', 2000);
          
          // Lade alle Beobachtungen
          const observations = await getAllFromIndexedDB('observations');
          
          if (observations.length === 0) {
            showNotification('ℹ️ Keine Beobachtungen gefunden', 3000);
            return;
          }
          
          const count = observations.length;
          
          // Lösche alle Beobachtungen
          for (const obs of observations) {
            await deleteFromIndexedDB('observations', obs.id);
            
            // Entferne auch von der Karte
            if (window.markers && window.markers.has(obs.id)) {
              const marker = window.markers.get(obs.id);
              if (marker) {
                if (window.markerCluster) {
                  window.markerCluster.removeLayer(marker);
                }
                marker.remove();
                window.markers.delete(obs.id);
              }
            }
          }
          
          showNotification(`✅ ${count} Beobachtungen gelöscht`, 3000);
          
          // Aktualisiere UI
          await loadData();
          await initFolderSelect();
          updateMarkersFromData();
          updateChart();
          updateAdvancedStatistics();
          updateDashboard();
          await updateQuickStats();
          if (typeof renderObservationManager === 'function') {
            await renderObservationManager();
          }
          
          // Synchronisiere geteilte Listen
          await syncSharedListsAfterNewObservation();
        }
        
      } catch (error) {
        console.error('Fehler beim Löschen der Beobachtungen:', error);
        showNotification('❌ Fehler beim Löschen: ' + error.message, 5000);
      }
    }
    
    // Heatmap-Optionen anzeigen
    function showHeatmapOptions() {
      alert('🔥 Heatmap-Optionen:\n\n' +
            '• Radius: 25px\n' +
            '• Blur: 15px\n' +
            '• Max-Intensität: 1.0\n\n' +
            'Diese Einstellungen können in zukünftigen Versionen angepasst werden.');
    }
    
    // NEU: Benutzername speichern (Privater Modus)
    function savePrivateUserName() {
      const input = document.getElementById('privateUserNameInput');
      const name = input.value.trim();
      
      if (!name) {
        showNotification('⚠️ Bitte gib einen Namen ein', 2000);
        return;
      }
      
      if (setPrivateUserName(name)) {
        showNotification(`✅ Name gespeichert: ${name}`, 3000);
        updatePrivateUserNameDisplay();
        input.value = ''; // Leere das Eingabefeld
      } else {
        showNotification('❌ Fehler beim Speichern', 2000);
      }
    }
    
    // NEU: Anzeige des aktuellen Namens aktualisieren
    function updatePrivateUserNameDisplay() {
      const display = document.getElementById('currentUserNameDisplay');
      if (display) {
        display.textContent = getPrivateUserName();
      }
      
      // Auch das Eingabefeld mit dem aktuellen Namen vorbelegen
      const input = document.getElementById('privateUserNameInput');
      if (input && !input.value) {
        input.placeholder = getPrivateUserName();
      }
    }
    
    // NEU: Initialisierung wenn Tools-Seite geladen wird
    document.addEventListener('DOMContentLoaded', function() {
      // Aktualisiere die Anzeige wenn die Tools-Seite geöffnet wird
      const navButtons = document.querySelectorAll('.nav button');
      navButtons.forEach(btn => {
        btn.addEventListener('click', function() {
          const page = this.getAttribute('data-page');
          if (page === 'tools') {
            // Warte kurz, bis die Seite angezeigt wird
            setTimeout(updatePrivateUserNameDisplay, 100);
          }
        });
      });
      
      // Initialisiere auch sofort falls wir auf der Tools-Seite sind
      updatePrivateUserNameDisplay();
    });
    
    // System-Info aktualisieren
    async function updateSystemInfo() {
      const stats = await getDatabaseStats();
      
      if (stats) {
        document.getElementById('sysObservations').textContent = stats.totalObservations;
        document.getElementById('sysStorage').textContent = stats.totalSize;
      }
    }
    
    // Export Daten (JSON oder CSV)
    async function exportData(format) {
      try {
        const observations = await getAllObservationsWithDetails();
        
        if (observations.length === 0) {
          showNotification('⚠️ Keine Daten zum Exportieren', 3000);
          return;
        }
        
        let dataStr, mimeType, filename;
        
        if (format === 'json') {
          // JSON Export
          const exportObj = {
            exportDate: new Date().toISOString(),
            version: '2.1.0',
            observations: observations,
            folders: await getAllFromIndexedDB('folders'),
            lists: await getAllFromIndexedDB('lists')
          };
          
          dataStr = JSON.stringify(exportObj, null, 2);
          mimeType = 'application/json';
          filename = `birdcount_${new Date().toISOString().split('T')[0]}.json`;
          
        } else if (format === 'csv') {
          // CSV Export
          const headers = ['Vogelart', 'Datum', 'Zeit', 'Latitude', 'Longitude', 'Anzahl', 'Verhalten', 'Wetter', 'Ordner'];
          const rows = observations.map(obs => [
            obs.bird || '',
            obs.date || '',
            obs.time || '',
            obs.lat || '',
            obs.lng || '',
            obs.count || '1',
            obs.behavior || '',
            obs.weather || '',
            obs.folderName || ''
          ]);
          
          dataStr = [headers, ...rows].map(row => 
            row.map(cell => `"${cell}"`).join(',')
          ).join('\n');
          
          mimeType = 'text/csv;charset=utf-8;';
          filename = `birdcount_${new Date().toISOString().split('T')[0]}.csv`;
        }
        
        // Download erstellen
        const blob = new Blob([dataStr], { type: mimeType });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        
        showNotification(`✅ ${format.toUpperCase()} exportiert!`, 3000);
        
      } catch (error) {
        console.error('Fehler beim Export:', error);
        showNotification('❌ Export fehlgeschlagen', 3000);
      }
    }
    
    // ---------- NEUE FUNKTION: Bereinige verwaiste Marker ----------
    async function cleanupOrphanedMarkers() {
      const observations = await getAllObservationsWithDetails();
      const observationIds = new Set(observations.map(o => o.id));
      
      const orphanedMarkers = [];
      window.markers.forEach((marker, id) => {
        if (!id.startsWith('custom_') && !observationIds.has(id)) {
          orphanedMarkers.push(id);
        }
      });
      
      orphanedMarkers.forEach(id => {
        const marker = window.markers.get(id);
        if (marker) {
          if (markerCluster) {
            markerCluster.removeLayer(marker);
          }
          marker.remove();
          window.markers.delete(id);
        }
      });
      
      if (orphanedMarkers.length > 0) {
        console.log(`${orphanedMarkers.length} verwaiste Marker bereinigt`);
        updateMarkerList();
      }
    }
    
    // ---------- HILFSFUNKTIONEN ----------
    function showNotification(message, duration = 3000) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, duration);
    }
    
    // KORRIGIERT: updateMarkersFromData Funktion
    async function updateMarkersFromData() {
      // Lade alle Beobachtungen
      const observations = await getAllObservationsWithDetails();
      
      // IDs der aktuellen Beobachtungen
      const currentObservationIds = new Set(observations.map(obs => obs.id));
      
      // Entferne Marker, deren Beobachtungen nicht mehr existieren
      const markersToRemove = [];
      window.markers.forEach((marker, id) => {
        if (!id.startsWith('custom_') && !currentObservationIds.has(id)) {
          markersToRemove.push(id);
        }
      });
      
      // Entferne verwaiste Marker
      markersToRemove.forEach(id => {
        const marker = window.markers.get(id);
        if (marker) {
          if (markerCluster) {
            markerCluster.removeLayer(marker);
          }
          marker.remove();
          window.markers.delete(id);
        }
      });
      
      // Wenn Heatmap aktiv ist, überspringe die Marker-Aktualisierung
      if (heatmapLayer && window.mapObj && window.mapObj.hasLayer(heatmapLayer)) {
        console.log('Heatmap ist aktiv - überspringe Marker-Aktualisierung');
        return;
      }
      
      // Stelle sicher, dass markerCluster auf der Karte ist
      if (markerCluster && window.mapObj && !window.mapObj.hasLayer(markerCluster)) {
        window.mapObj.addLayer(markerCluster);
      }
      
      // Neuen Marker-Cluster erstellen
      if (markerCluster) {
        markerCluster.clearLayers();
      }
      
      // Marker aus den Beobachtungen erstellen
      const existingIds = new Set();
      
      observations.forEach(obs => {
        if (obs.lat && obs.lng && obs.bird && obs.date && !existingIds.has(obs.id)) {
          // Sammle alle zusätzlichen Beobachtungsdaten
          const observationData = {
            time: obs.time,
            count: obs.count,
            behavior: obs.behavior,
            weather: obs.weather,
            photo: obs.photo,
            state: obs.state,
            userId: obs.userId,     // NEU: für Gruppenmodus
            userName: obs.userName   // NEU: für Gruppenmodus
          };
          
          createMarker(obs.id, parseFloat(obs.lat), parseFloat(obs.lng), obs.bird, obs.date, observationData);
          existingIds.add(obs.id);
        }
      });
      
      // Custom Marker (temporäre) wieder hinzufügen
      window.markers.forEach((marker, id) => {
        if (id.startsWith('custom_') && markerCluster) {
          markerCluster.addLayer(marker);
        }
      });
      
      updateMarkerList();
      
      // NEU: Aktualisiere Gruppen-Legende
      updateGroupLegend(observations);
    }
    
    // NEU: Aktualisiere Gruppen-Legende
    function updateGroupLegend(observations) {
      const legendContainer = document.getElementById('groupMarkerLegend');
      const legendItems = document.getElementById('groupLegendItems');
      
      if (!legendContainer || !legendItems) return;
      
      // Prüfe ob wir im Gruppenmodus sind
      const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
      
      if (!isGroupMode) {
        legendContainer.style.display = 'none';
        return;
      }
      
      // Sammle User-Statistiken
      const userStats = {};
      observations.forEach(obs => {
        if (obs.userId && obs.userName) {
          if (!userStats[obs.userId]) {
            userStats[obs.userId] = {
              name: obs.userName,
              count: 0,
              color: getUserColor(obs.userId)
            };
          }
          userStats[obs.userId].count++;
        }
      });
      
      // Sortiere nach Anzahl
      const sortedUsers = Object.entries(userStats)
        .sort((a, b) => b[1].count - a[1].count);
      
      if (sortedUsers.length === 0) {
        legendContainer.style.display = 'none';
        return;
      }
      
      // Zeige Legende
      legendContainer.style.display = 'block';
      
      // Rendere Legende
      let html = '';
      sortedUsers.forEach(([userId, stats]) => {
        const isCurrentUser = window.FBA && window.FBA.currentUser && userId === window.FBA.currentUser.uid;
        html += `
          <div class="legend-item">
            <div class="legend-color" style="background:${stats.color};"></div>
            <div class="legend-name">
              ${escapeHtml(stats.name)}${isCurrentUser ? ' <span style="color:var(--accent);font-size:10px;">(Du)</span>' : ''}
            </div>
            <div class="legend-count">${stats.count}</div>
          </div>
        `;
      });
      
      legendItems.innerHTML = html;
    }
    
    // ---------- Cleanup-Funktion für Testdaten ----------
    async function cleanupTestData() {
      try {
        let foundTestData = false;
        
        // Lösche Test-Ordner
        const testFolderId = 'folder_test';
        const testFolder = await getFromIndexedDB('folders', testFolderId);
        
        if (testFolder) {
          console.log('🧹 Lösche Test-Ordner...');
          await deleteFromIndexedDB('folders', testFolderId);
          foundTestData = true;
        }
        
        // Lösche alle Test-Beobachtungen
        const allObs = await getAllFromIndexedDB('observations');
        for (const obs of allObs) {
          if (obs.folderId === testFolderId || obs.id.startsWith('obs_test_')) {
            console.log('🧹 Lösche Test-Beobachtung:', obs.bird);
            await deleteFromIndexedDB('observations', obs.id);
            foundTestData = true;
          }
        }
        
        if (foundTestData) {
          console.log('✅ Testdaten wurden entfernt');
        } else {
          console.log('ℹ️ Keine Testdaten gefunden');
        }
        
        return foundTestData;
      } catch (error) {
        console.log('ℹ️ Keine Testdaten zum Löschen gefunden:', error);
        return false;
      }
    }
    
    // ---------- Modifizierte Testdaten Funktion ----------
    async function createTestData() {
      try {
        // Erstelle Test-Ordner
        const testFolder = {
          id: 'folder_test',
          name: 'Testdaten',
          color: colorPalette[0],
          createdAt: new Date().toISOString()
        };
        await saveFolderToDB(testFolder);
        
        // Erstelle Test-Beobachtungen
        const testObservations = [
          { bird: "Amsel", date: "2024-05-01", lat: "51.1657", lng: "10.4515" },
          { bird: "Blaumeise", date: "2024-05-03", lat: "51.1672", lng: "10.4531" },
          { bird: "Kohlmeise", date: "2024-05-05", lat: "51.1660", lng: "10.4520" },
          { bird: "Rotkehlchen", date: "2024-05-07", lat: "51.1681", lng: "10.4545" },
          { bird: "Buchfink", date: "2024-05-10", lat: "51.1650", lng: "10.4500" },
          { bird: "Zaunkönig", date: "2024-05-12", lat: "51.1690", lng: "10.4550" }
        ];
        
        for (const obs of testObservations) {
          await saveNewObservationToDB({
            id: 'obs_test_' + Date.now() + '_' + Math.random(),
            ...obs,
            folderId: testFolder.id,
            folderName: testFolder.name,
            folderColor: testFolder.color,
            time: "10:00",
            count: "1",
            behavior: "sitzend",
            weather: "sonnig",
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          });
        }
        
        // Daten neu laden
        await loadData();
        showNotification('✅ Testdaten erstellt! Das Diagramm sollte jetzt Daten anzeigen.', 5000);
        
      } catch (error) {
        console.error('Fehler beim Erstellen der Testdaten:', error);
        showNotification('Fehler beim Erstellen der Testdaten', 3000);
      }
    }
    
    // ---------- Export/Import Funktionen ----------
    async function exportAllData() {
      try {
        const exportData = await exportDatabase();
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `birdcount_backup_${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showNotification('Daten erfolgreich exportiert!', 3000);
      } catch (error) {
        console.error('Export fehlgeschlagen:', error);
        showNotification('Export fehlgeschlagen: ' + error.message, 5000);
      }
    }
    
    async function importData(file) {
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        
        if (confirm('Möchten Sie wirklich alle Daten importieren? Bestehende Daten werden überschrieben!')) {
          const success = await importDatabase(data);
          if (success) {
            await loadData();
            showNotification('Daten erfolgreich importiert!', 3000);
          } else {
            showNotification('Import fehlgeschlagen!', 3000);
          }
        }
      } catch (error) {
        console.error('Import fehlgeschlagen:', error);
        showNotification('Import fehlgeschlagen: Ungültiges Dateiformat', 3000);
      }
    }
    
    // ---------- Gruppen-Import Dialog ----------
    async function showGroupImportDialog(file, importedObservations) {
      try {
        // Prüfe ob Firebase verfügbar ist
        if (!window.FBA || !window.FBD) {
          console.log('Firebase nicht verfügbar - Gruppen-Import übersprungen');
          return;
        }
        
        // Prüfe ob Benutzer angemeldet ist
        const user = window.FBA.currentUser;
        if (!user || !user.email) {
          console.log('Nicht angemeldet - Gruppen-Import übersprungen');
          return;
        }
        
        // Lade verfügbare Gruppen
        const groupsSnapshot = await window.FBD.ref('groups').once('value');
        const allGroups = groupsSnapshot.val() || {};
        
        // Filtere Gruppen, in denen der Benutzer Mitglied ist
        const userGroups = [];
        for (const [groupId, groupData] of Object.entries(allGroups)) {
          if (groupData.members && groupData.members[user.uid]) {
            userGroups.push({
              id: groupId,
              name: groupData.name || 'Unbenannte Gruppe'
            });
          }
        }
        
        if (userGroups.length === 0) {
          console.log('Keine Gruppen gefunden - Gruppen-Import übersprungen');
          return;
        }
        
        // Erstelle Dialog
        const dialogHtml = `
          <div id="groupImportDialog" style="
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 12px 48px rgba(0,0,0,0.5);
            z-index: 10000;
            min-width: 400px;
            max-width: 90vw;
          ">
            <h3 style="margin: 0 0 16px 0; color: var(--text);">Auch in Gruppe importieren?</h3>
            <p style="color: var(--muted); margin: 0 0 16px 0;">
              Du hast ${importedObservations.length} Beobachtungen in deinen privaten Bereich importiert.
              <br><br>
              Möchtest du diese Daten auch in eine deiner Gruppen importieren?
              <br><br>
              <strong>Hinweis:</strong> Die Duplikat-Prüfung gilt nicht zwischen privatem Bereich und Gruppe - 
              deine Beobachtungen werden auch dann importiert, wenn sie bereits privat vorhanden sind.
            </p>
            <select id="groupImportSelect" style="
              width: 100%;
              background: rgba(255,255,255,0.05);
              border: 1px solid rgba(255,255,255,0.1);
              padding: 10px;
              border-radius: 8px;
              color: var(--text);
              margin-bottom: 16px;
              font-size: 14px;
            ">
              <option value="">Wähle eine Gruppe...</option>
              ${userGroups.map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
            </select>
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
              <button onclick="closeGroupImportDialog()" style="
                background: rgba(255,255,255,0.05);
                border: 1px solid rgba(255,255,255,0.1);
                padding: 8px 16px;
                border-radius: 8px;
                color: var(--text);
                cursor: pointer;
                font-weight: 600;
              ">Überspringen</button>
              <button onclick="confirmGroupImport()" style="
                background: var(--accent);
                border: none;
                padding: 8px 16px;
                border-radius: 8px;
                color: white;
                cursor: pointer;
                font-weight: 600;
              ">In Gruppe importieren</button>
            </div>
          </div>
          <div id="groupImportBackdrop" style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
            z-index: 9999;
          " onclick="closeGroupImportDialog()"></div>
        `;
        
        // Füge Dialog zum DOM hinzu
        const dialogContainer = document.createElement('div');
        dialogContainer.innerHTML = dialogHtml;
        document.body.appendChild(dialogContainer);
        
        // Speichere importierte Beobachtungen für späteren Zugriff
        window.pendingGroupImport = {
          file: file,
          observations: importedObservations
        };
        
      } catch (error) {
        console.error('Fehler beim Erstellen des Gruppen-Import-Dialogs:', error);
      }
    }
    
    // Schließe Gruppen-Import Dialog
    window.closeGroupImportDialog = function() {
      const dialog = document.getElementById('groupImportDialog');
      const backdrop = document.getElementById('groupImportBackdrop');
      if (dialog) dialog.parentElement.remove();
      if (backdrop) backdrop.remove();
      delete window.pendingGroupImport;
    };
    
    // Bestätige Gruppen-Import
    window.confirmGroupImport = async function() {
      const select = document.getElementById('groupImportSelect');
      const groupId = select.value;
      
      if (!groupId) {
        showNotification('⚠️ Bitte wähle eine Gruppe aus', 2000);
        return;
      }
      
      // Schließe Dialog
      closeGroupImportDialog();
      
      // Führe Import in Gruppe durch
      if (window.pendingGroupImport) {
        await importToGroup(groupId, window.pendingGroupImport.observations);
        delete window.pendingGroupImport;
      }
    };
    
    // Importiere Beobachtungen in eine Gruppe
    async function importToGroup(groupId, observations) {
      try {
        showNotification('Importiere in Gruppe...', 2000);
        
        const user = window.FBA.currentUser;
        if (!user || !user.email) {
          showNotification('❌ Nicht angemeldet', 3000);
          return;
        }
        
        const currentUserEmail = user.email;
        const userName = user.displayName || currentUserEmail.split('@')[0];
        
        // Lade NUR die rohen Beobachtungen (viel schneller)
        showNotification('Prüfe auf Duplikate...', 1000);
        const groupObsRef = window.FBD.ref(`groups/${groupId}/observations`);
        const snapshot = await groupObsRef.once('value');
        const existingGroupObservations = [];
        
        if (snapshot.exists()) {
          const obsData = snapshot.val();
          Object.values(obsData).forEach(obs => {
            if (obs.tickable !== false) {
              existingGroupObservations.push(obs);
            }
          });
        }
        
        let importCount = 0;
        let duplicateCount = 0;
        const updates = {}; // Für Batch-Update
        const rarityObservations = []; // Für spätere Raritätenpunkte
        
        // Bereite alle Beobachtungen vor (ohne Firebase-Aufrufe)
        for (const obs of observations) {
          // Prüfe auf Duplikate NUR in der Gruppe
          const isDuplicate = existingGroupObservations.some(existing => {
            const latMatch = Math.abs(parseFloat(existing.lat) - obs.lat) < 0.0001;
            const lngMatch = Math.abs(parseFloat(existing.lng) - obs.lng) < 0.0001;
            const birdMatch = existing.bird === obs.bird;
            const dateMatch = existing.date === obs.date;
            return birdMatch && dateMatch && latMatch && lngMatch;
          });
          
          if (isDuplicate) {
            duplicateCount++;
            continue;
          }
          
          // Erstelle neue ID für Gruppe
          const newId = 'obs_group_' + Date.now() + '_' + importCount + '_' + Math.random().toString(36).substr(2, 9);
          const groupObservation = {
            ...obs,
            id: newId,
            createdBy: currentUserEmail,
            userId: user.uid,
            userName: userName,
            userEmail: currentUserEmail,
            // Entferne Ordner-Info (existiert nicht in Gruppen)
            folderId: undefined,
            folderName: undefined,
            folderColor: undefined
          };
          
          // Füge zum Batch-Update hinzu
          updates[`groups/${groupId}/observations/${newId}`] = groupObservation;
          
          // Merke Raritäten für später
          if (groupObservation.rarity && (groupObservation.rarity === 'selten' || groupObservation.rarity === 'sehr selten')) {
            rarityObservations.push(groupObservation);
          }
          
          importCount++;
          
          // Zeige Fortschritt
          if (importCount % 50 === 0) {
            showNotification(`Vorbereitung: ${importCount} Beobachtungen...`, 500);
          }
        }
        
        // Speichere ALLE Beobachtungen auf einmal (Batch-Update)
        if (Object.keys(updates).length > 0) {
          showNotification(`Speichere ${importCount} Beobachtungen...`, 2000);
          await window.FBD.ref().update(updates);
          
          // Füge Raritätenpunkte hinzu (in Batch)
          if (rarityObservations.length > 0) {
            showNotification('Berechne Raritätenpunkte...', 1000);
            const rarityUpdates = {};
            
            for (const obs of rarityObservations) {
              const points = obs.rarity === 'sehr selten' ? 10 : 5;
              const userEmailKey = emailToFirebaseKey(currentUserEmail);
              const pointsPath = `groups/${groupId}/rarityChallenge/users/${userEmailKey}/points`;
              
              // Addiere Punkte (später mit transaction für Genauigkeit)
              if (!rarityUpdates[pointsPath]) {
                // Lade aktuelle Punkte
                const currentPointsSnap = await window.FBD.ref(pointsPath).once('value');
                rarityUpdates[pointsPath] = (currentPointsSnap.val() || 0) + points;
              } else {
                rarityUpdates[pointsPath] += points;
              }
            }
            
            // Speichere alle Punkte auf einmal
            if (Object.keys(rarityUpdates).length > 0) {
              await window.FBD.ref().update(rarityUpdates);
            }
          }
        }
        
        // Erfolgsmeldung
        let message = `✅ ${importCount} Beobachtungen in Gruppe importiert`;
        if (duplicateCount > 0) {
          message += ` (${duplicateCount} Duplikate übersprungen)`;
        }
        showNotification(message, 5000);
        
        // Aktualisiere UI wenn in Gruppenmodus
        const isInGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        if (isInGroupMode && window.currentSelectedGroup === groupId) {
          if (typeof renderRarityChallenge === 'function') {
            await renderRarityChallenge();
          }
          if (typeof renderObservationManager === 'function') {
            await renderObservationManager();
          }
        }
        
      } catch (error) {
        console.error('Fehler beim Gruppen-Import:', error);
        showNotification('❌ Gruppen-Import fehlgeschlagen: ' + error.message, 5000);
      }
    }
    
    // ---------- Hilfsfunktion: Lade Gruppendaten ----------
    async function loadGroupData() {
      return new Promise((resolve, reject) => {
        const groupId = window.currentSelectedGroup;
        const groupRef = window.FBD.ref(`groups/${groupId}`);
        
        groupRef.once('value', (snapshot) => {
          const data = snapshot.val();
          if (!data) {
            reject(new Error('Keine Gruppendaten gefunden'));
            return;
          }
          
          // Verarbeite Beobachtungen nach Benutzer
          const userStats = {};
          const observations = data.observations || {};
          const members = data.members || {}; // Aktuelle Gruppenmitglieder
          
          Object.entries(observations).forEach(([obsId, obs]) => {
            // WICHTIG: Filtere nicht-tickbare Arten heraus
            if (obs.tickable === false) return;
            
            const userId = obs.userId || 'unknown';
            
            // NEU: Überspringe Beobachtungen von Benutzern, die nicht mehr in der Gruppe sind
            if (!members[userId]) {
              return;
            }
            
            if (!userStats[userId]) {
              userStats[userId] = {
                userId: userId,
                userName: obs.userName || members[userId]?.name || 'Unbekannt',
                userEmail: obs.userEmail || members[userId]?.email || '',
                observations: [],
                species: new Set(),
                photosCount: 0,
                totalCount: 0
              };
            }
            
            // NEU: Füge die ObservationID hinzu, damit manuallyBlocked/manuallyUnblocked Flags funktionieren
            const obsWithId = {
              ...obs,
              id: obsId,
              // Stelle sicher dass die manual Block/Unblock Flags übernommen werden
              manuallyBlocked: obs.manuallyBlocked || false,
              manuallyUnblocked: obs.manuallyUnblocked || false
            };
            
            userStats[userId].observations.push(obsWithId);
            userStats[userId].species.add(obs.bird);
            if (obs.photo) userStats[userId].photosCount++;
            userStats[userId].totalCount++;
          });
          
          // Konvertiere Set zu Array
          Object.values(userStats).forEach(user => {
            user.speciesCount = user.species.size;
            user.species = Array.from(user.species);
          });
          
          resolve({
            groupInfo: {
              name: data.name || 'Unbenannte Gruppe',
              members: data.members || {}
            },
            userStats: userStats,
            rawObservations: observations
          });
        }, (error) => {
          reject(error);
        });
      });
    }
    
    // ---------- Ornitho.de Import ----------
    async function importOrnithoData(file) {
      try {
        showNotification('Lese Ornitho.de Datei...', 2000);
        
        // Initialisiere Batch-Arrays
        window.batchObservations = [];
        window.batchRarities = [];
        
        // NEU: Prüfe ob im Gruppenmodus
        const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        let currentUserEmail = null;
        let groupId = null;
        
        if (isGroupMode) {
          try {
            const user = window.FBA.currentUser;
            if (!user || !user.email) {
              showNotification('❌ Nicht angemeldet', 3000);
              return;
            }
            currentUserEmail = user.email;
            groupId = window.currentSelectedGroup;
            console.log('Importiere Ornitho-Daten für Benutzer:', currentUserEmail, 'in Gruppe:', groupId);
          } catch (error) {
            console.error('Fehler beim Abrufen des Benutzers:', error);
            showNotification('❌ Fehler: ' + error.message, 3000);
            return;
          }
        }
        
        const text = await file.text();
        const lines = text.split('\n');
        
        if (lines.length < 3) {
          throw new Error('Datei ist zu kurz oder ungültig');
        }
        
        // Parse Header
        const headers = lines[0].split('\t');
        
        // Finde wichtige Spalten-Indizes
        const getColumnIndex = (name) => headers.findIndex(h => h === name);
        
        const indices = {
          species: getColumnIndex('NAME_SPECIES'),
          latin: getColumnIndex('LATIN_SPECIES'),
          date: getColumnIndex('DATE'),
          time: getColumnIndex('TIMING'),
          lat: getColumnIndex('COORD_LAT'),
          lon: getColumnIndex('COORD_LON'),
          count: getColumnIndex('TOTAL_COUNT'),
          place: getColumnIndex('PLACE'),
          state: getColumnIndex('COUNTRY'),
          accuracy: getColumnIndex('ESTIMATION_CODE'),
          altitude: getColumnIndex('ALTITUDE'),
          comment: getColumnIndex('COMMENT'),
          // NEU: Foto-URL falls vorhanden
          photoUrl: getColumnIndex('PHOTO_URL'),
          photoPath: getColumnIndex('PHOTO_PATH'),
          hasPhoto: getColumnIndex('HAS_PHOTO')
        };
        
        // Prüfe ob wichtige Spalten vorhanden sind
        if (indices.species === -1 || indices.date === -1 || indices.lat === -1 || indices.lon === -1) {
          throw new Error('Wichtige Spalten fehlen in der Datei');
        }
        
        // Erstelle oder finde Ornitho.de Import-Ordner (nur im lokalen Modus)
        let importFolder = null;
        if (!isGroupMode) {
          importFolder = await getFromIndexedDB('folders', 'folder_ornitho_import');
          
          if (!importFolder) {
            importFolder = {
              id: 'folder_ornitho_import',
              name: 'Ornitho.de Import',
              color: '#8b5cf6',
              createdAt: new Date().toISOString()
            };
            await saveToIndexedDB('folders', importFolder);
          }
        }
        
        let importCount = 0;
        let skipCount = 0;
        let duplicateCount = 0;
        
        // NEU: Detaillierte Statistiken für ungültige Beobachtungen
        const invalidReasons = {
          missingFields: [],
          speciesNotInDatabase: [],
          invalidDate: []
        };
        
        // NEU: Lade existierende Beobachtungen abhängig vom Modus
        let existingObservations = [];
        // NEU: Erstelle Hash-Map für schnellere Duplikats-Prüfung
        const existingObsMap = new Map();
        
        if (isGroupMode) {
          // In Gruppenmodus: Lade NUR die rohen Beobachtungen (viel schneller!)
          showNotification('Prüfe auf Duplikate...', 1000);
          const groupObsRef = window.FBD.ref(`groups/${groupId}/observations`);
          const snapshot = await groupObsRef.once('value');
          
          if (snapshot.exists()) {
            const obsData = snapshot.val();
            existingObservations = Object.values(obsData).filter(obs => obs.tickable !== false);
            
            // Erstelle Hash-Map für schnelle Lookups
            existingObservations.forEach(obs => {
              const key = `${obs.bird}|${obs.date}|${parseFloat(obs.lat).toFixed(4)}|${parseFloat(obs.lng).toFixed(4)}`;
              existingObsMap.set(key, true);
            });
          }
          console.log(`📊 Prüfe auf Duplikate gegen ${existingObservations.length} existierende Gruppen-Beobachtungen`);
        } else {
          // In lokalem Modus: Lade Beobachtungen aus IndexedDB
          existingObservations = await getAllFromIndexedDB('observations');
          
          // Erstelle Hash-Map für schnelle Lookups
          existingObservations.forEach(obs => {
            const key = `${obs.bird}|${obs.date}|${parseFloat(obs.lat).toFixed(4)}|${parseFloat(obs.lng).toFixed(4)}`;
            existingObsMap.set(key, true);
          });
          
          console.log(`📊 Prüfe auf Duplikate gegen ${existingObservations.length} existierende Beobachtungen`);
        }
        
        // Parse Beobachtungen (ab Zeile 2, Zeile 1 ist deutscher Header)
        for (let i = 2; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          const values = line.split('\t');
          
          // Extrahiere Daten
          const species = values[indices.species] || '';
          const dateStr = values[indices.date] || '';
          const timeStr = values[indices.time] || '';
          const lat = values[indices.lat];
          const lon = values[indices.lon];
          const count = values[indices.count] || '';
          const place = values[indices.place] || '';
          const state = values[indices.state] || '';
          const altitude = values[indices.altitude] || '';
          const comment = values[indices.comment] || '';
          
          // NEU: Extrahiere Foto-URL falls vorhanden
          let photoUrl = '';
          if (indices.photoUrl !== -1 && values[indices.photoUrl]) {
            photoUrl = values[indices.photoUrl];
          } else if (indices.photoPath !== -1 && values[indices.photoPath]) {
            // Falls nur ein Pfad vorhanden ist, konstruiere die vollständige URL
            photoUrl = values[indices.photoPath];
            if (photoUrl && !photoUrl.startsWith('http')) {
              photoUrl = 'https://www.ornitho.de' + (photoUrl.startsWith('/') ? '' : '/') + photoUrl;
            }
          }
          
          // Zähle Fotos
          if (!window.photoImportCount) window.photoImportCount = 0;
          if (photoUrl) window.photoImportCount++;
          
          // Überspringe ungültige Einträge
          if (!species || !dateStr || !lat || !lon) {
            skipCount++;
            if (species) {
              invalidReasons.missingFields.push(species);
            } else {
              invalidReasons.missingFields.push(`Zeile ${i} (kein Artname)`);
            }
            continue;
          }
          
          // NEU: Überspringe Nullmeldungen (Anzahl = 0)
          // Diese sollen nicht in Challenges, Listen oder Analysen einfließen
          const countNum = parseInt(count) || 0;
          const isNullmeldung = countNum === 0 || count === '0';
          
          if (isNullmeldung) {
            skipCount++;
            console.log(`⚠️ Nullmeldung übersprungen: ${species} (${dateStr})`);
            continue;
          }
          
          // GEÄNDERT: Importiere ALLE Arten, auch wenn sie nicht in der Vogeldatenbank sind
          // Warnung ausgeben wenn Art nicht bekannt ist
          if (!birdDatabase[species]) {
            console.warn(`⚠️ Art "${species}" nicht in Vogeldatenbank - wird trotzdem importiert`);
          }
          
          // Konvertiere Datum von DD.MM.YYYY zu YYYY-MM-DD
          let isoDate = '';
          try {
            const dateParts = dateStr.split('.');
            if (dateParts.length === 3) {
              isoDate = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
            }
          } catch (e) {
            console.warn('Ungültiges Datum:', dateStr);
            skipCount++;
            invalidReasons.invalidDate.push(`${species} (${dateStr})`);
            continue;
          }
          
          // Erstelle Beobachtung
          const observation = {
            id: 'obs_ornitho_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            bird: species,
            date: isoDate,
            time: timeStr,
            lat: parseFloat(lat),
            lng: parseFloat(lon),
            count: count,
            state: state,
            weather: '',
            behavior: comment ? `Import: ${comment}` : `Importiert von ornitho.de - ${place}`,
            photo: photoUrl, // NEU: Foto-URL aus Ornitho-Export
            userName: getUserNameForObservation(), // NEU: Benutzername hinzufügen
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            source: 'ornitho.de',
            // NEU: Seltenheitsinformationen aus der Vogeldatenbank übernehmen
            rarity: birdDatabase[species]?.status || null,
            // NEU: Standard-Flags für importierte Beobachtungen
            tickable: true,
            selffound: window.ornithoImportSelffound || false  // Nutze Benutzer-Auswahl aus Dialog
          };
          
          // Füge Ordner-Info nur im lokalen Modus hinzu
          if (!isGroupMode && importFolder) {
            observation.folderId = importFolder.id;
            observation.folderName = importFolder.name;
            observation.folderColor = importFolder.color;
          }
          
          // NEU: Prüfe auf Duplikate (gleiche Art, Datum und Koordinaten) - optimiert mit Hash-Map
          const obsKey = `${species}|${isoDate}|${parseFloat(lat).toFixed(4)}|${parseFloat(lon).toFixed(4)}`;
          const isDuplicate = existingObsMap.has(obsKey);
          
          if (isDuplicate) {
            duplicateCount++;
            skipCount++;
            continue; // Überspringe diese Beobachtung
          }
          
          // Füge zur Hash-Map hinzu, damit spätere Duplikate erkannt werden
          existingObsMap.set(obsKey, true);
          
          // NEU: Speichere abhängig vom Modus (IndexedDB oder Firebase)
          if (isGroupMode) {
            // Firebase-Modus: Sammle für Batch-Update
            const user = window.FBA.currentUser;
            observation.createdBy = currentUserEmail;
            observation.userId = user.uid;
            observation.userName = user.displayName || currentUserEmail.split('@')[0];
            observation.userEmail = currentUserEmail;
            
            // Speichere für später (wird am Ende als Batch gespeichert)
            if (!window.batchObservations) window.batchObservations = [];
            if (!window.batchRarities) window.batchRarities = [];
            
            window.batchObservations.push(observation);
            
            // Merke Raritäten für später
            if (observation.rarity && (observation.rarity === 'selten' || observation.rarity === 'sehr selten')) {
              window.batchRarities.push(observation);
            }
          } else {
            // Lokaler Modus: Speichere direkt in IndexedDB
            await saveToIndexedDB('observations', observation);
          }
          
          importCount++;
          
          // Zeige Fortschritt alle 25 Einträge (häufiger für besseres Feedback)
          if (importCount % 25 === 0) {
            showNotification(`${importCount} Beobachtungen vorbereitet...`, 300);
          }
        }
        
        // NEU: Speichere alle Firebase-Beobachtungen in Chunks (für bessere Performance)
        if (isGroupMode && window.batchObservations && window.batchObservations.length > 0) {
          const totalObservations = window.batchObservations.length;
          const CHUNK_SIZE = 50; // Speichere 50 Beobachtungen pro Batch
          const totalChunks = Math.ceil(totalObservations / CHUNK_SIZE);
          
          // Zeige Progress-Overlay
          showImportProgress(0, totalObservations);
          
          try {
            let savedCount = 0;
            
            // Speichere in Chunks
            for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
              const start = chunkIndex * CHUNK_SIZE;
              const end = Math.min(start + CHUNK_SIZE, totalObservations);
              const chunk = window.batchObservations.slice(start, end);
              
              // Erstelle Update-Objekt für diesen Chunk
              const updates = {};
              for (const obs of chunk) {
                // NEU: Entferne undefined Werte für Firebase
                const cleanedObs = removeUndefinedFields(obs);
                updates[`groups/${groupId}/observations/${obs.id}`] = cleanedObs;
              }
              
              // Speichere Chunk
              await window.FBD.ref().update(updates);
              
              savedCount += chunk.length;
              
              // Update Progress
              const progress = Math.round((savedCount / totalObservations) * 100);
              updateImportProgress(progress, savedCount, totalObservations, 
                `Chunk ${chunkIndex + 1}/${totalChunks} gespeichert`);
              
              // Kurze Pause zwischen Chunks um UI responsive zu halten
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Füge Raritätenpunkte hinzu
            if (window.batchRarities.length > 0) {
              updateImportProgress(100, savedCount, totalObservations, 'Berechne Raritätenpunkte...');
              
              let totalPoints = 0;
              for (const obs of window.batchRarities) {
                totalPoints += obs.rarity === 'sehr selten' ? 10 : 5;
              }
              
              // Lade aktuelle Punkte
              const userEmailKey = emailToFirebaseKey(currentUserEmail);
              const pointsRef = window.FBD.ref(`groups/${groupId}/rarityChallenge/users/${userEmailKey}/points`);
              const currentPointsSnap = await pointsRef.once('value');
              const currentPoints = currentPointsSnap.val() || 0;
              
              // Setze neue Punkte
              await pointsRef.set(currentPoints + totalPoints);
            }
            
            // Verstecke Progress nach kurzer Verzögerung
            setTimeout(() => {
              hideImportProgress();
            }, 1000);
            
          } catch (error) {
            hideImportProgress();
            throw error;
          }
          
          // Cleanup
          delete window.batchObservations;
          delete window.batchRarities;
        }
        
        // Aktualisiere UI
        if (!isGroupMode) {
          await loadData();
          await initFolderSelect();
          updateMarkersFromData();
          updateChart();
          updateAdvancedStatistics();
          updateDashboard();
          await updateQuickStats();
          
          // NEU: Synchronisiere geteilte Listen (nur im lokalen Modus)
          await syncSharedListsAfterNewObservation();
        } else {
          // Im Gruppenmodus: Raritäten-Challenge aktualisieren
          if (typeof renderRarityChallenge === 'function') {
            await renderRarityChallenge();
          }
          if (typeof renderObservationManager === 'function') {
            await renderObservationManager();
          }
        }
        
        // Erstelle detaillierte Erfolgsmeldung
        let message = `✅ Import erfolgreich! ${importCount} Beobachtungen importiert`;
        
        // NEU: Zeige Foto-Import-Statistik
        const photoCount = window.photoImportCount || 0;
        if (photoCount > 0) {
          message += ` (inkl. ${photoCount} Foto${photoCount > 1 ? 's' : ''})`;
        }
        
        if (isGroupMode) {
          message += ` für ${currentUserEmail}`;
        }
        
        if (duplicateCount > 0) {
          message += `, ${duplicateCount} Duplikate übersprungen`;
        }
        
        const invalidSkipped = skipCount - duplicateCount;
        if (invalidSkipped > 0) {
          message += `, ${invalidSkipped} ungültige übersprungen`;
        }
        
        message += '.';
        
        showNotification(message, 5000);
        console.log(`📊 Import-Statistik: ${importCount} neu, ${duplicateCount} Duplikate, ${invalidSkipped} ungültig, ${photoCount} Fotos`);
        
        // Cleanup
        delete window.photoImportCount;
        
        // NEU: Detaillierte Console-Ausgabe für ungültige Beobachtungen
        if (invalidSkipped > 0) {
          console.group('❌ Details zu ungültigen Beobachtungen:');
          
          if (invalidReasons.speciesNotInDatabase.length > 0) {
            console.warn(`🦅 ${invalidReasons.speciesNotInDatabase.length} Arten nicht in Vogeldatenbank gefunden:`);
            // Zeige nur eindeutige Arten
            const uniqueSpecies = [...new Set(invalidReasons.speciesNotInDatabase)];
            uniqueSpecies.forEach(species => console.log(`   - ${species}`));
          }
          
          if (invalidReasons.missingFields.length > 0) {
            console.warn(`📋 ${invalidReasons.missingFields.length} Beobachtungen mit fehlenden Pflichtfeldern:`);
            const uniqueMissing = [...new Set(invalidReasons.missingFields)];
            uniqueMissing.slice(0, 5).forEach(entry => console.log(`   - ${entry}`));
            if (uniqueMissing.length > 5) console.log(`   ... und ${uniqueMissing.length - 5} weitere`);
          }
          
          if (invalidReasons.invalidDate.length > 0) {
            console.warn(`📅 ${invalidReasons.invalidDate.length} Beobachtungen mit ungültigem Datum:`);
            const uniqueDates = [...new Set(invalidReasons.invalidDate)];
            uniqueDates.slice(0, 5).forEach(entry => console.log(`   - ${entry}`));
            if (uniqueDates.length > 5) console.log(`   ... und ${uniqueDates.length - 5} weitere`);
          }
          
          console.groupEnd();
          
          // NEU: Zeige Hinweis-Notification bei Arten nicht in Datenbank
          if (invalidReasons.speciesNotInDatabase.length > 0) {
            setTimeout(() => {
              showNotification(`ℹ️ ${invalidReasons.speciesNotInDatabase.length} Arten nicht in Datenbank. Siehe Console (F12) für Details.`, 5000);
            }, 5500);
          }
        }
        
        // NEU: Zeige spezielle Info bei Raritäten im Gruppenmodus
        if (isGroupMode) {
          const rarityImported = importCount > 0; // Vereinfachte Prüfung
          if (rarityImported) {
            setTimeout(() => {
              showNotification('💎 Raritätenpunkte werden automatisch berechnet', 3000);
            }, 2000);
          }
        }
        
        // NEU: Frage nach Gruppen-Import (nur im privaten Modus)
        if (!isGroupMode && importCount > 0) {
          // Verzögere den Dialog, damit die Erfolgsmeldung sichtbar ist
          setTimeout(() => {
            showGroupImportDialog(file, existingObservations.slice(-importCount));
          }, 2000);
        }
        
        // Cleanup Import-Optionen
        delete window.ornithoImportSelffound;
        
      } catch (error) {
        console.error('Ornitho.de Import fehlgeschlagen:', error);
        showNotification('❌ Import fehlgeschlagen: ' + error.message, 5000);
        
        // Cleanup
        delete window.batchObservations;
        delete window.batchRarities;
        delete window.ornithoImportSelffound;
      }
    }
    
    // Event Listener für Ornitho.de Import
    document.getElementById('ornithoImportFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        // Prüfe ob im Gruppenmodus
        const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
        
        // Zeige Import-Optionen-Dialog
        showOrnithoImportOptions(file, isGroupMode);
        
        // Reset file input
        this.value = '';
      }
    });
    
    // NEU: Zeige Import-Optionen Dialog
    function showOrnithoImportOptions(file, isGroupMode) {
      const dialogHtml = `
        <div id="ornithoImportDialog" style="
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: var(--card);
          border: 1px solid rgba(255,255,255,0.1);
          border-radius: 16px;
          padding: 24px;
          box-shadow: 0 12px 48px rgba(0,0,0,0.5);
          z-index: 10000;
          min-width: 450px;
          max-width: 90vw;
        ">
          <h3 style="margin: 0 0 16px 0; color: var(--text);">🦅 Ornitho.de Import</h3>
          
          <div style="background: rgba(255,255,255,0.03); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
            <div style="font-size: 14px; color: var(--text); margin-bottom: 4px;">
              <strong>Datei:</strong> ${file.name}
            </div>
            ${isGroupMode ? `
              <div style="font-size: 13px; color: var(--muted);">
                Import in aktuelle Gruppe
              </div>
            ` : `
              <div style="font-size: 13px; color: var(--muted);">
                Import in Ordner "Ornitho.de Import"
              </div>
            `}
          </div>
          
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--text); font-size: 14px;">Import-Optionen:</h4>
            
            <label style="
              display: flex;
              align-items: flex-start;
              gap: 10px;
              padding: 12px;
              background: rgba(255,255,255,0.02);
              border-radius: 8px;
              cursor: pointer;
              border: 1px solid rgba(255,255,255,0.05);
              transition: all 0.2s;
            " onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='rgba(255,255,255,0.02)'">
              <input type="checkbox" id="ornithoSelffoundOption" style="margin-top: 2px; cursor: pointer;" />
              <div style="flex: 1;">
                <div style="color: var(--text); font-weight: 600; margin-bottom: 4px;">
                  👤 Als "selbst gefunden" markieren
                </div>
                <div style="color: var(--muted); font-size: 12px; line-height: 1.4;">
                  Aktiviere diese Option nur, wenn <strong>alle</strong> Beobachtungen in dieser Datei 
                  von dir selbst entdeckt wurden. Wenn die Datei auch Beobachtungen von anderen 
                  Personen enthält, lasse diese Option deaktiviert.
                </div>
              </div>
            </label>
          </div>
          
          <div style="font-size: 12px; color: var(--muted); padding: 10px; background: rgba(124,58,237,0.1); border-radius: 6px; margin-bottom: 16px;">
            💡 <strong>Tipp:</strong> Du kannst die Markierung später im Beobachtungs-Manager für einzelne 
            Beobachtungen ändern.
          </div>
          
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button onclick="closeOrnithoImportDialog()" style="
              background: rgba(255,255,255,0.05);
              border: 1px solid rgba(255,255,255,0.1);
              padding: 10px 20px;
              border-radius: 8px;
              color: var(--text);
              cursor: pointer;
              font-weight: 600;
            ">Abbrechen</button>
            <button onclick="startOrnithoImport()" style="
              background: var(--accent);
              border: none;
              padding: 10px 20px;
              border-radius: 8px;
              color: white;
              cursor: pointer;
              font-weight: 600;
            ">Importieren</button>
          </div>
        </div>
        <div id="ornithoImportBackdrop" style="
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          backdrop-filter: blur(4px);
          z-index: 9999;
        " onclick="closeOrnithoImportDialog()"></div>
      `;
      
      const dialogContainer = document.createElement('div');
      dialogContainer.innerHTML = dialogHtml;
      document.body.appendChild(dialogContainer);
      
      // Speichere Datei für späteren Import
      window.pendingOrnithoImport = { file, isGroupMode };
    }
    
    // Schließe Ornitho Import Dialog
    window.closeOrnithoImportDialog = function() {
      const dialog = document.getElementById('ornithoImportDialog');
      const backdrop = document.getElementById('ornithoImportBackdrop');
      if (dialog) dialog.parentElement.remove();
      if (backdrop) backdrop.remove();
      delete window.pendingOrnithoImport;
    };
    
    // Starte Ornitho Import mit Optionen
    window.startOrnithoImport = function() {
      if (!window.pendingOrnithoImport) return;
      
      const selffoundOption = document.getElementById('ornithoSelffoundOption').checked;
      const { file, isGroupMode } = window.pendingOrnithoImport;
      
      // Speichere Option für Import-Funktion
      window.ornithoImportSelffound = selffoundOption;
      
      closeOrnithoImportDialog();
      
      // Starte Import
      importOrnithoData(file);
    };
    
    // ---------- Legacy Funktionen (für Kompatibilität) ----------
    function saveData() {
      // Diese Funktion bleibt für Kompatibilität, aber speichert jetzt in IndexedDB
      console.log('saveData aufgerufen - speichere alle Beobachtungen');
      
      // Sammle alle Beobachtungen aus der UI und speichere sie
      document.querySelectorAll('.folder').forEach(async (folder) => {
        const folderId = folder.dataset.folderId;
        const folderName = folder.querySelector('h3').textContent;
        const folderColor = folder.style.borderLeftColor || colorPalette[0];
        
        // Speichere Ordner
        await saveFolderToDB({
          id: folderId,
          name: folderName,
          color: folderColor,
          createdAt: new Date().toISOString()
        });
        
        // Speichere Beobachtungen
        folder.querySelectorAll('tr[data-id]').forEach(async (row) => {
          await saveObservationFromRow(row);
        });
      });
      
      // Aktualisiere UI
      updateMarkersFromData();
      updateChart();
      updateAdvancedStatistics();
      updateDashboard();
      updateStorageInfo();
    }
    
    function createTableRow(id, bird, date, lat, lng) {
      const tr = document.createElement('tr');
      tr.setAttribute('data-id', id);
      
      tr.innerHTML = `
        <td><input type="text" class="bird-input" value="${escapeHtml(bird)}" placeholder="Vogelart" /></td>
        <td><input type="date" value="${date}" /></td>
        <td>
          <div style="display:flex;gap:4px;align-items:center;">
            <input type="text" class="lat-input" value="${lat}" placeholder="Lat" style="width:80px;font-family:monospace;" />
            <input type="text" class="lng-input" value="${lng}" placeholder="Lng" style="width:80px;font-family:monospace;" />
            <span class="map-point-indicator" onclick="setMapPointForRow(this)" title="Punkt auf Karte setzen">🗺️</span>
          </div>
        </td>
        <td><button class="small-btn" onclick="removeRow(this)" style="background:var(--danger);">🗑️</button></td>
      `;
      
      // Farbe des Vogel-Inputs setzen
      const birdInput = tr.querySelector('.bird-input');
      if (birdInput) {
        updateBirdInputColor(birdInput);
        birdInput.addEventListener('input', function() {
          updateBirdInputColor(this);
        });
      }
      
      return tr;
    }
    
    // Funktion zum Aktualisieren der Farbe des Vogel-Input-Feldes
    function updateBirdInputColor(input) {
      const birdName = input.value.trim();
      if (birdName && birdDatabase[birdName]) {
        const rarity = getRarityStyle(birdName);
        const species = birdDatabase[birdName];
        
        // Farbe basierend auf Status setzen
        if (species.status && species.status.toLowerCase() === 'escape') {
          input.style.color = '#3b82f6'; // Blau für Escape
          input.style.fontWeight = '600';
        } else if (species.status === 'sehr selten') {
          input.style.color = '#dc2626'; // Dunkelrot für sehr selten
          input.style.fontWeight = '700';
        } else if (species.status === 'selten') {
          input.style.color = '#ef4444'; // Rot für selten
          input.style.fontWeight = '600';
        } else {
          input.style.color = 'var(--text)'; // Standard
          input.style.fontWeight = '400';
        }
      } else {
        input.style.color = 'var(--text)'; // Standard
        input.style.fontWeight = '400';
      }
    }
    
    // KORRIGIERT: removeRow Funktion
    async function removeRow(btn) {
      const row = btn.closest('tr');
      const id = row.getAttribute('data-id');
      
      if (!id) {
        row.remove();
        return;
      }
      
      try {
        // 1. Marker von der Karte entfernen, falls vorhanden
        if (window.markers.has(id)) {
          const marker = window.markers.get(id);
          if (marker) {
            // Aus dem Cluster entfernen
            if (markerCluster) {
              markerCluster.removeLayer(marker);
            }
            // Von der Karte entfernen
            marker.remove();
            // Aus der Map entfernen
            window.markers.delete(id);
          }
        }
        
        // 2. Aus IndexedDB löschen
        await deleteObservationFromDB(id);
        
        // 3. Zeile entfernen
        row.remove();
        
        // 4. UI aktualisieren
        updateMarkerList();
        updateDashboard();
        updateChart();
        updateAdvancedStatistics();
        
        showNotification('Beobachtung gelöscht!', 2000);
      } catch (error) {
        console.error('Fehler beim Löschen:', error);
        showNotification('Fehler beim Löschen', 3000);
      }
    }
    
    function attachFolderListeners(folder) {
      folder.querySelector('h3').addEventListener('input', saveData);
      folder.querySelectorAll('.mapbox').forEach(m => attachMapListeners(m));
    }
    
    function attachMapListeners(map) {
      map.querySelector('h4').addEventListener('input', saveData);
      map.querySelectorAll('input').forEach(inp => {
        if (!inp._listenerAttached) {
          inp.addEventListener('input', saveData);
          inp._listenerAttached = true;
        }
      });
    }
    
    async function addFolder() {
      try {
        const foldersDiv = document.getElementById('folders');
        const folders = document.querySelectorAll('.folder');
        const nextColorIndex = folders.length % colorPalette.length;
        const color = colorPalette[nextColorIndex];
        
        const folderId = 'folder_' + Date.now();
        const folder = document.createElement('div');
        folder.className = 'folder card';
        folder.dataset.folderId = folderId;
        folder.style.marginTop = '12px';
        folder.style.borderLeft = `4px solid ${color}`;
        
        folder.innerHTML = `
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
            <div class="folder-color-indicator" style="width:16px;height:16px;border-radius:4px;background:${color};cursor:pointer;" onclick="changeFolderColor('${folderId}')" title="Farbe ändern"></div>
            <h3 contenteditable="true" style="margin:0;flex:1;">Neuer Ordner</h3>
          </div>
          <div class="maps"></div>
          <div style="margin-top:8px;display:flex;gap:8px;">
            <button class="small-btn" onclick="addMap(this)">➕ Neue Mappe</button>
            <button class="small-btn" onclick="removeFolder(this)">🗑️ Ordner löschen</button>
          </div>`;
        
        foldersDiv.appendChild(folder);
        folderColors[folderId] = color;
        attachFolderListeners(folder);
        
        // Speichere Ordner in IndexedDB
        await saveFolderToDB({
          id: folderId,
          name: 'Neuer Ordner',
          color: color,
          createdAt: new Date().toISOString()
        });
        
        // NEU: Ordnerauswahl aktualisieren
        await initFolderSelect();
        
        // Ordner wird leer erstellt - Nutzer muss manuell "Neue Mappe" klicken
        saveData();
        showNotification('Neuer Ordner erstellt!', 3000);
      } catch (error) {
        console.error('Fehler beim Hinzufügen des Ordners:', error);
        showNotification('Fehler beim Hinzufügen des Ordners', 3000);
      }
    }
    
    async function changeFolderColor(folderId) {
      const folder = document.querySelector(`[data-folder-id="${folderId}"]`);
      if (!folder) return;
      
      const currentColor = folderColors[folderId] || colorPalette[0];
      const currentIndex = colorPalette.indexOf(currentColor);
      const nextIndex = (currentIndex + 1) % colorPalette.length;
      const newColor = colorPalette[nextIndex];
      
      // Farbe aktualisieren
      folderColors[folderId] = newColor;
      folder.style.borderLeftColor = newColor;
      folder.querySelector('.folder-color-indicator').style.background = newColor;
      
      // Ordner in IndexedDB aktualisieren
      try {
        const folderData = await getFromIndexedDB('folders', folderId);
        if (folderData) {
          folderData.color = newColor;
          folderData.updatedAt = new Date().toISOString();
          await saveToIndexedDB('folders', folderData);
        }
      } catch (error) {
        console.error('Fehler beim Aktualisieren der Ordnerfarbe:', error);
      }
      
      saveData();
      if (chart) updateChart(); // Diagramm neu zeichnen
    }
    
    // KORRIGIERT: removeFolder Funktion mit Synchronisation der Ordnerauswahl
    async function removeFolder(btn) {
      const folder = btn.closest('.folder');
      const folderId = folder.dataset.folderId;
      
      if (confirm('Möchten Sie diesen Ordner wirklich löschen? Alle Beobachtungen in diesem Ordner werden ebenfalls gelöscht.')) {
        if (folderId && folderColors[folderId]) {
          delete folderColors[folderId];
        }
        
        // Lösche Ordner aus IndexedDB
        try {
          await deleteFromIndexedDB('folders', folderId);
          
          // Lösche alle Beobachtungen dieses Ordners
          const observations = await getAllFromIndexedDB('observations');
          const folderObservations = observations.filter(obs => obs.folderId === folderId);
          
          for (const obs of folderObservations) {
            await deleteObservationFromDB(obs.id);
          }
          
          // NEU: Ordnerauswahl aktualisieren
          await initFolderSelect();
          
          // Ordner aus UI entfernen
          folder.remove();
          
          // Dashboard und Statistiken aktualisieren
          updateDashboard();
          updateChart();
          updateAdvancedStatistics();
          
          showNotification('Ordner erfolgreich gelöscht!', 3000);
          
        } catch (error) {
          console.error('Fehler beim Löschen des Ordners:', error);
          showNotification('Fehler beim Löschen des Ordners', 3000);
        }
      }
    }
    
    function addMap(btn) {
      const mapsDiv = btn.closest('.folder').querySelector('.maps');
      const map = createMapElement();
      mapsDiv.appendChild(map);
      saveData();
    }
    
    function removeMap(btn) {
      btn.closest('.mapbox').remove();
      saveData();
    }
    
    function addRow(btn) {
      const tbody = btn.closest('.mapbox').querySelector('tbody');
      const tr = createTableRow('obs_' + Date.now(), '', '', '', '');
      tbody.appendChild(tr);
      attachMapListeners(btn.closest('.mapbox'));
      saveData();
    }
    
    function setMapPointForRow(element) {
      const row = element.closest('tr');
      activeRowForMapClick = row;
      
      showNotification('Klicke jetzt auf die Karte, um den Punkt zu setzen.');
      document.querySelector('.nav button[data-page="karte"]').click();
    }
    
    function createMapElement(name = 'Neue Mappe', rows = []) {
      const map = document.createElement('div');
      map.className = 'mapbox';
      map.style.marginTop = '8px';
      map.innerHTML = `
        <h4 contenteditable="true">${escapeHtml(name)}</h4>
        <table class="input-table">
          <thead>
            <tr>
              <th>Vogelart</th>
              <th>Datum</th>
              <th>Koordinaten</th>
              <th style="width:40px;"></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div style="margin-top:8px;display:flex;gap:8px;">
          <button class="small-btn" onclick="addRow(this)">➕ Zeile</button>
          <button class="small-btn" onclick="removeMap(this)">🗑️ Mappe löschen</button>
        </div>`;
      
      const tbody = map.querySelector('tbody');
      
      if (rows && rows.length) {
        rows.forEach(row => {
          const tr = createTableRow(row.id, row.bird || '', row.date || '', row.lat || '', row.lng || '');
          // Zusätzliche Daten in Input-Felder setzen
          if (row.time) tr.cells[0].querySelector('input').setAttribute('data-time', row.time);
          if (row.count) tr.cells[0].querySelector('input').setAttribute('data-count', row.count);
          if (row.behavior) tr.cells[0].querySelector('input').setAttribute('data-behavior', row.behavior);
          if (row.weather) tr.cells[0].querySelector('input').setAttribute('data-weather', row.weather);
          if (row.photo) tr.cells[0].querySelector('input').setAttribute('data-photo', row.photo);
          tbody.appendChild(tr);
        });
      } else {
        const tr = createTableRow('obs_' + Date.now(), '', '', '', '');
        tbody.appendChild(tr);
      }
      
      attachMapListeners(map);
      return map;
    }

    // Initialisiere die Karte beim Laden
    window.onload = function() {
      if (!window.mapObj) {
        initMap();
      }
    };
  </script>

<!-- ==================== FIREBASE CLOUD-SYNC ==================== -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

<style>
.fbModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(2,6,23,0.98);backdrop-filter:blur(12px);display:none;align-items:center;justify-content:center;z-index:999999;padding:20px}
.fbModal.show{display:flex}
.fbBox{background:var(--card);padding:48px;border-radius:24px;max-width:440px;width:100%;border:1px solid rgba(255,255,255,0.08);box-shadow:0 24px 60px rgba(0,0,0,0.6)}
.fbLogo{width:80px;height:80px;margin:0 auto 20px;background:linear-gradient(135deg,#06b6d4,#7c3aed);border-radius:20px;display:flex;align-items:center;justify-content:center;font-size:40px}
.fbTitle{font-size:26px;font-weight:700;margin:0 0 8px;text-align:center;background:linear-gradient(135deg,#06b6d4,#7c3aed);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.fbSub{color:var(--muted);text-align:center;margin-bottom:28px;font-size:14px}
.fbInput{width:100%;padding:14px 16px;margin-bottom:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:10px;color:var(--text);font-size:14px;box-sizing:border-box}
.fbBtn{width:100%;padding:14px;border:none;border-radius:10px;font-weight:600;font-size:14px;cursor:pointer;margin-bottom:12px}
.fbBtnPrimary{background:linear-gradient(135deg,#06b6d4,#7c3aed);color:white}
.fbBtnSecondary{background:rgba(255,255,255,0.06);color:var(--text);border:1px solid rgba(255,255,255,0.08)}
.fbBtnSecondary:hover{background:rgba(255,255,255,0.08)}
.fbBtnGoogle{background:white;color:#333;display:flex;align-items:center;justify-content:center;gap:10px}
.fbLink{text-align:center;margin-top:16px;font-size:13px;color:var(--muted)}
.fbLink button{background:none;border:none;color:#06b6d4;cursor:pointer;font-weight:600;text-decoration:underline}
.fbLoading{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(2,6,23,0.95);display:none;align-items:center;justify-content:center;z-index:999998;flex-direction:column;gap:20px}
.fbLoading.show{display:flex}
.fbSpinner{width:50px;height:50px;border:4px solid rgba(255,255,255,0.1);border-top-color:#06b6d4;border-radius:50%;animation:fbSpin 1s linear infinite}
.fbLoadingText{color:var(--text);font-size:14px}
@keyframes fbSpin{to{transform:rotate(360deg)}}
.fbWidget{background:linear-gradient(135deg,rgba(6,182,212,0.1),rgba(124,58,237,0.1));border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:12px;margin-top:12px;display:none}
.fbWidget.show{display:block}
.fbAvatar{width:40px;height:40px;background:linear-gradient(135deg,#06b6d4,#7c3aed);border-radius:50%;display:inline-flex;align-items:center;justify-content:center;color:white;font-weight:700;font-size:16px}
.fbGroups{background:var(--glass);border:1px solid rgba(255,255,255,0.04);border-radius:10px;padding:12px;margin-top:12px;display:none}
.fbGroups.show{display:block}
.fbGroups select{width:100%;padding:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);border-radius:8px;color:var(--text);font-size:13px}
</style>

<script>
// ==================== OPTIMIZATIONS & NEW FEATURES ====================

// Production Mode (setze auf false für keine Debug-Ausgaben)
const DEBUG = false;

// Logger mit DEBUG-Check
function log(...args) {
  if (DEBUG) {
    console.log('[BirdCount]', ...args);
  }
}

function logError(...args) {
  console.error('[BirdCount ERROR]', ...args);
}

function logWarn(...args) {
  console.warn('[BirdCount WARNING]', ...args);
}

// ==================== ERROR HANDLING ====================

/**
 * Zeigt eine benutzerfreundliche Fehlermeldung
 */
function showError(error, context, retryFn = null) {
  logError(context, error);
  
  const errorHtml = `
    <div class="error-card" role="alert">
      <h3>⚠️ Ein Fehler ist aufgetreten</h3>
      <p><strong>${context}</strong></p>
      <p style="font-size:13px; color:var(--muted);">${error.message}</p>
      <div style="margin-top:16px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
        ${retryFn ? `<button class="btn" onclick="this.closest('.error-card').remove(); (${retryFn.name || 'retry'})()">🔄 Erneut versuchen</button>` : ''}
        <button class="btn ghost" onclick="this.closest('.error-card').remove()">OK</button>
      </div>
    </div>
  `;
  
  const main = document.querySelector('.main');
  if (main) {
    const errorDiv = document.createElement('div');
    errorDiv.innerHTML = errorHtml;
    main.insertBefore(errorDiv.firstElementChild, main.firstChild);
  }
}

/**
 * Async Error Handler Wrapper
 */
async function tryAsync(fn, errorContext, retryFn = null) {
  try {
    return await fn();
  } catch (error) {
    showError(error, errorContext, retryFn);
    throw error;
  }
}

// ==================== LOADING STATES ====================

function showSkeleton(elementId, lines = 3) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  let skeletonHtml = '<div class="skeleton-loader">';
  for (let i = 0; i < lines; i++) {
    skeletonHtml += '<div class="skeleton-line"></div>';
  }
  skeletonHtml += '</div>';
  
  element.innerHTML = skeletonHtml;
}

function showEmptyState(elementId, icon, title, description, actionText = null, actionFn = null) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  let html = `
    <div class="empty-state">
      <div class="empty-icon" aria-hidden="true">${icon}</div>
      <h3>${title}</h3>
      <p>${description}</p>
  `;
  
  if (actionText && actionFn) {
    html += `<button class="btn" onclick="${actionFn}">${actionText}</button>`;
  }
  
  html += '</div>';
  element.innerHTML = html;
}

// ==================== THEME MANAGEMENT ====================

function initTheme() {
  const savedTheme = localStorage.getItem('theme');
  
  if (savedTheme) {
    document.body.setAttribute('data-theme', savedTheme);
    log('Theme geladen:', savedTheme);
  } else {
    // Auto-Detection
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.body.setAttribute('data-theme', 'dark');
      log('Theme automatisch: dark');
    } else {
      document.body.setAttribute('data-theme', 'light');
      log('Theme automatisch: light');
    }
  }
}

function watchSystemTheme() {
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    if (!localStorage.getItem('theme')) {
      document.body.setAttribute('data-theme', e.matches ? 'dark' : 'light');
      log('System-Theme geändert:', e.matches ? 'dark' : 'light');
    }
  });
}

// ==================== KEYBOARD SHORTCUTS ====================

function initKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Ignoriere wenn in Input-Feld
    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
      if (e.key !== 'Escape') return;
    }
    
    // Ctrl/Cmd + Key
    if (e.ctrlKey || e.metaKey) {
      switch(e.key.toLowerCase()) {
        case 'n':
          e.preventDefault();
          if (typeof openQuickAdd === 'function') openQuickAdd();
          break;
        case 'k':
          e.preventDefault();
          document.getElementById('globalSearch')?.focus();
          break;
        case 's':
          e.preventDefault();
          // Auto-save aktuelle Beobachtung
          break;
        case 'm':
          e.preventDefault();
          document.querySelector('.nav button[data-page="karte"]')?.click();
          break;
      }
    }
    
    // Ohne Modifier
    if (!e.ctrlKey && !e.metaKey && !e.altKey) {
      switch(e.key) {
        case 'Escape':
          closeAllModals();
          break;
        case '?':
          if (document.activeElement.tagName !== 'INPUT') {
            e.preventDefault();
            showKeyboardShortcuts();
          }
          break;
      }
    }
  });
  
  log('Keyboard Shortcuts initialisiert');
}

function closeAllModals() {
  const modalIds = [
    'quickAddModal', 'editModal', 'speciesDetailModal',
    'weatherModal', 'newFolderModal', 'speciesGuideModal', 'fbModal'
  ];
  
  modalIds.forEach(id => {
    const modal = document.getElementById(id);
    if (modal && modal.style.display !== 'none') {
      modal.style.display = 'none';
    }
  });
  
  if (typeof closeQuickAdd === 'function') closeQuickAdd();
  if (typeof closeEditModal === 'function') closeEditModal();
  if (typeof closeMobileMenu === 'function') closeMobileMenu();
}

function showKeyboardShortcuts() {
  const modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;inset:0;background:rgba(2,6,23,0.85);backdrop-filter:blur(8px);z-index:10000;display:flex;align-items:center;justify-content:center;padding:20px;';
  modal.onclick = (e) => {
    if (e.target === modal) modal.remove();
  };
  
  modal.innerHTML = `
    <div class="shortcuts-modal">
      <h2>⌨️ Tastatur-Shortcuts</h2>
      <table>
        <tr><td>Ctrl+N</td><td>Neue Beobachtung (Schnelleingabe)</td></tr>
        <tr><td>Ctrl+K</td><td>Suche fokussieren</td></tr>
        <tr><td>Ctrl+S</td><td>Speichern</td></tr>
        <tr><td>Ctrl+M</td><td>Karte öffnen</td></tr>
        <tr><td>ESC</td><td>Modals/Menü schließen</td></tr>
        <tr><td>?</td><td>Diese Hilfe anzeigen</td></tr>
      </table>
      <button class="btn" style="margin-top:20px;width:100%;" onclick="this.closest('div[style*=fixed]').remove()">Schließen</button>
    </div>
  `;
  
  document.body.appendChild(modal);
  log('Keyboard Shortcuts angezeigt');
}

// ==================== DATE UTILITIES ====================

function getDateRange(range) {
  const today = new Date();
  today.setHours(23, 59, 59, 999);
  let start = new Date(today);
  
  switch(range) {
    case 'today':
      start.setHours(0, 0, 0, 0);
      break;
    case 'yesterday':
      start.setDate(today.getDate() - 1);
      start.setHours(0, 0, 0, 0);
      today.setDate(today.getDate() - 1);
      break;
    case 'week':
      start.setDate(today.getDate() - 7);
      start.setHours(0, 0, 0, 0);
      break;
    case 'month':
      start.setMonth(today.getMonth() - 1);
      start.setHours(0, 0, 0, 0);
      break;
    case 'thisYear':
      start = new Date(today.getFullYear(), 0, 1);
      start.setHours(0, 0, 0, 0);
      break;
    default:
      start.setFullYear(2000, 0, 1);
  }
  
  return {
    start: start.toISOString().split('T')[0],
    end: today.toISOString().split('T')[0]
  };
}

function applyDateFilter(range) {
  const { start, end } = getDateRange(range);
  
  const dateFrom = document.getElementById('obsManagerDateFrom');
  const dateTo = document.getElementById('obsManagerDateTo');
  
  if (dateFrom) dateFrom.value = start;
  if (dateTo) dateTo.value = end;
  
  if (typeof filterObservationManager === 'function') {
    filterObservationManager();
  }
  
  // Aktualisiere ALLE date-shortcuts Buttons auf allen Seiten
  document.querySelectorAll('.date-shortcuts button').forEach(btn => {
    btn.classList.remove('active');
  });
  
  document.querySelectorAll(`.date-shortcuts button[data-range="${range}"]`).forEach(btn => {
    btn.classList.add('active');
  });
  
  const rangeNames = {
    'today': 'Heute',
    'yesterday': 'Gestern',
    'week': 'Letzte Woche',
    'month': 'Letzter Monat',
    'thisYear': 'Dieses Jahr',
    'all': 'Alle'
  };
  
  showNotification(`📅 Zeige: ${rangeNames[range] || range}`, 2000);
  log('Datums-Filter angewendet:', range);
}

// ==================== MOBILE GESTURES ====================

function initPullToRefresh() {
  let touchStartY = 0;
  let touchEndY = 0;
  let isPulling = false;
  
  const pullIndicator = document.createElement('div');
  pullIndicator.className = 'pull-to-refresh';
  pullIndicator.textContent = '🔄 Zum Aktualisieren ziehen';
  document.body.appendChild(pullIndicator);
  
  // Passive Listeners für bessere Performance
  document.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
  }, { passive: true });
  
  document.addEventListener('touchmove', (e) => {
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    touchEndY = e.touches[0].clientY;
    
    if (scrollTop === 0 && touchEndY > touchStartY) {
      const pullDistance = touchEndY - touchStartY;
      
      // RequestAnimationFrame für flüssige Updates
      requestAnimationFrame(() => {
        if (pullDistance > 80 && !isPulling) {
          pullIndicator.classList.add('active');
          pullIndicator.textContent = '🔄 Loslassen zum Aktualisieren';
        } else if (pullDistance < 80) {
          pullIndicator.classList.remove('active');
          pullIndicator.textContent = '🔄 Zum Aktualisieren ziehen';
        }
      });
    }
  }, { passive: true });
  
  document.addEventListener('touchend', async (e) => {
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    const pullDistance = touchEndY - touchStartY;
    
    if (scrollTop === 0 && pullDistance > 80 && !isPulling) {
      isPulling = true;
      pullIndicator.textContent = '⏳ Aktualisiere...';
      pullIndicator.classList.add('active');
      
      try {
        await refreshData();
        pullIndicator.textContent = '✅ Aktualisiert!';
        setTimeout(() => {
          pullIndicator.classList.remove('active');
        }, 1000);
      } catch (error) {
        pullIndicator.textContent = '❌ Fehler';
        setTimeout(() => {
          pullIndicator.classList.remove('active');
        }, 1000);
      }
      
      isPulling = false;
    } else {
      pullIndicator.classList.remove('active');
    }
    
    touchStartY = 0;
    touchEndY = 0;
  }, { passive: true });
  
  log('Pull-to-Refresh initialisiert');
}

async function refreshData() {
  log('Aktualisiere Daten...');
  
  // Nutze Promise.allSettled für parallele Ausführung
  const promises = [];
  
  if (typeof renderObservationManager === 'function') {
    promises.push(renderObservationManager().catch(err => log('Fehler beim Laden der Beobachtungen:', err)));
  }
  
  if (typeof updateDashboard === 'function') {
    promises.push(updateDashboard().catch(err => log('Fehler beim Dashboard-Update:', err)));
  }
  
  if (typeof updateChart === 'function') {
    promises.push(updateChart().catch(err => log('Fehler beim Chart-Update:', err)));
  }
  
  if (typeof updateMarkersFromData === 'function') {
    promises.push(updateMarkersFromData().catch(err => log('Fehler beim Marker-Update:', err)));
  }
  
  await Promise.allSettled(promises);
  log('Daten aktualisiert');
}

function initSwipeNavigation() {
  let touchStartX = 0;
  let touchEndX = 0;
  let touchStartTime = 0;
  
  const pages = ['home', 'beobachtungen', 'eingabe', 'diagramme', 'statistiken', 'karte', 'listen', 'arten', 'challenges', 'tools'];
  let currentPageIndex = 0;
  
  // Passive Listeners
  document.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartTime = Date.now();
  }, { passive: true });
  
  document.addEventListener('touchend', (e) => {
    touchEndX = e.changedTouches[0].clientX;
    const touchDuration = Date.now() - touchStartTime;
    
    // Nur bei schnellen Swipes (< 300ms)
    if (touchDuration < 300) {
      handleSwipe();
    }
  }, { passive: true });
  
  function handleSwipe() {
    const diff = touchStartX - touchEndX;
    const absDiff = Math.abs(diff);
    
    // Mindestens 100px und maximal 300ms
    if (absDiff < 100) return;
    if (window.innerWidth > 700) return;
    
    const activeBtn = document.querySelector('.nav button.active');
    if (activeBtn) {
      const currentPage = activeBtn.getAttribute('data-page');
      currentPageIndex = pages.indexOf(currentPage);
    }
    
    if (diff > 0) {
      currentPageIndex = Math.min(pages.length - 1, currentPageIndex + 1);
    } else {
      currentPageIndex = Math.max(0, currentPageIndex - 1);
    }
    
    const nextPage = pages[currentPageIndex];
    const nextBtn = document.querySelector(`.nav button[data-page="${nextPage}"]`);
    if (nextBtn) {
      // INSTANT Click ohne requestAnimationFrame
      // Trigger pointerdown event für instant response
      const event = new PointerEvent('pointerdown', {
        bubbles: true,
        cancelable: true
      });
      nextBtn.dispatchEvent(event);
      log('Swipe Navigation:', nextPage);
    }
  }
  
  log('Swipe Navigation initialisiert');
}

// ==================== PRIVACY BANNER ====================

function showPrivacyBanner() {
  if (localStorage.getItem('privacy_accepted')) {
    return;
  }
  
  const banner = document.createElement('div');
  banner.className = 'privacy-banner';
  banner.innerHTML = `
    <p>
      🔒 Diese App speichert Daten lokal in deinem Browser für Offline-Nutzung.
      Keine Cookies, kein Tracking.
    </p>
    <button onclick="acceptPrivacy()">Verstanden</button>
  `;
  
  document.body.appendChild(banner);
  log('Privacy Banner angezeigt');
}

function acceptPrivacy() {
  localStorage.setItem('privacy_accepted', 'true');
  const banner = document.querySelector('.privacy-banner');
  if (banner) {
    banner.style.animation = 'slideUpBanner 0.3s ease reverse';
    setTimeout(() => banner.remove(), 300);
  }
  log('Privacy akzeptiert');
}

// ==================== INIT ALL IMPROVEMENTS ====================

document.addEventListener('DOMContentLoaded', function() {
  log('🚀 BirdCount mit Optimierungen lädt...');
  
  // Theme initialisieren
  initTheme();
  watchSystemTheme();
  
  // Keyboard Shortcuts
  initKeyboardShortcuts();
  
  // Mobile Features
  if (window.innerWidth <= 700) {
    initPullToRefresh();
    initSwipeNavigation();
  }
  
  // Privacy Banner
  setTimeout(showPrivacyBanner, 2000);
  
  // Update Mobile Menu ARIA
  const mobileMenuBtn = document.getElementById('mobileMenuBtn');
  if (mobileMenuBtn) {
    const originalToggle = window.toggleMobileMenu;
    window.toggleMobileMenu = function() {
      if (originalToggle) originalToggle();
      const sidebar = document.querySelector('.sidebar');
      const isOpen = sidebar?.classList.contains('mobile-visible');
      mobileMenuBtn.setAttribute('aria-expanded', isOpen);
      mobileMenuBtn.setAttribute('aria-label', isOpen ? 'Menü schließen' : 'Menü öffnen');
    };
  }
  
  // PERFORMANCE-OPTIMIERUNG: Event Delegation für Navigation mit Touch-Schutz
  const navContainer = document.querySelector('.nav');
  if (navContainer) {
    // Touch-Event-System: unterscheidet Swipe von echtem Click
    let touchStartY = 0;
    let touchStartX = 0;
    let touchStartTime = 0;
    let isSwiping = false;
    let touchedButton = null;
    
    // Speichere Touch-Start-Position
    navContainer.addEventListener('touchstart', function(e) {
      const button = e.target.closest('button');
      if (!button) return;
      
      touchedButton = button;
      touchStartY = e.touches[0].clientY;
      touchStartX = e.touches[0].clientX;
      touchStartTime = Date.now();
      isSwiping = false;
    }, { passive: true });
    
    // Erkenne Bewegung als Swipe
    navContainer.addEventListener('touchmove', function(e) {
      if (!isSwiping && touchedButton) {
        const touchCurrentY = e.touches[0].clientY;
        const touchCurrentX = e.touches[0].clientX;
        const deltaY = Math.abs(touchCurrentY - touchStartY);
        const deltaX = Math.abs(touchCurrentX - touchStartX);
        
        // Wenn mehr als 10px Bewegung → ist ein Swipe
        if (deltaY > 10 || deltaX > 10) {
          isSwiping = true;
          console.log('🚫 Swipe erkannt - Click wird verhindert');
        }
      }
    }, { passive: true });
    
    // Nutze click Event (nicht pointerdown!) für bessere Touch-Unterscheidung
    navContainer.addEventListener('click', function(e) {
      const button = e.target.closest('button');
      if (!button) return;
      
      // Verhindere Click wenn es ein Swipe war
      if (isSwiping) {
        e.preventDefault();
        e.stopPropagation();
        console.log('❌ Click blockiert - war Swipe');
        return;
      }
      
      // Verhindere zu schnelle Klicks (< 80ms = wahrscheinlich Scroll-Start)
      const touchDuration = Date.now() - touchStartTime;
      if (touchDuration < 80 && touchStartTime > 0) {
        e.preventDefault();
        e.stopPropagation();
        console.log('❌ Click blockiert - zu schnell (<80ms)');
        return;
      }
      
      console.log('✅ Echter Click erkannt -', touchDuration + 'ms');
      
      // INSTANT UI-Update
      // Mobile Menü schließen
      if (window.innerWidth <= 700) {
        closeMobileMenu();
      }
      
      const page = button.getAttribute('data-page');
      if (!page) return;
      
      // Navigation aktiv setzen - INSTANT
      navContainer.querySelectorAll('button').forEach(b => {
        b.classList.remove('active');
        b.removeAttribute('aria-current');
      });
      button.classList.add('active');
      button.setAttribute('aria-current', 'page');
      
      // Map-Full Mode für Karte - INSTANT
      if (page === 'karte') {
        document.documentElement.classList.add('map-full');
        // Karte ist im aside-Element, nicht in einer section
        // Verstecke alle sections wenn Karte aktiv ist
        document.querySelectorAll('main section').forEach(s => s.style.display = 'none');
      } else {
        document.documentElement.classList.remove('map-full');
        // Sections umschalten - INSTANT ohne Animation
        document.querySelectorAll('main section').forEach(s => {
          if (s.id === page) {
            s.style.display = 'block';
          } else {
            s.style.display = 'none';
          }
        });
      }
      
      log('Navigation:', page);
      
      // Lade Section-spezifische Daten asynchron (nicht-blockierend)
      loadPageData(page);
    });
  }
  
  // PERFORMANCE-OPTIMIERUNG: Theme-Switcher mit Event Delegation
  const themeContainer = document.querySelector('.feature-section');
  if (themeContainer) {
    themeContainer.addEventListener('pointerdown', function(e) {
      const themeBtn = e.target.closest('.theme-btn');
      if (!themeBtn) return;
      
      const theme = themeBtn.getAttribute('data-theme');
      if (!theme) return;
      
      // INSTANT Änderung ohne requestAnimationFrame
      document.body.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      
      // Visual Feedback - INSTANT
      themeContainer.querySelectorAll('.theme-btn').forEach(b => b.style.opacity = '0.6');
      themeBtn.style.opacity = '1';
      
      showNotification(`🎨 Theme geändert: ${theme}`, 2000);
      log('Theme gewechselt:', theme);
    }, { passive: true });
  }
  
  // Setze initialen Theme-Button als aktiv
  const currentTheme = document.body.getAttribute('data-theme') || 'dark';
  const activeThemeBtn = document.querySelector(`.theme-btn[data-theme="${currentTheme}"]`);
  if (activeThemeBtn) activeThemeBtn.style.opacity = '1';
  
  log('✅ Optimierungen geladen!');
  log('💡 Tipp: Drücke "?" für Keyboard-Shortcuts');
});

// Asynchrones Laden von Section-Daten (nicht-blockierend)
async function loadPageData(page) {
  try {
    // Temporäre Daten löschen wenn wir nicht zur Karte gehen
    if (page !== 'karte' && typeof tempObservationData !== 'undefined') {
      window.tempObservationData = null;
    }
    
    // Section-spezifische Logik
    if (page === 'diagramme') {
      if (typeof updateYearSelection === 'function') updateYearSelection();
      if (typeof initMemberFilter === 'function') await initMemberFilter();
      if (typeof updateChart === 'function') updateChart();
    } else if (page === 'statistiken') {
      if (typeof updateAdvancedStatistics === 'function') updateAdvancedStatistics();
    } else if (page === 'beobachtungen') {
      if (typeof renderObservationManager === 'function') await renderObservationManager();
    } else if (page === 'eingabe') {
      if (typeof initFolderSelect === 'function') await initFolderSelect();
      if (typeof updateMapCoordinatesDisplay === 'function') updateMapCoordinatesDisplay();
    } else if (page === 'listen') {
      if (typeof loadUserLists === 'function') await loadUserLists();
      if (typeof renderLists === 'function') await renderLists();
    } else if (page === 'arten') {
      if (typeof loadSpeciesDatabase === 'function') loadSpeciesDatabase();
    } else if (page === 'tools') {
      if (typeof updateSystemInfo === 'function') updateSystemInfo();
    } else if (page === 'group-compare') {
      if (typeof renderGroupComparison === 'function') await renderGroupComparison();
    } else if (page === 'home') {
      if (typeof updateDashboard === 'function') updateDashboard();
    } else if (page === 'challenges') {
      if (typeof loadChallengeProgress === 'function') await loadChallengeProgress();
      if (typeof loadCustomChallenges === 'function') await loadCustomChallenges();
      if (typeof updateChallengeDisplay === 'function') updateChallengeDisplay();
      if (typeof renderChallenges === 'function') await renderChallenges();
    }
    
    // Karte neu berechnen nach Größenänderung
    setTimeout(() => {
      if (window.mapObj && typeof window.mapObj.invalidateSize === 'function') {
        window.mapObj.invalidateSize();
      }
    }, 220);
    
  } catch (error) {
    logError('Fehler beim Laden der Section-Daten:', error);
  }
}

// Export functions to window
window.log = log;
window.logError = logError;
window.showError = showError;
window.tryAsync = tryAsync;
window.showSkeleton = showSkeleton;
window.showEmptyState = showEmptyState;
window.applyDateFilter = applyDateFilter;
window.showKeyboardShortcuts = showKeyboardShortcuts;
window.acceptPrivacy = acceptPrivacy;

// ==================== ORIGINAL CODE BELOW ====================

(function(){
console.log("%c🔥 Firebase Start", "color: #06b6d4; font-weight: bold; font-size: 16px");
var loadingTimeout;
var waitFB=function(){return new Promise(function(r){if(typeof firebase!=="undefined"){r()}else{var i=setInterval(function(){if(typeof firebase!=="undefined"){clearInterval(i);r()}},50)}})};
var init=function(){
  console.log("1️⃣ Warte auf Firebase SDK...");
  
  // Initialisiere globale Variable für aktuelle Gruppe
  window.currentSelectedGroup = localStorage.getItem("selectedGroup") || "personal";
  console.log("💾 window.currentSelectedGroup initialisiert:", window.currentSelectedGroup);
  
  // NEU: Lade Challenge-Fortschritt beim Start
  setTimeout(() => {
    loadChallengeProgress().then(() => {
      console.log("✅ Challenge-Fortschritt geladen:", challengeLevel, "XP:", challengeXP);
      updateChallengeDisplay();
    }).catch(err => {
      console.log("ℹ️ Kein gespeicherter Challenge-Fortschritt gefunden");
    });
    
    // NEU: Lade auch benutzerdefinierte Challenges beim Start
    loadCustomChallenges().then(() => {
      console.log("✅ Benutzerdefinierte Challenges geladen");
    }).catch(err => {
      console.log("ℹ️ Keine benutzerdefinierten Challenges gefunden");
    });
  }, 1000);
  
  // Initialer Zustand des Gruppenvergleichs-Menüpunkts
  setTimeout(() => {
    if (typeof window.toggleGroupCompareVisibility === 'function') {
      window.toggleGroupCompareVisibility();
    }
  }, 500);
  
  waitFB().then(function(){
    console.log("2️⃣ Firebase SDK geladen, initialisiere...");
    try {
      firebase.initializeApp({
        apiKey:"AIzaSyC0jdnaVDn56qoI2hI5jGYY0RI464OwE4M",
        authDomain:"birdcount-a563a.firebaseapp.com",
        databaseURL:"https://birdcount-a563a-default-rtdb.europe-west1.firebasedatabase.app",
        projectId:"birdcount-a563a",
        storageBucket:"birdcount-a563a.firebasestorage.app",
        messagingSenderId:"759746888036",
        appId:"1:759746888036:web:bc5375ba840956a4f43a71"
      });
      window.FBA=firebase.auth();
      window.FBD=firebase.database();
      console.log("3️⃣ Firebase initialisiert!");
      console.log("   - Auth:", window.FBA ? "✅" : "❌");
      console.log("   - Database:", window.FBD ? "✅" : "❌");
      
      // Test Database Connection
      window.FBD.ref('.info/connected').on('value', function(snap) {
        if (snap.val() === true) {
          console.log("4️⃣ 🟢 Database Verbindung: ONLINE");
        } else {
          console.log("4️⃣ 🔴 Database Verbindung: OFFLINE");
        }
      });
      
      setTimeout(injectUI,200);
    } catch(e) {
      console.error("❌ Firebase Init Error:", e);
      alert("Firebase Fehler: " + e.message);
    }
  }).catch(function(e){
    console.error("❌ Firebase SDK Fehler:",e);
    alert("Firebase SDK konnte nicht geladen werden")
  })
};

var injectUI=function(){
  console.log("5️⃣ Injiziere UI...");
  var m=document.createElement("div");m.className="fbModal";m.id="fbModal";
  m.innerHTML='<div class="fbBox"><div class="fbLogo">🐦</div><h2 class="fbTitle">Cloud-Sync</h2><p class="fbSub">Sync deine Beobachtungen</p><button class="fbBtn fbBtnGoogle" id="fbGoogleBtn"><svg width="18" height="18" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path></svg>Mit Google anmelden</button><div style="text-align:center;margin:12px 0;color:var(--muted);">oder</div><input type="email" class="fbInput" id="fbEmail" placeholder="E-Mail"><input type="password" class="fbInput" id="fbPassword" placeholder="Passwort"><button class="fbBtn fbBtnPrimary" id="fbLoginBtn">Anmelden</button><div class="fbLink">Noch kein Konto? <button id="fbRegBtn">Registrieren</button></div><div class="fbLink"><button id="fbSkipBtn">Offline-Modus</button></div></div>';
  document.body.appendChild(m);
  var l=document.createElement("div");l.className="fbLoading";l.id="fbLoading";l.innerHTML='<div class="fbSpinner"></div><div class="fbLoadingText" id="fbLoadingText">Lädt...</div>';
  document.body.appendChild(l);
  var s=document.querySelector(".sidebar .brand");
  if(s){
    var w=document.createElement("div");w.id="fbWidget";w.className="fbWidget";
    w.innerHTML='<div style="display:flex;align-items:center;gap:10px;"><div class="fbAvatar" id="fbAvatar">?</div><div style="flex:1;min-width:0;"><div style="display:flex;align-items:center;gap:6px;"><div style="font-weight:600;font-size:13px;flex:1;" id="fbName">Lädt...</div><button id="fbEditNameBtn" style="background:none;border:none;cursor:pointer;padding:4px;opacity:0.6;display:none;" title="Namen ändern">✏️</button></div><div style="font-size:11px;color:var(--muted);" id="fbEmail2">...</div></div></div>';
    s.parentNode.insertBefore(w,s.nextSibling);
    var g=document.createElement("div");g.id="fbGroups";g.className="fbGroups";
    g.innerHTML='<select id="fbGroupSelect"><option value="personal">🔒 Meine Beobachtungen</option></select><div style="display:flex;gap:8px;margin-top:8px;"><button class="fbBtn fbBtnPrimary" id="fbNewGroupBtn" style="flex:1;">➕ Neue Gruppe</button><button class="fbBtn fbBtnSecondary" id="fbJoinGroupBtn" style="flex:1;">🔗 Beitreten</button></div><div style="margin-top:8px;"><button class="fbBtn" id="fbRenameGroupBtn" style="width:100%;background:var(--accent-2);display:none;">✏️ Gruppe umbenennen</button></div><div style="margin-top:8px;"><button class="fbBtn" id="fbDeleteGroupBtn" style="width:100%;background:var(--danger);display:none;">🗑️ Gruppe löschen</button></div>';
    w.parentNode.insertBefore(g,w.nextSibling)
  }
  setupEvents();
  setTimeout(showPrompt,2000);
  console.log("6️⃣ UI injiziert ✅")
};

var setupEvents=function(){
  console.log("7️⃣ Setup Events...");
  
  document.getElementById("fbGoogleBtn").addEventListener("click",function(){
    console.log("🔵 Google Login gestartet...");
    showLoading("Google-Anmeldung...");
    loadingTimeout=setTimeout(function(){hideLoading();alert("Timeout: Google-Anmeldung dauert zu lange")},15000);
    var p=new firebase.auth.GoogleAuthProvider();
    window.FBA.signInWithPopup(p).then(function(result){
      clearTimeout(loadingTimeout);
      console.log("✅ Google Login erfolgreich:", result.user.email);
    }).catch(function(e){
      clearTimeout(loadingTimeout);
      console.error("❌ Google Login Fehler:",e);
      alert("Google-Anmeldung fehlgeschlagen: "+e.message);
      hideLoading()
    })
  });
  
  document.getElementById("fbLoginBtn").addEventListener("click",function(){
    var e=document.getElementById("fbEmail").value;
    var p=document.getElementById("fbPassword").value;
    if(!e||!p){alert("Bitte E-Mail und Passwort eingeben");return}
    console.log("🔵 Email Login für:", e);
    showLoading("Anmeldung...");
    loadingTimeout=setTimeout(function(){hideLoading();alert("Timeout: Anmeldung dauert zu lange")},15000);
    window.FBA.signInWithEmailAndPassword(e,p).then(function(result){
      clearTimeout(loadingTimeout);
      console.log("✅ Email Login erfolgreich:", result.user.email);
    }).catch(function(err){
      clearTimeout(loadingTimeout);
      console.error("❌ Email Login Fehler:",err);
      alert("Anmeldung fehlgeschlagen: "+err.message);
      hideLoading()
    })
  });
  
  document.getElementById("fbRegBtn").addEventListener("click",function(){
    var e=prompt("E-Mail:");if(!e)return;
    var p=prompt("Passwort (min. 6 Zeichen):");
    if(!p||p.length<6){alert("Passwort muss mindestens 6 Zeichen haben");return}
    console.log("🔵 Registrierung für:", e);
    showLoading("Registrierung...");
    loadingTimeout=setTimeout(function(){hideLoading();alert("Timeout: Registrierung dauert zu lange")},15000);
    window.FBA.createUserWithEmailAndPassword(e,p).then(function(result){
      clearTimeout(loadingTimeout);
      console.log("✅ Registrierung erfolgreich:", result.user.email);
    }).catch(function(err){
      clearTimeout(loadingTimeout);
      console.error("❌ Registrierung Fehler:",err);
      alert("Registrierung fehlgeschlagen: "+err.message);
      hideLoading()
    })
  });
  
  document.getElementById("fbSkipBtn").addEventListener("click",function(){
    console.log("⏭️ Offline-Modus gewählt");
    hideModal();
    if(typeof showNotification==="function"){showNotification("Offline-Modus aktiv")}
  });
  
  // Edit Name Button Event
  document.getElementById("fbEditNameBtn").addEventListener("click", function() {
    var user = window.FBA.currentUser;
    if (!user) {
      alert("Bitte erst anmelden!");
      return;
    }
    
    var currentName = user.displayName || user.email.split("@")[0];
    var newName = prompt("Neuer Anzeigename:", currentName);
    
    if (newName && newName.trim() !== "" && newName !== currentName) {
      newName = newName.trim();
      console.log("🔵 Name ändern zu:", newName);
      
      showLoading("Name wird aktualisiert...");
      
      user.updateProfile({
        displayName: newName
      }).then(function() {
        console.log("✅ Name erfolgreich geändert zu:", newName);
        
        // UI aktualisieren
        document.getElementById("fbName").textContent = newName;
        document.getElementById("fbAvatar").textContent = newName.charAt(0).toUpperCase();
        
        // Aktualisiere alle Beobachtungen in allen Gruppen
        return updateUserNameInGroups(user.uid, newName);
      }).then(function() {
        hideLoading();
        if (typeof showNotification === "function") {
          showNotification("✅ Name überall aktualisiert: " + newName);
        }
        
        // Aktualisiere die Anzeige (falls auf Analyse-Seite)
        if (document.getElementById("diagramme").style.display !== "none") {
          initMemberFilter();
          updateChart();
        }
      }).catch(function(error) {
        console.error("❌ Fehler beim Ändern des Namens:", error);
        hideLoading();
        alert("Fehler beim Ändern des Namens: " + error.message);
      });
    }
  });
  
  window.FBA.onAuthStateChanged(function(u){
    if(u){
      console.log("8️⃣ Auth State: Angemeldet als", u.email);
      hideModal();hideLoading();updateUI(u);
      if(typeof showNotification==="function"){showNotification("✅ Cloud-Sync aktiv!")}
    }else{
      console.log("8️⃣ Auth State: Abgemeldet");
      var w=document.getElementById("fbWidget");
      var g=document.getElementById("fbGroups");
      if(w)w.classList.remove("show");
      if(g)g.classList.remove("show")
    }
  });
  
  var btn=document.getElementById("fbNewGroupBtn");
  if(btn){
    btn.addEventListener("click",function(){
      console.log("🔵 Neue Gruppe Button geklickt");
      
      var u=window.FBA.currentUser;
      if(!u){
        console.error("❌ Kein User angemeldet!");
        alert("Bitte erst anmelden!");
        return;
      }
      console.log("   User:", u.email);
      
      var n=prompt("Gruppenname:");
      if(!n){
        console.log("   Abgebrochen - kein Name");
        return;
      }
      console.log("   Gruppenname:", n);
      
      showLoading("Gruppe wird erstellt...");
      console.log("🔵 Starte Database-Write...");
      console.log("   Path: groups/[new-id]");
      console.log("   User UID:", u.uid);
      
      loadingTimeout=setTimeout(function(){
        console.error("❌ TIMEOUT nach 10 Sekunden!");
        console.log("   Mögliche Ursachen:");
        console.log("   1. Realtime Database nicht aktiviert");
        console.log("   2. Security Rules blockieren");
        console.log("   3. Netzwerk-Problem");
        hideLoading();
        alert("⏱️ Timeout!\n\nDie Realtime Database antwortet nicht.\n\nBitte prüfe in der Firebase Console:\n1. Ist Realtime Database aktiviert?\n2. Sind die Security Rules korrekt?\n\nKonsole öffnen (F12) für Details.")
      },10000);
      
      var groupRef = window.FBD.ref("groups").push();
      console.log("   Group ID:", groupRef.key);
      
      var groupData = {
        name:n,
        createdBy:u.uid,
        createdAt:firebase.database.ServerValue.TIMESTAMP,
        members:{
          [u.uid]:{
            role:"admin",
            name:u.displayName||u.email.split("@")[0]
          }
        }
      };
      console.log("   Daten:", JSON.stringify(groupData, null, 2));
      console.log("   ✅ Du wirst als Admin mit UID", u.uid, "hinzugefügt");
      
      groupRef.set(groupData).then(function(){
        clearTimeout(loadingTimeout);
        console.log("✅ Gruppe erfolgreich erstellt!");
        console.log("✅ Du wurdest als Admin hinzugefügt!");
        
        var fullId = groupRef.key;
        var shortId = fullId.substr(0,8).toUpperCase();
        
        // Füge die Gruppe sofort manuell zur Auswahl hinzu
        var select = document.getElementById("fbGroupSelect");
        if(select){
          var option = document.createElement("option");
          option.value = fullId;
          option.textContent = "👑 " + n;
          select.appendChild(option);
          select.value = fullId; // Wähle die neue Gruppe aus
          
          // Speichere die Auswahl GLOBAL und in localStorage
          window.currentSelectedGroup = fullId;
          localStorage.setItem("selectedGroup", fullId);
          console.log("✅ Gruppe zur Auswahl hinzugefügt, ausgewählt und in window.currentSelectedGroup gespeichert:", fullId);
          
          // Trigger change event damit die Beobachtungen geladen werden
          var event = new Event('change');
          select.dispatchEvent(event);
        }
        
        hideLoading();
        
        alert("✅ Gruppe erfolgreich erstellt!\n\n📁 Gruppe: "+n+"\n👤 Du bist: Admin\n\n📋 Gruppen-ID (zum Teilen):\n"+fullId+"\n\nKurz-ID: "+shortId+"\n\n💡 Die Gruppe wurde ausgewählt!\n\n⚠️ WICHTIG: Neue Beobachtungen werden jetzt in dieser Gruppe gespeichert!");
        
        // Kopiere die ID in die Zwischenablage wenn möglich
        if(navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(fullId).then(function(){
            if(typeof showNotification === "function"){
              showNotification("📋 Gruppen-ID kopiert! Gruppe ist aktiv.");
            }
          }).catch(function(e){
            console.log("Clipboard API nicht verfügbar:", e);
            if(typeof showNotification === "function"){
              showNotification("✅ Gruppe ist aktiv!");
            }
          });
        } else {
          if(typeof showNotification === "function"){
            showNotification("✅ Gruppe ist aktiv!");
          }
        }
      }).catch(function(e){
        clearTimeout(loadingTimeout);
        console.error("❌ Database Write Fehler:",e);
        console.log("   Error Code:", e.code);
        console.log("   Error Message:", e.message);
        hideLoading();
        
        var msg = "❌ Fehler beim Erstellen:\n\n" + e.message;
        if(e.code === "PERMISSION_DENIED"){
          msg += "\n\n🔒 PERMISSION_DENIED bedeutet:\nDie Security Rules blockieren den Zugriff.\n\nLösung:\n1. Gehe zu Firebase Console\n2. Realtime Database → Rules\n3. Setze:\n{\n  \"rules\": {\n    \".read\": \"auth != null\",\n    \".write\": \"auth != null\"\n  }\n}"
        }
        alert(msg)
      })
    })
  }
  
  var joinBtn=document.getElementById("fbJoinGroupBtn");
  if(joinBtn){
    joinBtn.addEventListener("click",function(){
      console.log("🔵 Beitreten Button geklickt");
      
      var u=window.FBA.currentUser;
      if(!u){
        console.error("❌ Kein User angemeldet!");
        alert("Bitte erst anmelden!");
        return;
      }
      console.log("   User:", u.email);
      
      var groupId=prompt("Gib die Gruppen-ID ein:\n\n(Die ID erhältst du vom Gruppen-Admin)");
      if(!groupId){
        console.log("   Abgebrochen - keine ID");
        return;
      }
      
      // Bereinige die Eingabe
      groupId = groupId.trim();
      console.log("   Gruppen-ID:", groupId);
      console.log("   ID-Länge:", groupId.length);
      
      showLoading("Trete Gruppe bei...");
      
      // Prüfe ob Gruppe existiert
      console.log("🔍 Prüfe Gruppe in Firebase:", "groups/" + groupId);
      window.FBD.ref("groups/"+groupId).once("value").then(function(snapshot){
        console.log("📊 Snapshot erhalten, exists:", snapshot.exists());
        
        if(!snapshot.exists()){
          console.error("❌ Gruppe existiert nicht!");
          console.log("   Mögliche Ursachen:");
          console.log("   1. Falsche Gruppen-ID");
          console.log("   2. Gruppe wurde gelöscht");
          console.log("   3. Keine Leseberechtigung (Security Rules)");
          hideLoading();
          alert("❌ Gruppe nicht gefunden!\n\nMögliche Gründe:\n• Falsche Gruppen-ID\n• Keine Berechtigung\n\nBitte prüfe:\n1. Die vollständige ID kopiert?\n2. Firebase Security Rules korrekt?");
          return;
        }
        
        var groupData = snapshot.val();
        console.log("   Gruppe gefunden:", groupData.name);
        console.log("   Aktuelle Members:", groupData.members ? Object.keys(groupData.members) : "keine");
        
        // Prüfe ob User bereits Mitglied ist
        if(groupData.members && groupData.members[u.uid]){
          console.log("   ℹ️ User ist bereits Mitglied");
          hideLoading();
          alert("ℹ️ Du bist bereits Mitglied dieser Gruppe!");
          return;
        }
        
        // Füge User zur Gruppe hinzu
        var memberData = {
          role: "member",
          name: u.displayName || u.email.split("@")[0],
          joinedAt: firebase.database.ServerValue.TIMESTAMP
        };
        
        console.log("💾 Schreibe Member-Daten:", "groups/"+groupId+"/members/"+u.uid);
        console.log("   Daten:", JSON.stringify(memberData, null, 2));
        
        window.FBD.ref("groups/"+groupId+"/members/"+u.uid).set(memberData).then(function(){
          console.log("✅ Erfolgreich beigetreten!");
          
          // Füge die Gruppe sofort manuell zur Auswahl hinzu
          var select = document.getElementById("fbGroupSelect");
          if(select){
            // Prüfe ob Gruppe nicht schon da ist
            var exists = false;
            for(var i = 0; i < select.options.length; i++){
              if(select.options[i].value === groupId){
                exists = true;
                break;
              }
            }
            
            if(!exists){
              var option = document.createElement("option");
              option.value = groupId;
              option.textContent = "👥 " + groupData.name;
              select.appendChild(option);
            }
            
            select.value = groupId; // Wähle die neue Gruppe aus
            
            // Speichere die Auswahl GLOBAL und in localStorage
            window.currentSelectedGroup = groupId;
            localStorage.setItem("selectedGroup", groupId);
            console.log("✅ Gruppe zur Auswahl hinzugefügt, ausgewählt und in window.currentSelectedGroup gespeichert:", groupId);
            
            // Trigger change event damit die Beobachtungen geladen werden
            var event = new Event('change');
            select.dispatchEvent(event);
          }
          
          hideLoading();
          alert("✅ Erfolgreich beigetreten!\n\nGruppe: " + groupData.name + "\n\nDie Gruppe wurde ausgewählt!\n\n⚠️ WICHTIG: Neue Beobachtungen werden jetzt in dieser Gruppe gespeichert!");
          
          // Gruppen werden automatisch durch den Listener aktualisiert
        }).catch(function(e){
          console.error("❌ Fehler beim Beitreten:", e);
          console.log("   Error Code:", e.code);
          console.log("   Error Message:", e.message);
          hideLoading();
          
          var msg = "❌ Fehler beim Beitreten:\n\n" + e.message;
          
          if(e.code === "PERMISSION_DENIED"){
            msg += "\n\n🔒 PERMISSION_DENIED!\n\nDie Firebase Security Rules blockieren den Zugriff.\n\nLösung in Firebase Console:\n1. Realtime Database → Rules\n2. Ersetze mit:\n\n{\n  \"rules\": {\n    \"groups\": {\n      \"$groupId\": {\n        \".read\": \"auth != null\",\n        \".write\": \"auth != null\"\n      }\n    }\n  }\n}";
          }
          
          alert(msg);
        });
        
      }).catch(function(e){
        console.error("❌ Fehler beim Laden der Gruppe:", e);
        console.log("   Error Code:", e.code);
        console.log("   Error Message:", e.message);
        hideLoading();
        
        var msg = "❌ Fehler beim Laden:\n\n" + e.message;
        
        if(e.code === "PERMISSION_DENIED"){
          msg += "\n\n🔒 Die Firebase Security Rules erlauben dir nicht, diese Gruppe zu sehen.\n\nBitte den Admin, die Security Rules zu prüfen.";
        }
        
        alert(msg);
      });
    })
  }
  
  // Event-Listener für Gruppe umbenennen Button
  var renameBtn=document.getElementById("fbRenameGroupBtn");
  if(renameBtn){
    renameBtn.addEventListener("click",function(){
      console.log("🔵 Gruppe umbenennen Button geklickt");
      
      var u=window.FBA.currentUser;
      if(!u){
        console.error("❌ Kein User angemeldet!");
        alert("Bitte erst anmelden!");
        return;
      }
      
      var selectedGroup = window.currentSelectedGroup;
      if(!selectedGroup || selectedGroup === "personal"){
        alert("Bitte wähle eine Gruppe aus!");
        return;
      }
      
      console.log("   User:", u.email);
      console.log("   Umzubenennende Gruppe:", selectedGroup);
      
      showLoading("Prüfe Berechtigung...");
      
      // Prüfe ob User Admin der Gruppe ist
      window.FBD.ref("groups/" + selectedGroup).once("value").then(function(snapshot){
        if(!snapshot.exists()){
          hideLoading();
          alert("❌ Gruppe nicht gefunden!");
          return;
        }
        
        var groupData = snapshot.val();
        var isAdmin = groupData.members && groupData.members[u.uid] && groupData.members[u.uid].role === "admin";
        
        console.log("   Ist Admin:", isAdmin);
        
        if(!isAdmin){
          hideLoading();
          alert("❌ Nur Admins können die Gruppe umbenennen!\n\nDu bist: " + (groupData.members && groupData.members[u.uid] ? groupData.members[u.uid].role : "kein Mitglied"));
          return;
        }
        
        hideLoading();
        
        // Frage nach neuem Namen
        var newName = window.prompt("Neuer Gruppenname:", groupData.name);
        
        if(!newName || newName.trim() === ""){
          console.log("   Abgebrochen - kein Name eingegeben");
          return;
        }
        
        newName = newName.trim();
        
        if(newName === groupData.name){
          alert("Der Name ist identisch mit dem aktuellen Namen!");
          return;
        }
        
        console.log("✏️ Benenne Gruppe um zu:", newName);
        showLoading("Benenne Gruppe um...");
        
        // Update den Gruppennamen in Firebase
        window.FBD.ref("groups/" + selectedGroup + "/name").set(newName).then(function(){
          console.log("✅ Gruppe erfolgreich umbenannt!");
          hideLoading();
          alert("✅ Gruppe wurde erfolgreich umbenannt zu:\n\n" + newName);
          
          // Aktualisiere die Dropdown-Auswahl
          loadUserGroups();
        }).catch(function(error){
          console.error("❌ Fehler beim Umbenennen:", error);
          hideLoading();
          alert("❌ Fehler beim Umbenennen der Gruppe:\n\n" + error.message);
        });
      }).catch(function(error){
        console.error("❌ Fehler beim Abrufen der Gruppe:", error);
        hideLoading();
        alert("❌ Fehler:\n\n" + error.message);
      });
    });
  }
  
  // Event-Listener für Gruppe löschen Button
  var deleteBtn=document.getElementById("fbDeleteGroupBtn");
  if(deleteBtn){
    deleteBtn.addEventListener("click",function(){
      console.log("🔵 Gruppe löschen Button geklickt");
      
      var u=window.FBA.currentUser;
      if(!u){
        console.error("❌ Kein User angemeldet!");
        alert("Bitte erst anmelden!");
        return;
      }
      
      var selectedGroup = window.currentSelectedGroup;
      if(!selectedGroup || selectedGroup === "personal"){
        alert("Bitte wähle eine Gruppe aus!");
        return;
      }
      
      console.log("   User:", u.email);
      console.log("   Zu löschende Gruppe:", selectedGroup);
      
      showLoading("Prüfe Berechtigung...");
      
      // Prüfe ob User Admin der Gruppe ist
      window.FBD.ref("groups/" + selectedGroup).once("value").then(function(snapshot){
        if(!snapshot.exists()){
          hideLoading();
          alert("❌ Gruppe nicht gefunden!");
          return;
        }
        
        var groupData = snapshot.val();
        var isAdmin = groupData.members && groupData.members[u.uid] && groupData.members[u.uid].role === "admin";
        
        console.log("   Ist Admin:", isAdmin);
        
        if(!isAdmin){
          hideLoading();
          alert("❌ Nur Admins können die Gruppe löschen!\n\nDu bist: " + (groupData.members && groupData.members[u.uid] ? groupData.members[u.uid].role : "kein Mitglied"));
          return;
        }
        
        hideLoading();
        
        // Bestätigung vom User
        var confirmDelete = window.confirm("⚠️ WARNUNG!\n\nMöchtest du die Gruppe wirklich löschen?\n\nGruppe: " + groupData.name + "\n\n🗑️ Dies löscht:\n• Die Gruppe\n• ALLE Mitglieder\n• ALLE Beobachtungen\n\n❌ Diese Aktion kann NICHT rückgängig gemacht werden!");
        
        if(!confirmDelete){
          console.log("   Abgebrochen");
          return;
        }
        
        // Zweite Bestätigung für Sicherheit
        var confirm2 = window.confirm("🚨 LETZTE WARNUNG!\n\nBist du ABSOLUT sicher?\n\nGruppe '" + groupData.name + "' wird unwiderruflich gelöscht!");
        
        if(!confirm2){
          console.log("   Abgebrochen bei zweiter Bestätigung");
          return;
        }
        
        console.log("🗑️ Lösche Gruppe...");
        showLoading("Lösche Gruppe...");
        
        // Lösche die Gruppe aus Firebase
        window.FBD.ref("groups/" + selectedGroup).remove().then(function(){
          console.log("✅ Gruppe erfolgreich gelöscht!");
          hideLoading();
          
          // Wechsle zu "Meine Beobachtungen"
          window.currentSelectedGroup = "personal";
          localStorage.setItem("selectedGroup", "personal");
          
          var select = document.getElementById("fbGroupSelect");
          if(select){
            select.value = "personal";
            // Trigger change event
            var event = new Event('change');
            select.dispatchEvent(event);
          }
          
          alert("✅ Gruppe erfolgreich gelöscht!\n\n" + groupData.name + " wurde entfernt.");
          
          if(typeof showNotification === "function"){
            showNotification("✅ Gruppe gelöscht");
          }
          
          // Verstecke Löschen/Umbenennen-Button
          deleteBtn.style.display = "none";
          var renameBtn = document.getElementById("fbRenameGroupBtn");
          if(renameBtn) renameBtn.style.display = "none";
          
        }).catch(function(e){
          console.error("❌ Fehler beim Löschen:", e);
          hideLoading();
          
          var msg = "❌ Fehler beim Löschen:\n\n" + e.message;
          
          if(e.code === "PERMISSION_DENIED"){
            msg += "\n\n🔒 PERMISSION_DENIED!\n\nDie Firebase Security Rules blockieren das Löschen.\n\nBitte prüfe die Rules in der Firebase Console.";
          }
          
          alert(msg);
        });
        
      }).catch(function(e){
        console.error("❌ Fehler beim Laden der Gruppe:", e);
        hideLoading();
        alert("❌ Fehler: " + e.message);
      });
    });
  }
};

// Funktion zum Aktualisieren des Benutzernamens in allen Gruppen
var updateUserNameInGroups = function(userId, newName) {
  return new Promise(function(resolve, reject) {
    console.log("🔄 Aktualisiere Namen in allen Gruppen für User:", userId);
    
    if (!window.FBD || !userId || !newName) {
      console.warn("⚠️ Fehlende Parameter für Name-Update");
      resolve();
      return;
    }
    
    // Lade alle Gruppen des Users
    window.FBD.ref("groups").once("value").then(function(snapshot) {
      if (!snapshot.exists()) {
        console.log("📭 Keine Gruppen vorhanden");
        resolve();
        return;
      }
      
      var updatePromises = [];
      var updatedCount = 0;
      
      // Durchlaufe alle Gruppen
      snapshot.forEach(function(groupSnap) {
        var groupId = groupSnap.key;
        var groupObsRef = window.FBD.ref("groups/" + groupId + "/observations");
        
        // Prüfe ob der User Beobachtungen in dieser Gruppe hat
        var groupUpdatePromise = groupObsRef.once("value").then(function(obsSnapshot) {
          if (!obsSnapshot.exists()) return;
          
          var updates = {};
          var hasUpdates = false;
          
          obsSnapshot.forEach(function(obsSnap) {
            var obs = obsSnap.val();
            if (obs.userId === userId) {
              // Aktualisiere den userName
              updates[obsSnap.key + "/userName"] = newName;
              hasUpdates = true;
              updatedCount++;
            }
          });
          
          // Führe Updates aus, falls welche vorhanden sind
          if (hasUpdates) {
            console.log("  📝 Aktualisiere " + Object.keys(updates).length + " Beobachtungen in Gruppe:", groupId);
            return groupObsRef.update(updates);
          }
        }).catch(function(error) {
          console.warn("⚠️ Fehler beim Aktualisieren in Gruppe " + groupId + ":", error);
        });
        
        updatePromises.push(groupUpdatePromise);
      });
      
      // Warte auf alle Updates
      return Promise.all(updatePromises).then(function() {
        console.log("✅ Name in " + updatedCount + " Beobachtungen aktualisiert");
        resolve();
      });
      
    }).catch(function(error) {
      console.error("❌ Fehler beim Laden der Gruppen:", error);
      reject(error);
    });
  });
};

var showPrompt=function(){
  var s=localStorage.getItem("fbPromptSeen");
  if(!s){
    var w=confirm("🌐 Cloud-Sync aktivieren?\n\n✅ Sync über Geräte\n✅ Gruppen\n✅ Backup\n\nOK = Anmelden");
    if(w){showModal()}
    localStorage.setItem("fbPromptSeen","true")
  }
};

var updateUI=function(u){
  var n=u.displayName||u.email.split("@")[0];
  document.getElementById("fbAvatar").textContent=n.charAt(0).toUpperCase();
  document.getElementById("fbName").textContent=n;
  document.getElementById("fbEmail2").textContent=u.email;
  document.getElementById("fbWidget").classList.add("show");
  document.getElementById("fbGroups").classList.add("show");
  
  // Zeige Edit-Button
  var editBtn = document.getElementById("fbEditNameBtn");
  if(editBtn) {
    editBtn.style.display = "block";
  }
  
  // Lade Gruppen
  loadUserGroups(u);
  
  // Event-Listener für Gruppenwechsel (nur einmal registrieren)
  var select = document.getElementById("fbGroupSelect");
  if(select && !window.groupSelectListenerAdded){
    select.addEventListener("change", function(){
      var selectedGroup = select.value;
      console.log("🔄 Gruppe gewechselt zu:", selectedGroup);
      
      // Speichere Auswahl GLOBAL und in localStorage
      window.currentSelectedGroup = selectedGroup;
      localStorage.setItem("selectedGroup", selectedGroup);
      console.log("💾 Gruppenwahl gespeichert in window.currentSelectedGroup UND localStorage");
      
      // Zeige/Verstecke Gruppenvergleichs-Menüpunkt
      if (typeof window.toggleGroupCompareVisibility === 'function') {
        window.toggleGroupCompareVisibility();
      }
      
      // Prüfe ob Löschen-Button und Umbenennen-Button angezeigt werden sollen
      var deleteBtn = document.getElementById("fbDeleteGroupBtn");
      var renameBtn = document.getElementById("fbRenameGroupBtn");
      if(deleteBtn || renameBtn){
        if(selectedGroup !== "personal"){
          // Prüfe ob User Admin ist
          console.log("🔍 Prüfe Admin-Status für Löschen/Umbenennen-Button...");
          window.FBD.ref("groups/" + selectedGroup + "/members/" + u.uid).once("value").then(function(snap){
            if(snap.exists() && snap.val().role === "admin"){
              console.log("✅ User ist Admin - zeige Löschen/Umbenennen-Button");
              if(deleteBtn) deleteBtn.style.display = "block";
              if(renameBtn) renameBtn.style.display = "block";
            } else {
              console.log("❌ User ist kein Admin - verstecke Löschen/Umbenennen-Button");
              if(deleteBtn) deleteBtn.style.display = "none";
              if(renameBtn) renameBtn.style.display = "none";
            }
          }).catch(function(e){
            console.error("Fehler beim Prüfen des Admin-Status:", e);
            if(deleteBtn) deleteBtn.style.display = "none";
            if(renameBtn) renameBtn.style.display = "none";
          });
        } else {
          console.log("📱 Persönlicher Modus - verstecke Löschen/Umbenennen-Button");
          if(deleteBtn) deleteBtn.style.display = "none";
          if(renameBtn) renameBtn.style.display = "none";
        }
      }
      
      // Entferne vorherige Listener wenn vorhanden
      if(window.currentGroupListener){
        window.FBD.ref("groups/" + window.currentGroupId + "/observations").off("value", window.currentGroupListener);
        console.log("🔇 Vorherigen Listener entfernt");
      }
      
      if(selectedGroup === "personal"){
        console.log("📱 Persönlicher Modus - zeige lokale Daten");
        window.currentGroupId = null;
        window.currentGroupListener = null;
        
        // Lade lokale Daten aus IndexedDB
        if(typeof loadData === "function"){
          loadData();
        }
        
        // NEU: Verstecke Gruppen-Legende im persönlichen Modus
        const legendContainer = document.getElementById('groupMarkerLegend');
        if (legendContainer) {
          legendContainer.style.display = 'none';
        }
        
        // Aktualisiere Charts und Statistiken
        console.log("📊 Aktualisiere Charts für persönliche Daten...");
        if(typeof updateChart === "function"){
          updateChart();
        }
        
        if(typeof updateAdvancedStatistics === "function"){
          updateAdvancedStatistics();
        }
        
        // Aktualisiere Mode-Banner
        if(typeof updateModeBanners === "function"){
          updateModeBanners();
        }
        
        if(typeof showNotification === "function"){
          showNotification("📱 Persönlicher Modus aktiv");
        }
      } else {
        console.log("👥 Gruppen-Modus - lade Firebase Daten");
        window.currentGroupId = selectedGroup;
        
        // Lade Gruppendaten aus Firebase
        loadGroupObservations(selectedGroup, u);
        
        // Aktualisiere Charts und Statistiken mit Gruppendaten
        console.log("📊 Aktualisiere Charts für Gruppendaten...");
        setTimeout(function(){
          if(typeof updateChart === "function"){
            updateChart();
          }
          
          if(typeof updateAdvancedStatistics === "function"){
            updateAdvancedStatistics();
          }
          
          // Aktualisiere Mode-Banner
          if(typeof updateModeBanners === "function"){
            updateModeBanners();
          }
        }, 500);
        
        if(typeof showNotification === "function"){
          showNotification("👥 Gruppen-Modus aktiv");
        }
      }
    });
    window.groupSelectListenerAdded = true;
    console.log("✅ Gruppenwechsel-Listener registriert");
  }
};

var loadUserGroups=function(u){
  console.log("🔵 ===== LADE GRUPPEN =====");
  console.log("   User UID:", u.uid);
  console.log("   User Email:", u.email);
  console.log("   Firebase Database verfügbar:", !!window.FBD);
  
  var select = document.getElementById("fbGroupSelect");
  if(!select){
    console.error("❌ Select-Element nicht gefunden! Versuche es in 500ms erneut...");
    // Versuche es nach kurzer Verzögerung erneut
    setTimeout(function(){
      console.log("🔄 Retry: loadUserGroups");
      loadUserGroups(u);
    }, 500);
    return;
  }
  
  console.log("✅ Select-Element gefunden");
  
  // Lade gespeicherte Gruppenwahl
  var savedGroup = localStorage.getItem("selectedGroup");
  console.log("💾 Gespeicherte Gruppenwahl:", savedGroup);
  
  // Lösche alte Optionen (außer "Meine Beobachtungen")
  select.innerHTML = '<option value="personal">🔒 Meine Beobachtungen</option>';
  
  // Entferne alten Listener falls vorhanden
  if(window.groupsListener){
    console.log("🔇 Entferne alten Gruppen-Listener");
    try{
      window.FBD.ref("groups").off("value", window.groupsListener);
    }catch(e){
      console.error("Fehler beim Entfernen des Listeners:", e);
    }
  }
  
  console.log("📡 Registriere Realtime-Listener für:", "groups/");
  
  // Erstelle neuen Listener
  var listener = function(snapshot){
    console.log("📊 ===== GRUPPEN-SNAPSHOT EMPFANGEN =====");
    console.log("   Snapshot exists:", snapshot.exists());
    console.log("   Anzahl Children:", snapshot.numChildren());
    
    if(!snapshot.exists()){
      console.log("ℹ️ KEINE GRUPPEN in Firebase gefunden");
      console.log("   Mögliche Ursachen:");
      console.log("   1. Noch keine Gruppen erstellt");
      console.log("   2. Security Rules blockieren Lesezugriff");
      console.log("   3. Datenbankpfad falsch");
      return;
    }
    
    // Lösche alte Gruppen-Optionen (außer personal)
    var options = select.querySelectorAll('option:not([value="personal"])');
    options.forEach(function(opt){ opt.remove(); });
    
    // Zähle Gruppen
    var count = 0;
    var foundGroups = [];
    var validSavedGroup = false;
    var totalGroups = 0;
    
    snapshot.forEach(function(childSnap){
      totalGroups++;
      var groupId = childSnap.key;
      var groupData = childSnap.val();
      
      console.log("   🔍 Prüfe Gruppe #" + totalGroups + ":", groupData.name, "ID:", groupId);
      console.log("      Members:", groupData.members ? Object.keys(groupData.members) : "keine");
      console.log("      Meine UID:", u.uid);
      console.log("      Bin ich Mitglied?", groupData.members && groupData.members[u.uid] ? "JA" : "NEIN");
      
      // Prüfe ob User Mitglied ist
      if(groupData.members && groupData.members[u.uid]){
        count++;
        var userRole = groupData.members[u.uid].role || "member";
        console.log("      ✅ Bin Mitglied! Rolle:", userRole);
        
        foundGroups.push({id: groupId, name: groupData.name, role: userRole});
        
        // Prüfe ob dies die gespeicherte Gruppe ist
        if(savedGroup === groupId){
          validSavedGroup = true;
          console.log("      💾 Dies ist die gespeicherte Gruppe!");
        }
        
        // Füge zur Auswahl hinzu
        var option = document.createElement("option");
        option.value = groupId;
        
        var roleIcon = userRole === "admin" ? "👑" : "👥";
        option.textContent = roleIcon + " " + groupData.name;
        select.appendChild(option);
        console.log("      ✅ Zur Auswahl hinzugefügt");
      } else {
        console.log("      ❌ Nicht Mitglied dieser Gruppe");
      }
    });
    
    console.log("📊 ===== GRUPPEN-LADEN ABGESCHLOSSEN =====");
    console.log("   Gruppen in Firebase gesamt:", totalGroups);
    console.log("   Davon bin ich Mitglied:", count);
    console.log("   Gefundene Gruppen:", foundGroups);
    
    // Stelle gespeicherte Auswahl wieder her
    if(validSavedGroup && savedGroup !== "personal"){
      console.log("🔄 Stelle gespeicherte Gruppe wieder her:", savedGroup);
      select.value = savedGroup;
      window.currentSelectedGroup = savedGroup;
      console.log("💾 window.currentSelectedGroup gesetzt auf:", savedGroup);
      
      // Prüfe ob User Admin ist und zeige Löschen/Umbenennen-Button
      var deleteBtn = document.getElementById("fbDeleteGroupBtn");
      var renameBtn = document.getElementById("fbRenameGroupBtn");
      if(deleteBtn || renameBtn){
        // Finde die gespeicherte Gruppe in foundGroups
        var savedGroupInfo = foundGroups.find(function(g){ return g.id === savedGroup; });
        if(savedGroupInfo && savedGroupInfo.role === "admin"){
          console.log("👑 User ist Admin - zeige Löschen/Umbenennen-Button");
          if(deleteBtn) deleteBtn.style.display = "block";
          if(renameBtn) renameBtn.style.display = "block";
        } else {
          console.log("👥 User ist kein Admin - verstecke Löschen/Umbenennen-Button");
          if(deleteBtn) deleteBtn.style.display = "none";
          if(renameBtn) renameBtn.style.display = "none";
        }
      }
      
      // Lade Beobachtungen dieser Gruppe
      setTimeout(function(){
        console.log("⏰ Lade Beobachtungen nach 100ms...");
        loadGroupObservations(savedGroup, u);
        
        // Aktualisiere Mode-Banner, Charts und Statistiken nach kurzer Verzögerung
        setTimeout(function(){
          if(typeof updateModeBanners === "function"){
            updateModeBanners();
          }
          if(typeof updateChart === "function"){
            updateChart();
          }
          if(typeof updateAdvancedStatistics === "function"){
            updateAdvancedStatistics();
          }
        }, 500);
      }, 100);
    } else if(savedGroup && savedGroup !== "personal"){
      console.log("⚠️ Gespeicherte Gruppe nicht mehr verfügbar:", savedGroup);
      localStorage.removeItem("selectedGroup");
      window.currentSelectedGroup = "personal";
      
      // Verstecke Löschen/Umbenennen-Button
      var deleteBtn = document.getElementById("fbDeleteGroupBtn");
      var renameBtn = document.getElementById("fbRenameGroupBtn");
      if(deleteBtn) deleteBtn.style.display = "none";
      if(renameBtn) renameBtn.style.display = "none";
      
      // Aktualisiere Mode-Banner
      if(typeof updateModeBanners === "function"){
        updateModeBanners();
      }
    } else {
      console.log("ℹ️ Keine gespeicherte Gruppe oder 'personal' ausgewählt");
      window.currentSelectedGroup = "personal";
      
      // Verstecke Löschen/Umbenennen-Button
      var deleteBtn = document.getElementById("fbDeleteGroupBtn");
      var renameBtn = document.getElementById("fbRenameGroupBtn");
      if(deleteBtn) deleteBtn.style.display = "none";
      if(renameBtn) renameBtn.style.display = "none";
      
      // Aktualisiere Mode-Banner
      if(typeof updateModeBanners === "function"){
        updateModeBanners();
      }
    }
    
    if(count > 0){
      console.log("✅ Erfolgreich " + count + " Gruppe(n) geladen!");
      if(typeof showNotification === "function"){
        showNotification("✅ " + count + " Gruppe(n) geladen");
      }
    } else {
      console.log("⚠️ Keine Gruppen gefunden in denen du Mitglied bist");
      console.log("   Tipp: Erstelle eine Gruppe oder tritt einer bei");
    }
  };
  
  // Speichere Listener
  window.groupsListener = listener;
  
  // Registriere Listener mit Fehlerbehandlung
  try{
    window.FBD.ref("groups").on("value", listener, function(error){
      console.error("❌ Firebase Listener Fehler:", error);
      console.log("   Error Code:", error.code);
      console.log("   Error Message:", error.message);
      
      if(error.code === "PERMISSION_DENIED"){
        alert("❌ PERMISSION_DENIED!\n\nDie Firebase Security Rules blockieren das Laden der Gruppen.\n\nBitte prüfe die Security Rules in der Firebase Console.");
      }
    });
    console.log("✅ Realtime-Listener registriert");
  }catch(e){
    console.error("❌ Fehler beim Registrieren des Listeners:", e);
  }
};

var showModal=function(){document.getElementById("fbModal").classList.add("show")};
var hideModal=function(){document.getElementById("fbModal").classList.remove("show")};
var showLoading=function(text){
  var t=document.getElementById("fbLoadingText");
  if(t&&text)t.textContent=text;
  document.getElementById("fbLoading").classList.add("show")
};
var hideLoading=function(){document.getElementById("fbLoading").classList.remove("show")};

// Funktion zum Laden von Gruppen-Beobachtungen
var loadGroupObservations=function(groupId, user){
  console.log("🔵 Lade Beobachtungen für Gruppe:", groupId);
  
  showLoading("Lade Gruppenbeobachtungen...");
  
  // Zeige Loading-Status im Container
  var container = document.getElementById("folders");
  if(container){
    container.innerHTML = '<div class="card" style="margin-top:12px;padding:20px;text-align:center;color:var(--muted);">⏳ Lade Beobachtungen...</div>';
  }
  
  // Erstelle Listener-Funktion
  var listener = function(snapshot){
    console.log("📊 Beobachtungen-Snapshot erhalten");
    console.log("   Snapshot exists:", snapshot.exists());
    console.log("   Anzahl Beobachtungen:", snapshot.numChildren());
    
    if(!snapshot.exists() || snapshot.numChildren() === 0){
      console.log("ℹ️ Noch keine Beobachtungen in dieser Gruppe");
      if(container){
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">🦜</div>
            <div class="empty-state-title">Noch keine Beobachtungen</div>
            <div class="empty-state-description">
              Die Gruppe ist noch leer. Sei der Erste und füge eine Beobachtung hinzu! 
              Nutze die Karte oder die Schnelleingabe (⚡ Button unten rechts).
            </div>
            <button onclick="openQuickAdd()" class="btn" style="background:linear-gradient(135deg, var(--accent), var(--accent-2));margin-top:8px;">
              ⚡ Erste Beobachtung hinzufügen
            </button>
          </div>
        `;
      }
      hideLoading();
      if(typeof showNotification === "function"){
        showNotification("📭 Noch keine Beobachtungen");
      }
      
      // Lösche Marker von der Karte
      if(typeof markerCluster !== "undefined" && markerCluster){
        markerCluster.clearLayers();
      }
      if(typeof window.markers !== "undefined" && window.markers){
        window.markers.clear();
      }
      
      return;
    }
    
    var observations = [];
    snapshot.forEach(function(childSnap){
      var obs = childSnap.val();
      obs.id = childSnap.key;
      observations.push(obs);
      console.log("   📝 Beobachtung:", obs.bird, "von", obs.userName);
    });
    
    console.log("✅ " + observations.length + " Beobachtungen geladen");
    
    // Zeige Beobachtungen an
    displayGroupObservations(observations);
    
    hideLoading();
    if(typeof showNotification === "function"){
      showNotification("✅ " + observations.length + " Beobachtungen geladen");
    }
  };
  
  // Speichere Listener für spätere Entfernung
  window.currentGroupListener = listener;
  
  // Lade Beobachtungen aus Firebase mit Realtime-Updates
  console.log("📡 Registriere Realtime-Listener für:", "groups/" + groupId + "/observations");
  window.FBD.ref("groups/" + groupId + "/observations").on("value", listener);
};

// Funktion zum Anzeigen von Gruppen-Beobachtungen
var displayGroupObservations=function(observations){
  console.log("🎨 Zeige", observations.length, "Beobachtungen an");
  
  // Verwende das gleiche Container-Element wie loadData
  var container = document.getElementById("folders");
  if(!container){
    console.error("❌ folders Container nicht gefunden!");
    return;
  }
  
  container.innerHTML = '';
  
  // Füge Hinweis hinzu dass wir im Gruppenmodus sind
  var infoBox = document.createElement("div");
  infoBox.className = "card";
  infoBox.style.marginTop = "12px";
  infoBox.style.padding = "12px";
  infoBox.style.background = "linear-gradient(135deg, rgba(6,182,212,0.1), rgba(124,58,237,0.05))";
  infoBox.style.borderLeft = "4px solid #06b6d4";
  infoBox.innerHTML = '<div style="display:flex;align-items:center;gap:8px;"><span style="font-size:20px;">👥</span><div><strong>Gruppen-Modus aktiv</strong><div class="muted" style="font-size:12px;margin-top:2px;">Du siehst Beobachtungen von allen Gruppenmitgliedern in Echtzeit</div></div></div>';
  container.appendChild(infoBox);
  
  if(observations.length === 0){
    var emptyBox = document.createElement("div");
    emptyBox.className = "card";
    emptyBox.style.marginTop = "12px";
    emptyBox.style.padding = "20px";
    emptyBox.style.textAlign = "center";
    emptyBox.style.color = "var(--muted)";
    emptyBox.innerHTML = '📭 Noch keine Beobachtungen in dieser Gruppe.<br><br>Gehe zur Karte und füge die erste Beobachtung hinzu!';
    container.appendChild(emptyBox);
    return;
  }
  
  // Gruppiere nach Benutzer
  var byUser = {};
  
  // Hole aktuellen displayName für den eingeloggten User
  var currentUserId = null;
  var currentDisplayName = null;
  if (window.FBA && window.FBA.currentUser) {
    currentUserId = window.FBA.currentUser.uid;
    currentDisplayName = window.FBA.currentUser.displayName || window.FBA.currentUser.email.split("@")[0];
  }
  
  observations.forEach(function(obs){
    var userName = obs.userName || obs.userEmail || "Unbekannt";
    
    // Überschreibe mit aktuellem displayName, falls es der eingeloggte User ist
    if (currentUserId && obs.userId === currentUserId && currentDisplayName) {
      userName = currentDisplayName;
    }
    
    if(!byUser[userName]){
      byUser[userName] = [];
    }
    byUser[userName].push(obs);
  });
  
  // Erstelle für jeden Benutzer einen "Ordner"
  Object.keys(byUser).forEach(function(userName, index){
    var userObs = byUser[userName];
    
    // Verwende die gleiche Struktur wie in loadData/updateUIWithData
    var folder = document.createElement("div");
    folder.className = "folder card";
    folder.dataset.folderId = "group_user_" + index;
    folder.style.marginTop = "12px";
    folder.style.borderLeft = "4px solid #06b6d4";
    
    var html = '<div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">';
    html += '<div style="width:16px;height:16px;border-radius:4px;background:#06b6d4;"></div>';
    html += '<h3 style="margin:0;flex:1;">👤 ' + userName + ' (' + userObs.length + ' Beobachtungen)</h3>';
    html += '</div>';
    
    html += '<div class="maps"><div class="mapbox">';
    html += '<h4>Beobachtungen</h4>';
    html += '<table class="input-table"><thead><tr>';
    html += '<th>Vogelart</th><th>Datum</th><th>Zeit</th><th>Koordinaten</th><th>Details</th>';
    html += '</tr></thead><tbody>';
    
    userObs.forEach(function(obs){
      html += '<tr data-id="' + obs.id + '" style="background:rgba(255,255,255,0.02);">';
      html += '<td><strong>' + (obs.bird || '?') + '</strong></td>';
      html += '<td>' + (obs.date || '?') + '</td>';
      html += '<td>' + (obs.time || '-') + '</td>';
      html += '<td style="font-family:monospace;font-size:12px;">' + (obs.lat || '?') + ', ' + (obs.lng || '?') + '</td>';
      html += '<td style="font-size:12px;color:var(--muted);">';
      if(obs.count) html += '<span title="Anzahl">🔢 ' + obs.count + '</span> ';
      if(obs.behavior) html += '<span title="Verhalten">🐦 ' + obs.behavior + '</span> ';
      if(obs.weather) html += '<span title="Wetter">🌤️ ' + obs.weather + '</span>';
      html += '</td>';
      html += '</tr>';
    });
    
    html += '</tbody></table>';
    html += '</div></div>';
    
    folder.innerHTML = html;
    container.appendChild(folder);
  });
  
  console.log("✅ Beobachtungen für", Object.keys(byUser).length, "Benutzer angezeigt");
  
  // Aktualisiere auch die Karte
  updateMapWithGroupObservations(observations);
  
  // Aktualisiere Dashboard-Statistiken mit Gruppendaten
  updateDashboardWithGroupData(observations);
};

// Funktion zum Aktualisieren der Karte mit Gruppen-Beobachtungen
var updateMapWithGroupObservations=function(observations){
  console.log("🗺️ Aktualisiere Karte mit", observations.length, "Beobachtungen");
  
  // Wenn Marker gerade wiederhergestellt werden, überspringe diese Aktualisierung
  if (typeof isRestoringMarkers !== "undefined" && isRestoringMarkers) {
    console.log("Marker werden gerade wiederhergestellt - überspringe Aktualisierung");
    return;
  }
  
  // Wenn Heatmap aktiv ist, überspringe die Marker-Aktualisierung
  if (typeof heatmapLayer !== "undefined" && heatmapLayer && typeof window.mapObj !== "undefined" && window.mapObj && window.mapObj.hasLayer(heatmapLayer)) {
    console.log("Heatmap ist aktiv - überspringe Marker-Aktualisierung");
    return;
  }
  
  // Stelle sicher, dass markerCluster auf der Karte ist
  if (typeof markerCluster !== "undefined" && markerCluster && typeof window.mapObj !== "undefined" && window.mapObj && !window.mapObj.hasLayer(markerCluster)) {
    console.log("Füge markerCluster zur Karte hinzu");
    window.mapObj.addLayer(markerCluster);
  }
  
  // Lösche alle Marker
  if(typeof markerCluster !== "undefined" && markerCluster){
    markerCluster.clearLayers();
  }
  if(typeof window.markers !== "undefined" && window.markers){
    window.markers.clear();
  }
  
  // Füge neue Marker hinzu
  observations.forEach(function(obs){
    if(obs.lat && obs.lng && typeof createMarker === "function"){
      try{
        createMarker(obs.id, parseFloat(obs.lat), parseFloat(obs.lng), obs.bird, obs.date, obs);
      }catch(e){
        console.error("Fehler beim Erstellen des Markers:", e);
      }
    }
  });
  
  console.log("✅ Karte aktualisiert");
};

// Funktion zum Aktualisieren des Dashboards mit Gruppendaten
var updateDashboardWithGroupData=function(observations){
  console.log("📊 Aktualisiere Dashboard mit Gruppendaten");
  
  try{
    // WICHTIG: Filtere nicht-tickbare Arten heraus
    observations = observations.filter(obs => obs.tickable !== false);
    
    // Zähle Gesamtzahl
    var totalObs = observations.length;
    var totalObsEl = document.getElementById("totalObs");
    if(totalObsEl) totalObsEl.textContent = totalObs;
    
    // Zähle verschiedene Arten
    var uniqueSpecies = {};
    observations.forEach(function(obs){
      if(obs.bird) uniqueSpecies[obs.bird] = true;
    });
    var speciesCount = Object.keys(uniqueSpecies).length;
    var uniqueSpeciesEl = document.getElementById("uniqueSpecies");
    if(uniqueSpeciesEl) uniqueSpeciesEl.textContent = speciesCount;
    
    // Zähle Beobachter
    var uniqueObservers = {};
    observations.forEach(function(obs){
      var userName = obs.userName || obs.userEmail || "Unbekannt";
      uniqueObservers[userName] = true;
    });
    var observerCount = Object.keys(uniqueObservers).length;
    
    // Aktualisiere zusätzliche Statistiken wenn vorhanden
    var statsContainer = document.querySelector("#home .kpi");
    if(statsContainer && observerCount > 0){
      // Füge Beobachter-Statistik hinzu wenn noch nicht vorhanden
      var observerStat = document.getElementById("totalObservers");
      if(!observerStat){
        var newKpi = document.createElement("div");
        newKpi.className = "kpi";
        newKpi.innerHTML = '<div><div class="muted">Beobachter</div><div class="value" id="totalObservers">' + observerCount + '</div></div>';
        statsContainer.appendChild(newKpi);
      } else {
        observerStat.textContent = observerCount;
      }
    }
    
    console.log("✅ Dashboard aktualisiert:", totalObs, "Beobachtungen,", speciesCount, "Arten,", observerCount, "Beobachter");
  }catch(e){
    console.error("Fehler beim Dashboard-Update:", e);
  }
};

// Funktion zum Aktualisieren der Mode-Banner auf Analyse- und Statistik-Seiten
var updateModeBanners=function(){
  var diagrammeBanner = document.getElementById("diagrammeModeBanner");
  var statistikenBanner = document.getElementById("statistikenModeBanner");
  
  if(window.currentSelectedGroup && window.currentSelectedGroup !== "personal"){
    // Gruppen-Modus
    var bannerHTML = '<div class="card" style="padding:12px;background:linear-gradient(135deg, rgba(6,182,212,0.1), rgba(124,58,237,0.05));border-left:4px solid #06b6d4;">' +
      '<div style="display:flex;align-items:center;gap:8px;">' +
      '<span style="font-size:20px;">👥</span>' +
      '<div><strong>Gruppen-Modus aktiv</strong>' +
      '<div class="muted" style="font-size:12px;margin-top:2px;">Daten von allen Gruppenmitgliedern</div></div>' +
      '</div></div>';
    
    if(diagrammeBanner){
      diagrammeBanner.innerHTML = bannerHTML;
      diagrammeBanner.style.display = "block";
    }
    if(statistikenBanner){
      statistikenBanner.innerHTML = bannerHTML;
      statistikenBanner.style.display = "block";
    }
  } else {
    // Persönlicher Modus
    if(diagrammeBanner) diagrammeBanner.style.display = "none";
    if(statistikenBanner) statistikenBanner.style.display = "none";
  }
};

// ============================================================
// GRUPPENVERGLEICHS-FUNKTIONEN
// ============================================================

// Tab-Wechsel im Gruppenvergleich
function switchCompareTab(tab) {
  // Tab-Buttons aktualisieren
  document.querySelectorAll('#group-compare .small-btn').forEach(btn => {
    btn.classList.remove('active');
    btn.style.background = '';
    btn.style.border = '1px solid rgba(255,255,255,0.1)';
    btn.style.transform = '';
  });
  
  if (tab === 'observations') {
    document.getElementById('compareObsTab').classList.add('active');
    document.getElementById('compareObsTab').style.background = 'linear-gradient(135deg, rgba(6,182,212,0.2), rgba(124,58,237,0.1))';
    document.getElementById('compareObsTab').style.border = '2px solid #06b6d4';
    document.getElementById('compareObsTab').style.transform = 'scale(1.02)';
    document.getElementById('compareObservationsView').style.display = 'block';
    document.getElementById('compareListsView').style.display = 'none';
    document.getElementById('compareRarity2026View').style.display = 'none';
    document.getElementById('compareAchievementsView').style.display = 'none';
    document.getElementById('compareStatsView').style.display = 'none';
  } else if (tab === 'lists') {
    document.getElementById('compareListsTab').classList.add('active');
    document.getElementById('compareListsTab').style.background = 'linear-gradient(135deg, rgba(124,58,237,0.2), rgba(6,182,212,0.1))';
    document.getElementById('compareListsTab').style.border = '2px solid #7c3aed';
    document.getElementById('compareListsTab').style.transform = 'scale(1.02)';
    document.getElementById('compareObservationsView').style.display = 'none';
    document.getElementById('compareListsView').style.display = 'block';
    document.getElementById('compareRarity2026View').style.display = 'none';
    document.getElementById('compareAchievementsView').style.display = 'none';
    document.getElementById('compareStatsView').style.display = 'none';
    renderComparisonFolders(); // Lade Listen-Vergleich
  } else if (tab === 'rarity2026') {
    document.getElementById('compareRarityTab').classList.add('active');
    document.getElementById('compareRarityTab').style.background = 'linear-gradient(135deg, rgba(234,179,8,0.25), rgba(217,119,6,0.15))';
    document.getElementById('compareRarityTab').style.border = '2px solid #eab308';
    document.getElementById('compareRarityTab').style.transform = 'scale(1.02)';
    document.getElementById('compareObservationsView').style.display = 'none';
    document.getElementById('compareListsView').style.display = 'none';
    document.getElementById('compareRarity2026View').style.display = 'block';
    document.getElementById('compareAchievementsView').style.display = 'none';
    document.getElementById('compareStatsView').style.display = 'none';
    renderRarityChallenge2026(); // Lade Rarität-Challenge
  } else if (tab === 'achievements') {
    document.getElementById('compareAchTab').classList.add('active');
    document.getElementById('compareAchTab').style.background = 'linear-gradient(135deg, rgba(124,58,237,0.2), rgba(6,182,212,0.1))';
    document.getElementById('compareAchTab').style.border = '2px solid #7c3aed';
    document.getElementById('compareAchTab').style.transform = 'scale(1.02)';
    document.getElementById('compareObservationsView').style.display = 'none';
    document.getElementById('compareListsView').style.display = 'none';
    document.getElementById('compareRarity2026View').style.display = 'none';
    document.getElementById('compareAchievementsView').style.display = 'block';
    document.getElementById('compareStatsView').style.display = 'none';
  } else if (tab === 'stats') {
    document.getElementById('compareStatsTab').classList.add('active');
    document.getElementById('compareStatsTab').style.background = 'linear-gradient(135deg, rgba(6,182,212,0.2), rgba(34,197,94,0.1))';
    document.getElementById('compareStatsTab').style.border = '2px solid #06b6d4';
    document.getElementById('compareStatsTab').style.transform = 'scale(1.02)';
    document.getElementById('compareObservationsView').style.display = 'none';
    document.getElementById('compareListsView').style.display = 'none';
    document.getElementById('compareRarity2026View').style.display = 'none';
    document.getElementById('compareAchievementsView').style.display = 'none';
    document.getElementById('compareStatsView').style.display = 'block';
  }
}

// Hilfsfunktion: Raritätenpunkte für Benutzer hinzufügen (wird beim Import verwendet)
async function addRarityPointsForUser(groupId, userEmail, observation) {
  // Diese Funktion ist eigentlich nicht notwendig, da die Punkte dynamisch
  // beim Rendern der Challenge berechnet werden. Die Beobachtungen mit
  // rarity-Informationen werden automatisch gezählt.
  // Diese Funktion dient nur als Platzhalter für zukünftige Erweiterungen.
  console.log(`💎 Raritätenpunkte werden automatisch berechnet für ${userEmail}:`, {
    bird: observation.bird,
    rarity: observation.rarity,
    date: observation.date
  });
}

// Rarität-Challenge 2026 rendern
async function renderRarityChallenge2026() {
  console.log('💎 Lade Rarität-Challenge...');
  
  if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
    console.log('⚠️ Kein Gruppenmodus aktiv');
    return;
  }
  
  // NEU: Prüfe ob aktueller User ein Admin ist
  const isAdmin = await isCurrentUserGroupAdmin();
  console.log('🔐 Ist User Admin:', isAdmin);
  
  // Hole das ausgewählte Jahr
  const yearSelect = document.getElementById('rarityChallengeYearSelect');
  const selectedYear = yearSelect ? yearSelect.value : '2026';
  
  console.log('📅 Ausgewähltes Jahr:', selectedYear);
  
  try {
    const groupData = await loadGroupData();
    
    // Prüfe ob groupData und userStats vorhanden sind
    if (!groupData || !groupData.userStats) {
      console.log('⚠️ Keine Gruppendaten verfügbar');
      const leaderboardContainer = document.getElementById('rarityLeaderboard2026');
      if (leaderboardContainer) {
        leaderboardContainer.innerHTML = `
          <div style="text-align:center;padding:40px 20px;color:var(--muted);">
            <div style="font-size:48px;margin-bottom:12px;">⚠️</div>
            <p>Keine Gruppendaten verfügbar</p>
            <p style="font-size:12px;margin-top:8px;">Stelle sicher, dass du in einer Gruppe bist.</p>
          </div>
        `;
      }
      return;
    }
    
    const leaderboard = [];
    
    // NEU: Sammle ALLE seltenen Beobachtungen aller Nutzer für Duplikatsprüfung
    const allRareObservations = [];
    
    for (const [uid, userData] of Object.entries(groupData.userStats)) {
      const observations = userData.observations || [];
      
      // Prüfe ob manuelle Flags vorhanden sind (DEBUG)
      const manuallyBlockedCount = observations.filter(o => o.manuallyBlocked === true).length;
      const manuallyUnblockedCount = observations.filter(o => o.manuallyUnblocked === true).length;
      if (manuallyBlockedCount > 0 || manuallyUnblockedCount > 0) {
        console.log(`🔍 ${userData.userName}: ${manuallyBlockedCount} manuell blockiert, ${manuallyUnblockedCount} manuell entblockt`);
      }
      
      // Filtere nach Jahr und sammle seltene Arten
      observations.forEach(obs => {
        if (!obs.date) return;
        
        // NEU: Überspringe Nullmeldungen
        if (!isValidObservation(obs)) {
          return;
        }
        
        // Jahr-Filter anwenden
        if (selectedYear !== 'all') {
          const year = new Date(obs.date).getFullYear();
          if (year !== parseInt(selectedYear)) return;
        }
        
        // Prüfe ob selten oder sehr selten
        let rarity = obs.rarity || null;
        if (!rarity && obs.bird && birdDatabase[obs.bird]) {
          rarity = birdDatabase[obs.bird].status;
        }
        
        const normalizedRarity = (rarity || '').toLowerCase();
        if (normalizedRarity === 'selten' || normalizedRarity === 'sehr selten') {
          allRareObservations.push({
            ...obs,
            userId: uid,
            userName: userData.userName,
            rarity: normalizedRarity
          });
        }
      });
    }
    
    // Sortiere alle seltenen Beobachtungen nach Datum (älteste zuerst)
    allRareObservations.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    console.log(`📊 Gesamt ${allRareObservations.length} seltene Beobachtungen für Duplikatsprüfung`);
    
    // Hilfsfunktion: Berechne Distanz zwischen zwei Koordinaten in km (Haversine-Formel)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Erdradius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Hilfsfunktion: Prüfe ob Beobachtung Punkte bringt (keine vorherige Meldung in 3 Wochen / 3km)
    function isValidForPoints(obs, index) {
      // NEU: Wenn manuell blockiert, keine Punkte vergeben
      if (obs.manuallyBlocked === true) {
        console.log(`   🚫 Manuell blockiert: ${obs.bird} von ${obs.userName} (${obs.date}) - bringt keine Punkte`);
        return false;
      }
      
      // NEU: Wenn manuell entblockt, immer Punkte vergeben
      if (obs.manuallyUnblocked === true) {
        console.log(`   ✓ Manuell entblockt: ${obs.bird} von ${obs.userName} (${obs.date}) - bringt Punkte`);
        return true;
      }
      
      const obsDate = new Date(obs.date);
      const threeWeeksInMs = 21 * 24 * 60 * 60 * 1000;
      
      // Prüfe alle FRÜHEREN Beobachtungen
      for (let i = 0; i < index; i++) {
        const prevObs = allRareObservations[i];
        
        // NEU: Überspringe wenn die vorherige Beobachtung von einem anderen Benutzer ist
        // Die Regel gilt nur für eigene Beobachtungen
        if (prevObs.userId !== obs.userId) continue;
        
        // NEU: WICHTIG! Überspringe manuell blockierte Beobachtungen KOMPLETT!
        // Eine blockierte Beobachtung soll behandelt werden, als ob sie nicht existiert!
        // Das bedeutet: Sie kann nicht als "erste Meldung" zählen, die andere blockiert
        if (prevObs.manuallyBlocked === true) {
          console.log(`   ⏭️ Ignoriere blockierte Beobachtung für Duplikatsprüfung (isValidForPoints): ${prevObs.bird} (${prevObs.date})`);
          continue; // Diese Beobachtung wird komplett ignoriert
        }
        
        // Gleiche Art?
        if (prevObs.bird !== obs.bird) continue;
        
        // Innerhalb der letzten 3 Wochen?
        const prevDate = new Date(prevObs.date);
        const timeDiff = obsDate - prevDate;
        if (timeDiff < 0 || timeDiff > threeWeeksInMs) continue;
        
        // Innerhalb von 3km?
        const distance = calculateDistance(
          obs.lat, obs.lng,
          prevObs.lat, prevObs.lng
        );
        
        if (distance <= 3) {
          console.log(`   ⚠️ Duplikat gefunden: ${obs.bird} von ${obs.userName} (${obs.date}) - bereits selbst am ${prevObs.date} gemeldet (${distance.toFixed(2)}km entfernt)`);
          return false;
        }
      }
      
      return true;
    }
    
    // Für jedes Gruppenmitglied Punkte berechnen
    for (const [uid, userData] of Object.entries(groupData.userStats)) {
      const observations = userData.observations || [];
      
      // Filtere Beobachtungen nach ausgewähltem Jahr UND entferne Nullmeldungen
      const filteredObs = observations.filter(obs => {
        if (!obs.date) return false;
        
        // NEU: Überspringe Nullmeldungen
        if (!isValidObservation(obs)) return false;
        
        if (selectedYear === 'all') return true;
        const year = new Date(obs.date).getFullYear();
        return year === parseInt(selectedYear);
      });
      
      console.log(`📊 ${userData.userName}: ${filteredObs.length} Beobachtungen für ${selectedYear}`);
      
      // DEBUG: Zeige alle Beobachtungen mit ihren IDs
      if (filteredObs.length > 0) {
        const rareObs = filteredObs.filter(o => {
          const r = o.rarity || (o.bird && birdDatabase[o.bird] ? birdDatabase[o.bird].status : null);
          return (r || '').toLowerCase() === 'selten' || (r || '').toLowerCase() === 'sehr selten';
        });
        if (rareObs.length > 0) {
          console.log(`   📋 Seltene Beobachtungen (${rareObs.length}):`, rareObs.map(o => ({
            id: o.id,
            bird: o.bird,
            date: o.date,
            manuallyBlocked: o.manuallyBlocked,
            manuallyUnblocked: o.manuallyUnblocked
          })));
        }
      }
      
      // Debug: Zeige erste Beobachtung mit Seltenheitsinformation
      if (filteredObs.length > 0) {
        const firstObs = filteredObs[0];
        const rarityFromObs = firstObs.rarity;
        const rarityFromDB = firstObs.bird && birdDatabase[firstObs.bird] ? birdDatabase[firstObs.bird].status : null;
        const finalRarity = rarityFromObs || rarityFromDB;
        
        console.log('   Beispiel-Beobachtung:', {
          bird: firstObs.bird,
          rarity_in_obs: rarityFromObs,
          rarity_from_db: rarityFromDB,
          final_rarity: finalRarity,
          selffound: firstObs.selffound,
          date: firstObs.date
        });
      }
      
      let points = 0;
      let rareCount = 0;
      let veryRareCount = 0;
      let selffoundBonus = 0;
      let rareSelffoundCount = 0;
      let veryRareSelffoundCount = 0;
      let duplicateCount = 0; // NEU: Zähle blockierte Duplikate
      const blockedSpecies = []; // NEU: Speichere blockierte Arten mit Details
      
      filteredObs.forEach(obs => {
        // DEBUG: Log JEDE Beobachtung mit allen relevanten Flags
        if ((obs.rarity || (obs.bird && birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : '')).toLowerCase() === 'selten' || 
            (obs.rarity || (obs.bird && birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : '')).toLowerCase() === 'sehr selten') {
          console.log(`🔍 Verarbeite seltene Beobachtung:`, {
            id: obs.id,
            bird: obs.bird,
            date: obs.date,
            time: obs.time,
            manuallyBlocked: obs.manuallyBlocked,
            manuallyUnblocked: obs.manuallyUnblocked,
            rarity: obs.rarity
          });
        }
        
        // NEU: Prüfe zuerst obs.rarity, falls nicht vorhanden, checke Vogeldatenbank
        let rarity = obs.rarity || null;
        
        // Fallback: Wenn kein rarity-Feld vorhanden, prüfe Vogeldatenbank
        if (!rarity && obs.bird && birdDatabase[obs.bird]) {
          rarity = birdDatabase[obs.bird].status;
        }
        
        // Normalisiere auf Kleinbuchstaben
        rarity = (rarity || 'Nicht bewertet').toLowerCase();
        
        const isSelffound = obs.selffound === true;
        
        // DEBUG: Log manual block flags
        if (obs.manuallyBlocked || obs.manuallyUnblocked) {
          console.log('🔍 Beobachtung mit Manual Flag gefunden:', {
            id: obs.id,
            bird: obs.bird,
            manuallyBlocked: obs.manuallyBlocked,
            manuallyUnblocked: obs.manuallyUnblocked,
            date: obs.date
          });
        }
        
        // NEU: Prüfe ob diese Beobachtung Punkte bringen darf (keine Duplikate)
        if (rarity === 'selten' || rarity === 'sehr selten') {
          // NEU: Prüfe zuerst ob diese SPEZIFISCHE Beobachtung manuell blockiert wurde
          // Wichtig: Nur diese eine Beobachtung mit dieser ID wird blockiert, nicht alle der gleichen Art!
          if (obs.manuallyBlocked === true) {
            console.log(`   🚫 Beobachtung manuell blockiert (ID: ${obs.id}): ${obs.bird} von ${userData.userName} (${obs.date}) - bringt keine Punkte`);
            // Diese spezifische Beobachtung wurde manuell blockiert - keine Punkte vergeben
            duplicateCount++;
            blockedSpecies.push({
              id: obs.id,
              bird: obs.bird,
              date: obs.date,
              rarity: rarity,
              selffound: isSelffound,
              count: obs.count,
              time: obs.time,
              lat: obs.lat,
              lng: obs.lng,
              manuallyBlocked: true, // NEU: Flag für Banner
              blockedBy: null,
              blockedByUserId: null,
              blockedDate: null,
              distance: null,
              daysDiff: null
            });
            return; // Überspringe NUR diese Beobachtung
          }
          
          // NEU: Wenn diese spezifische Beobachtung manuell entblockt wurde, zählt sie immer
          if (obs.manuallyUnblocked === true) {
            console.log(`   ✅ Beobachtung manuell entblockt (ID: ${obs.id}): ${obs.bird} von ${userData.userName} (${obs.date}) - bringt Punkte`);
            // Diese Beobachtung wurde explizit entblockt - überspringe Duplikatsprüfung
          } else {
          
          // Finde den Index dieser Beobachtung in allRareObservations
          const obsIndex = allRareObservations.findIndex(rareObs => 
            rareObs.id === obs.id || 
            (rareObs.bird === obs.bird && 
             rareObs.date === obs.date && 
             rareObs.userId === uid &&
             Math.abs(rareObs.lat - obs.lat) < 0.0001 &&
             Math.abs(rareObs.lng - obs.lng) < 0.0001)
          );
          
          if (obsIndex !== -1) {
            const currentObs = allRareObservations[obsIndex];
            
            // NEU: Wenn manuell entblockt, keine Duplikatsprüfung durchführen
            if (currentObs.manuallyUnblocked === true) {
              // Diese Art wurde manuell entblockt - zählt immer
            } else {
              // Finde die blockierende Beobachtung (falls vorhanden)
              let blockingObs = null;
              const obsDate = new Date(currentObs.date);
              const threeWeeksInMs = 21 * 24 * 60 * 60 * 1000;
              
              for (let i = 0; i < obsIndex; i++) {
                const prevObs = allRareObservations[i];
                
                // NEU: Überspringe wenn die vorherige Beobachtung von einem anderen Benutzer ist
                if (prevObs.userId !== currentObs.userId) continue;
                
                // NEU: WICHTIG! Überspringe manuell blockierte Beobachtungen KOMPLETT!
                // Eine blockierte Beobachtung soll behandelt werden, als ob sie nicht existiert!
                // Das bedeutet: Sie kann nicht als "erste Meldung" zählen, die andere blockiert
                if (prevObs.manuallyBlocked === true) {
                  console.log(`   ⏭️ Ignoriere blockierte Beobachtung für Duplikatsprüfung: ${prevObs.bird} (${prevObs.date}, ID: ${prevObs.id})`);
                  continue; // Diese Beobachtung wird komplett ignoriert
                }
                
                if (prevObs.bird !== currentObs.bird) continue;
                
                const prevDate = new Date(prevObs.date);
                const timeDiff = obsDate - prevDate;
                if (timeDiff < 0 || timeDiff > threeWeeksInMs) continue;
                
                const distance = calculateDistance(
                  currentObs.lat, currentObs.lng,
                  prevObs.lat, prevObs.lng
                );
                
                if (distance <= 3) {
                  blockingObs = {
                    ...prevObs,
                    distance: distance,
                    daysDiff: Math.floor(timeDiff / (24 * 60 * 60 * 1000))
                  };
                  break;
              }
            }
            
            if (blockingObs) {
              // Diese Beobachtung ist ein Duplikat - keine Punkte vergeben
              console.log(`   ❌ DUPLIKAT GEFUNDEN: ${obs.bird} (${obs.date}, ID: ${obs.id}) wird blockiert durch frühere Meldung vom ${blockingObs.date} (Distanz: ${blockingObs.distance.toFixed(2)}km, ${blockingObs.daysDiff} Tage)`);
              duplicateCount++;
              blockedSpecies.push({
                id: obs.id, // NEU: Füge ID hinzu für Buttons
                bird: obs.bird,
                date: obs.date,
                rarity: rarity,
                selffound: isSelffound,
                count: obs.count, // NEU: Anzahl
                time: obs.time, // NEU: Uhrzeit
                lat: obs.lat, // NEU: Koordinaten
                lng: obs.lng,
                manuallyBlocked: false, // Automatisch blockiert
                blockedBy: blockingObs.userName,
                blockedByUserId: blockingObs.userId, // NEU: UserID des Erstmelders
                blockedDate: blockingObs.date,
                distance: blockingObs.distance,
                daysDiff: blockingObs.daysDiff
              });
              return; // Überspringe diese Beobachtung
            }
            } // Ende else-Block für manuallyUnblocked
          }
          } // Ende else-Block für manuallyUnblocked bei direkter Prüfung
        }
        
        if (rarity === 'selten') {
          if (isSelffound) {
            points += 3; // Seltene Art + Selffound = 3 Punkte
            rareSelffoundCount++;
            selffoundBonus += 2; // 2 Punkte Bonus (3 - 1)
          } else {
            points += 1; // Nur seltene Art = 1 Punkt
          }
          rareCount++;
        } else if (rarity === 'sehr selten') {
          if (isSelffound) {
            points += 5; // Sehr seltene Art + Selffound = 5 Punkte
            veryRareSelffoundCount++;
            selffoundBonus += 3; // 3 Punkte Bonus (5 - 2)
          } else {
            points += 2; // Nur sehr seltene Art = 2 Punkte
          }
          veryRareCount++;
        }
      });
      
      // NEU: Zeige Info über blockierte Duplikate
      if (duplicateCount > 0) {
        console.log(`   ⚠️ ${userData.userName}: ${duplicateCount} Duplikate blockiert (bereits in 3km/3 Wochen gemeldet)`);
      }
      
      leaderboard.push({
        uid: uid,
        name: userData.userName || 'Unbekannt',
        points: points,
        rareCount: rareCount,
        veryRareCount: veryRareCount,
        selffoundBonus: selffoundBonus,
        rareSelffoundCount: rareSelffoundCount,
        veryRareSelffoundCount: veryRareSelffoundCount,
        totalFiltered: filteredObs.length,
        duplicateCount: duplicateCount, // NEU: Für Statistik
        blockedSpecies: blockedSpecies, // NEU: Liste der blockierten Arten
        // NEU: Speichere nur die Arten, die tatsächlich Punkte gebracht haben
        rareSpecies: filteredObs.filter(obs => {
          let rarity = obs.rarity || (obs.bird && birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : null);
          if ((rarity || '').toLowerCase() !== 'selten') return false;
          
          // DEBUG: Zeige ALLE Bergenten zur Analyse
          if (obs.bird && obs.bird.toLowerCase().includes('bergente')) {
            console.log(`🦆 BERGENTE in rareSpecies Filter:`, {
              id: obs.id,
              bird: obs.bird,
              date: obs.date,
              time: obs.time,
              lat: obs.lat,
              lng: obs.lng,
              manuallyBlocked: obs.manuallyBlocked,
              manuallyUnblocked: obs.manuallyUnblocked
            });
          }
          
          // NEU: WICHTIG! Manuell blockierte Beobachtungen NICHT in erfolgreiche Arten aufnehmen!
          if (obs.manuallyBlocked === true) {
            console.log(`   ⏭️ Überspringe manuell blockierte Beobachtung für rareSpecies: ${obs.bird} (ID: ${obs.id}, ${obs.date})`);
            return false;
          }
          
          // DEBUG: Log wenn es eine manuell entblockte Beobachtung ist
          if (obs.manuallyUnblocked === true) {
            console.log(`   🔍 Prüfe manuell entblockte Beobachtung für rareSpecies:`, {
              id: obs.id,
              bird: obs.bird,
              date: obs.date,
              manuallyUnblocked: obs.manuallyUnblocked
            });
          }
          
          // Prüfe ob diese Beobachtung gültig ist (kein Duplikat)
          const obsIndex = allRareObservations.findIndex(rareObs => 
            rareObs.id === obs.id || 
            (rareObs.bird === obs.bird && 
             rareObs.date === obs.date && 
             rareObs.userId === uid &&
             Math.abs(rareObs.lat - obs.lat) < 0.0001 &&
             Math.abs(rareObs.lng - obs.lng) < 0.0001)
          );
          
          if (obsIndex === -1) {
            console.log(`   ⚠️ Beobachtung nicht in allRareObservations gefunden:`, obs.bird, obs.date);
            return false;
          }
          
          const isValid = isValidForPoints(allRareObservations[obsIndex], obsIndex);
          
          // DEBUG: Zeige das Ergebnis für Bergenten
          if (obs.bird && obs.bird.toLowerCase().includes('bergente')) {
            console.log(`   🦆 BERGENTE isValid Ergebnis: ${isValid} für ID ${obs.id}`);
          }
          
          // DEBUG: Log das Ergebnis für manuell entblockte Beobachtungen
          if (obs.manuallyUnblocked === true) {
            console.log(`   🔍 isValidForPoints Ergebnis für entblockte Beobachtung:`, isValid);
          }
          
          return isValid;
        }),
        veryRareSpecies: filteredObs.filter(obs => {
          let rarity = obs.rarity || (obs.bird && birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : null);
          if ((rarity || '').toLowerCase() !== 'sehr selten') return false;
          
          // DEBUG: Zeige ALLE Bergenten zur Analyse
          if (obs.bird && obs.bird.toLowerCase().includes('bergente')) {
            console.log(`🦆 BERGENTE in veryRareSpecies Filter:`, {
              id: obs.id,
              bird: obs.bird,
              date: obs.date,
              time: obs.time,
              lat: obs.lat,
              lng: obs.lng,
              manuallyBlocked: obs.manuallyBlocked,
              manuallyUnblocked: obs.manuallyUnblocked
            });
          }
          
          // NEU: WICHTIG! Manuell blockierte Beobachtungen NICHT in erfolgreiche Arten aufnehmen!
          if (obs.manuallyBlocked === true) {
            console.log(`   ⏭️ Überspringe manuell blockierte Beobachtung für veryRareSpecies: ${obs.bird} (${obs.date})`);
            return false;
          }
          
          // DEBUG: Log wenn es eine manuell entblockte Beobachtung ist
          if (obs.manuallyUnblocked === true) {
            console.log(`   🔍 Prüfe manuell entblockte Beobachtung für veryRareSpecies:`, {
              id: obs.id,
              bird: obs.bird,
              date: obs.date,
              manuallyUnblocked: obs.manuallyUnblocked
            });
          }
          
          // Prüfe ob diese Beobachtung gültig ist (kein Duplikat)
          const obsIndex = allRareObservations.findIndex(rareObs => 
            rareObs.id === obs.id || 
            (rareObs.bird === obs.bird && 
             rareObs.date === obs.date && 
             rareObs.userId === uid &&
             Math.abs(rareObs.lat - obs.lat) < 0.0001 &&
             Math.abs(rareObs.lng - obs.lng) < 0.0001)
          );
          
          if (obsIndex === -1) {
            console.log(`   ⚠️ Beobachtung nicht in allRareObservations gefunden:`, obs.bird, obs.date);
            return false;
          }
          
          const isValid = isValidForPoints(allRareObservations[obsIndex], obsIndex);
          
          // DEBUG: Zeige das Ergebnis für Bergenten
          if (obs.bird && obs.bird.toLowerCase().includes('bergente')) {
            console.log(`   🦆 BERGENTE isValid Ergebnis: ${isValid} für ID ${obs.id}`);
          }
          
          // DEBUG: Log das Ergebnis für manuell entblockte Beobachtungen
          if (obs.manuallyUnblocked === true) {
            console.log(`   🔍 isValidForPoints Ergebnis für entblockte Beobachtung:`, isValid);
          }
          
          return isValid;
        })
      });
    }
    
    // Sortiere nach Punkten
    leaderboard.sort((a, b) => b.points - a.points);
    
    // Rendere Leaderboard
    const leaderboardContainer = document.getElementById('rarityLeaderboard2026');
    if (leaderboard.length === 0) {
      leaderboardContainer.innerHTML = `
        <div style="text-align:center;padding:40px 20px;color:var(--muted);">
          <div style="font-size:48px;margin-bottom:12px;">🌟</div>
          <p>Noch keine Beobachtungen für ${selectedYear === 'all' ? 'alle Jahre' : selectedYear}</p>
        </div>
      `;
    } else {
      let html = '<div style="display:flex;flex-direction:column;gap:12px;">';
      
      // NEU: Admin-Info-Banner wenn User Admin ist
      if (isAdmin) {
        html += `
          <div style="padding:12px;background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(6,182,212,0.1));border-radius:8px;border-left:4px solid #7c3aed;">
            <div style="display:flex;align-items:center;gap:10px;">
              <span style="font-size:24px;">🔐</span>
              <div>
                <div style="font-weight:600;font-size:14px;color:#a855f7;margin-bottom:2px;">Admin-Modus aktiv</div>
                <div style="font-size:11px;color:var(--muted);">
                  Du kannst Beobachtungen aller Gruppenmitglieder blocken/entblocken. 
                  Admin-Buttons sind mit 🔐 markiert.
                </div>
              </div>
            </div>
          </div>
        `;
      }
      
      leaderboard.forEach((entry, index) => {
        const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
        const isTop3 = index < 3;
        const isFirst = index === 0;
        
        html += `
          <div class="card" style="background:${isFirst ? 'linear-gradient(135deg, rgba(234,179,8,0.25), rgba(217,119,6,0.15))' : isTop3 ? 'linear-gradient(135deg, rgba(234,179,8,0.15), rgba(217,119,6,0.05))' : 'rgba(255,255,255,0.02)'};border-left:${isFirst ? '6px' : isTop3 ? '4px' : '3px'} solid ${isFirst ? '#f59e0b' : isTop3 ? '#eab308' : 'rgba(255,255,255,0.1)'};${isFirst ? 'box-shadow:0 8px 32px rgba(234,179,8,0.3);' : ''}">
            <div style="display:flex;justify-content:space-between;align-items:start;gap:12px;">
              <div style="display:flex;align-items:start;gap:12px;flex:1;">
                <div style="font-size:${isFirst ? '40px' : '32px'};width:${isFirst ? '50px' : '40px'};text-align:center;margin-top:4px;">${medal || (index + 1)}</div>
                <div style="flex:1;">
                  <div style="font-weight:${isFirst ? '700' : '600'};font-size:${isFirst ? '18px' : '16px'};margin-bottom:8px;${isFirst ? 'color:#f59e0b;' : ''}">${isFirst ? '👑 ' : ''}${entry.name}</div>
                  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:6px;font-size:11px;">
                    <div style="padding:4px 8px;background:rgba(234,179,8,0.15);border-radius:4px;border-left:2px solid #eab308;">
                      <div style="color:var(--muted);">Selten (1P)</div>
                      <div style="font-weight:600;color:#eab308;">${entry.rareCount - entry.rareSelffoundCount} Arten</div>
                    </div>
                    <div style="padding:4px 8px;background:rgba(234,179,8,0.2);border-radius:4px;border-left:2px solid #10b981;">
                      <div style="color:var(--muted);">Selten SF (3P)</div>
                      <div style="font-weight:600;color:#10b981;">${entry.rareSelffoundCount} Arten</div>
                    </div>
                    <div style="padding:4px 8px;background:rgba(245,158,11,0.15);border-radius:4px;border-left:2px solid #f59e0b;">
                      <div style="color:var(--muted);">Sehr selten (2P)</div>
                      <div style="font-weight:600;color:#f59e0b;">${entry.veryRareCount - entry.veryRareSelffoundCount} Arten</div>
                    </div>
                    <div style="padding:4px 8px;background:rgba(245,158,11,0.2);border-radius:4px;border-left:2px solid #22c55e;">
                      <div style="color:var(--muted);">Sehr selten SF (5P)</div>
                      <div style="font-weight:600;color:#22c55e;">${entry.veryRareSelffoundCount} Arten</div>
                    </div>
                  </div>
                  
                  <!-- NEU: Info über blockierte Duplikate -->
                  ${entry.duplicateCount > 0 ? `
                    <div style="margin-top:8px;padding:6px 8px;background:rgba(239,68,68,0.1);border-radius:4px;border-left:2px solid #ef4444;font-size:11px;">
                      <div style="display:flex;justify-content:space-between;align-items:center;">
                        <div>
                          <div style="color:var(--muted);">🚫 Duplikate blockiert</div>
                          <div style="font-weight:600;color:#ef4444;">${entry.duplicateCount} Arten (bereits in 3km/3 Wochen gemeldet)</div>
                        </div>
                        <button onclick="toggleRarityDetails('blocked_${entry.uid}')" 
                                style="padding:4px 8px;background:rgba(239,68,68,0.2);border:1px solid #ef4444;border-radius:4px;color:#ef4444;font-size:10px;cursor:pointer;white-space:nowrap;"
                                onmouseover="this.style.background='rgba(239,68,68,0.3)'"
                                onmouseout="this.style.background='rgba(239,68,68,0.2)'">
                          Details
                        </button>
                      </div>
                      
                      <!-- Blockierte Arten Details -->
                      <div id="blocked_${entry.uid}" style="display:none;margin-top:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:4px;">
                        <div style="font-weight:600;margin-bottom:6px;color:#ef4444;">Blockierte Arten:</div>
                        ${entry.blockedSpecies.map(blocked => `
                          <div id="blocked_item_${blocked.id}" style="margin-bottom:6px;padding:6px;background:rgba(239,68,68,0.05);border-radius:4px;border-left:2px solid #ef4444;">
                            <div style="display:flex;justify-content:space-between;align-items:start;gap:8px;">
                              <div style="flex:1;">
                                <div style="font-weight:600;color:${blocked.rarity === 'sehr selten' ? '#f59e0b' : '#eab308'};">
                                  ${blocked.rarity === 'sehr selten' ? '💎' : '⭐'} ${blocked.bird}${blocked.selffound ? ' 🌟' : ''}
                                </div>
                                <div style="font-size:10px;color:var(--muted);margin-top:2px;">
                                  📅 Deine Meldung: ${blocked.date}${blocked.time ? ` • 🕐 ${blocked.time} Uhr` : ''}${blocked.count ? ` • 📊 Anzahl: ${blocked.count}` : ''}
                                </div>
                                ${blocked.lat && blocked.lng ? `
                                  <div style="font-size:10px;color:var(--muted);margin-top:2px;">
                                    📍 ${blocked.lat.toFixed(4)}, ${blocked.lng.toFixed(4)}
                                    <button onclick="showObservationOnMapByCoords(${blocked.lat}, ${blocked.lng}, \`${blocked.bird.replace(/`/g, '\\`').replace(/'/g, "\\'")}\`)" 
                                            style="margin-left:4px;padding:2px 4px;background:rgba(6,182,212,0.2);border:1px solid #06b6d4;border-radius:3px;color:#06b6d4;font-size:9px;cursor:pointer;"
                                            title="Auf Karte anzeigen">
                                      🗺️ Karte
                                    </button>
                                  </div>
                                ` : ''}
                                
                                ${blocked.manuallyBlocked ? `
                                  <div style="font-size:10px;color:#a855f7;margin-top:4px;padding:4px;background:rgba(168,85,247,0.15);border-radius:3px;border:1px solid #a855f7;">
                                    🔒 <strong>Manuell geblockt</strong><br>
                                    Diese Art wurde von dir manuell aus der Wertung genommen
                                  </div>
                                ` : `
                                  <div style="font-size:10px;color:#ef4444;margin-top:4px;padding:4px;background:rgba(239,68,68,0.1);border-radius:3px;">
                                    ⚠️ Bereits von dir selbst am ${blocked.blockedDate} gemeldet<br>
                                    📍 Distanz: ${blocked.distance.toFixed(2)} km | ⏱️ ${blocked.daysDiff} Tag${blocked.daysDiff !== 1 ? 'e' : ''} später
                                  </div>
                                `}
                                
                                <!-- NEU: Kontroll-Buttons -->
                                <div style="display:flex;gap:4px;margin-top:6px;">
                                  <button onclick="toggleSelffoundInChallenge('${blocked.id}', ${!blocked.selffound})" 
                                          style="padding:3px 6px;background:${blocked.selffound ? 'rgba(16,185,129,0.3)' : 'rgba(255,255,255,0.1)'};border:1px solid ${blocked.selffound ? '#10b981' : 'rgba(255,255,255,0.2)'};border-radius:3px;color:${blocked.selffound ? '#10b981' : 'var(--soft)'};font-size:9px;cursor:pointer;white-space:nowrap;"
                                          title="${blocked.selffound ? 'Selffound entfernen' : 'Als Selffound markieren'}">
                                    ${blocked.selffound ? '✓ SF' : '+ SF'}
                                  </button>
                                  <button onclick="manualUnblockSpecies('${blocked.id}', '${blocked.blockedByUserId}', '${entry.uid}')" 
                                          style="padding:3px 6px;background:rgba(16,185,129,0.2);border:1px solid #10b981;border-radius:3px;color:#10b981;font-size:9px;cursor:pointer;white-space:nowrap;"
                                          title="${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Admin: Blockierung aufheben' : 'Blockierung manuell aufheben (Punkte werden vergeben)'}">
                                    ${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Entblocken' : '✓ Entblocken'}
                                  </button>
                                </div>
                              </div>
                            </div>
                          </div>
                        `).join('')}
                        <div style="margin-top:8px;padding:6px;background:rgba(255,255,255,0.03);border-radius:4px;font-size:10px;color:var(--muted);">
                          💡 <strong>Tipp:</strong> Diese Arten wurden blockiert, weil ${entry.uid === (window.FBA?.currentUser?.uid || '') ? 'du sie' : 'dieser Benutzer sie'} bereits in den letzten 3 Wochen im Umkreis von 3km gemeldet ${entry.uid === (window.FBA?.currentUser?.uid || '') ? 'hast' : 'hat'}. ${isAdmin ? '🔐 Als Admin kannst du die Blockierung für alle Nutzer aufheben.' : 'Mit "Entblocken" kannst du die Blockierung manuell aufheben, falls es sich um ein anderes Individuum oder einen anderen Ort handelt.'}
                        </div>
                      </div>
                    </div>
                  ` : ''}
                  
                  <!-- NEU: Details-Button -->
                  ${entry.rareCount > 0 || entry.veryRareCount > 0 ? `
                    <button onclick="toggleRarityDetails('details_${entry.uid}')" 
                            style="margin-top:8px;padding:4px 8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--soft);font-size:11px;cursor:pointer;transition:all 0.2s;"
                            onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                      🔍 Erfolgreiche Arten anzeigen
                    </button>
                    
                    <!-- NEU: Versteckte Details -->
                    <div id="details_${entry.uid}" style="display:none;margin-top:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:6px;font-size:12px;">
                      ${entry.rareSpecies.length > 0 ? `
                        <div style="margin-bottom:12px;">
                          <div style="font-weight:600;color:#eab308;margin-bottom:6px;">⭐ Seltene Arten (${entry.rareSpecies.length}):</div>
                          <div style="display:flex;flex-direction:column;gap:6px;">
                            ${entry.rareSpecies.map(obs => `
                              <div style="padding:6px;background:${obs.selffound ? 'rgba(16,185,129,0.15)' : 'rgba(234,179,8,0.1)'};border-radius:4px;border:1px solid ${obs.selffound ? '#10b981' : '#eab308'};">
                                <div style="display:flex;justify-content:space-between;align-items:start;gap:8px;">
                                  <div style="flex:1;">
                                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                                      <span style="font-weight:600;">${obs.bird}</span>
                                      ${obs.selffound ? ' 🌟' : ''}
                                      <span style="opacity:0.6;font-size:10px;">(${obs.date})</span>
                                    </div>
                                    <div style="display:flex;gap:8px;font-size:10px;color:var(--muted);margin-bottom:4px;">
                                      ${obs.count ? `<span>📊 Anzahl: <strong style="color:var(--text);">${obs.count}</strong></span>` : ''}
                                      ${obs.time ? `<span>🕐 ${obs.time} Uhr</span>` : ''}
                                    </div>
                                    ${obs.lat && obs.lng ? `
                                      <div style="font-size:10px;color:var(--muted);">
                                        📍 ${obs.lat.toFixed(4)}, ${obs.lng.toFixed(4)}
                                        <button onclick="showObservationOnMapByCoords(${obs.lat}, ${obs.lng}, \`${obs.bird.replace(/`/g, '\\`').replace(/'/g, "\\'")}\`)" 
                                                style="margin-left:4px;padding:2px 4px;background:rgba(6,182,212,0.2);border:1px solid #06b6d4;border-radius:3px;color:#06b6d4;font-size:9px;cursor:pointer;"
                                                title="Auf Karte anzeigen">
                                          🗺️ Karte
                                        </button>
                                      </div>
                                    ` : ''}
                                  </div>
                                  <div style="display:flex;gap:4px;">
                                    <button onclick="toggleSelffoundInChallenge('${obs.id}', ${!obs.selffound})" 
                                            style="padding:3px 6px;background:${obs.selffound ? 'rgba(16,185,129,0.3)' : 'rgba(255,255,255,0.1)'};border:1px solid ${obs.selffound ? '#10b981' : 'rgba(255,255,255,0.2)'};border-radius:3px;color:${obs.selffound ? '#10b981' : 'var(--soft)'};font-size:9px;cursor:pointer;white-space:nowrap;"
                                            title="${obs.selffound ? 'Selffound entfernen' : 'Als Selffound markieren'}">
                                      ${obs.selffound ? '✓ SF' : '+ SF'}
                                    </button>
                                    <button onclick="manualBlockSpecies('${obs.id}', '${entry.uid}')" 
                                            style="padding:3px 6px;background:rgba(239,68,68,0.2);border:1px solid #ef4444;border-radius:3px;color:#ef4444;font-size:9px;cursor:pointer;white-space:nowrap;"
                                            title="${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Admin: Diese Art blockieren' : 'Diese Art blockieren (keine Punkte mehr vergeben)'}">
                                      ${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Blocken' : '🚫 Blocken'}
                                    </button>
                                  </div>
                                </div>
                              </div>
                            `).join('')}
                          </div>
                        </div>
                      ` : ''}
                      
                      ${entry.veryRareSpecies.length > 0 ? `
                        <div>
                          <div style="font-weight:600;color:#f59e0b;margin-bottom:6px;">💎 Sehr seltene Arten (${entry.veryRareSpecies.length}):</div>
                          <div style="display:flex;flex-direction:column;gap:6px;">
                            ${entry.veryRareSpecies.map(obs => `
                              <div style="padding:6px;background:${obs.selffound ? 'rgba(34,197,94,0.15)' : 'rgba(245,158,11,0.1)'};border-radius:4px;border:1px solid ${obs.selffound ? '#22c55e' : '#f59e0b'};">
                                <div style="display:flex;justify-content:space-between;align-items:start;gap:8px;">
                                  <div style="flex:1;">
                                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
                                      <span style="font-weight:600;">${obs.bird}</span>
                                      ${obs.selffound ? ' 🌟' : ''}
                                      <span style="opacity:0.6;font-size:10px;">(${obs.date})</span>
                                    </div>
                                    <div style="display:flex;gap:8px;font-size:10px;color:var(--muted);margin-bottom:4px;">
                                      ${obs.count ? `<span>📊 Anzahl: <strong style="color:var(--text);">${obs.count}</strong></span>` : ''}
                                      ${obs.time ? `<span>🕐 ${obs.time} Uhr</span>` : ''}
                                    </div>
                                    ${obs.lat && obs.lng ? `
                                      <div style="font-size:10px;color:var(--muted);">
                                        📍 ${obs.lat.toFixed(4)}, ${obs.lng.toFixed(4)}
                                        <button onclick="showObservationOnMapByCoords(${obs.lat}, ${obs.lng}, \`${obs.bird.replace(/`/g, '\\`').replace(/'/g, "\\'")}\`)" 
                                                style="margin-left:4px;padding:2px 4px;background:rgba(6,182,212,0.2);border:1px solid #06b6d4;border-radius:3px;color:#06b6d4;font-size:9px;cursor:pointer;"
                                                title="Auf Karte anzeigen">
                                          🗺️ Karte
                                        </button>
                                      </div>
                                    ` : ''}
                                  </div>
                                  <div style="display:flex;gap:4px;">
                                    <button onclick="toggleSelffoundInChallenge('${obs.id}', ${!obs.selffound})" 
                                            style="padding:3px 6px;background:${obs.selffound ? 'rgba(34,197,94,0.3)' : 'rgba(255,255,255,0.1)'};border:1px solid ${obs.selffound ? '#22c55e' : 'rgba(255,255,255,0.2)'};border-radius:3px;color:${obs.selffound ? '#22c55e' : 'var(--soft)'};font-size:9px;cursor:pointer;white-space:nowrap;"
                                            title="${obs.selffound ? 'Selffound entfernen' : 'Als Selffound markieren'}">
                                      ${obs.selffound ? '✓ SF' : '+ SF'}
                                    </button>
                                    <button onclick="manualBlockSpecies('${obs.id}', '${entry.uid}')" 
                                            style="padding:3px 6px;background:rgba(239,68,68,0.2);border:1px solid #ef4444;border-radius:3px;color:#ef4444;font-size:9px;cursor:pointer;white-space:nowrap;"
                                            title="${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Admin: Diese Art blockieren' : 'Diese Art blockieren (keine Punkte mehr vergeben)'}">
                                      ${isAdmin && entry.uid !== (window.FBA?.currentUser?.uid || '') ? '🔐 Blocken' : '🚫 Blocken'}
                                    </button>
                                  </div>
                                </div>
                              </div>
                            `).join('')}
                          </div>
                        </div>
                      ` : ''}
                    </div>
                  ` : ''}
                </div>
              </div>
              <div style="text-align:right;${isFirst ? 'padding:8px 12px;background:linear-gradient(135deg, rgba(245,158,11,0.3), rgba(234,179,8,0.2));border-radius:12px;border:2px solid #f59e0b;' : ''}">
                <div style="font-size:${isFirst ? '42px' : '28px'};font-weight:700;color:${isFirst ? '#f59e0b' : '#eab308'};line-height:1;">${entry.points}</div>
                <div style="font-size:${isFirst ? '13px' : '11px'};color:var(--muted);margin-top:${isFirst ? '6px' : '2px'};font-weight:${isFirst ? '600' : 'normal'};">${isFirst ? '🏆 ' : ''}Punkte</div>
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      leaderboardContainer.innerHTML = html;
    }
    
    // Rendere detaillierte Statistiken
    const statsContainer = document.getElementById('rarityDetailedStats2026');
    if (leaderboard.length === 0) {
      statsContainer.innerHTML = '<p style="color:var(--muted);text-align:center;padding:20px;">Keine Daten verfügbar</p>';
    } else {
      let statsHtml = '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-bottom:16px;">';
      
      // Statistik-Karten
      const totalPoints = leaderboard.reduce((sum, e) => sum + e.points, 0);
      const totalRare = leaderboard.reduce((sum, e) => sum + e.rareCount, 0);
      const totalVeryRare = leaderboard.reduce((sum, e) => sum + e.veryRareCount, 0);
      const totalSelffoundBonus = leaderboard.reduce((sum, e) => sum + e.selffoundBonus, 0);
      const totalRareSelffound = leaderboard.reduce((sum, e) => sum + e.rareSelffoundCount, 0);
      const totalVeryRareSelffound = leaderboard.reduce((sum, e) => sum + e.veryRareSelffoundCount, 0);
      
      statsHtml += `
        <div class="card" style="background:rgba(234,179,8,0.1);">
          <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Gesamt Punkte</div>
          <div style="font-size:28px;font-weight:700;color:#eab308;">${totalPoints}</div>
        </div>
        <div class="card" style="background:rgba(234,179,8,0.08);">
          <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Selten (1P) / SF (3P)</div>
          <div style="font-size:28px;font-weight:700;">${totalRare}</div>
          <div style="font-size:11px;color:var(--muted);margin-top:2px;">${totalRare - totalRareSelffound} normal + ${totalRareSelffound} SF</div>
        </div>
        <div class="card" style="background:rgba(245,158,11,0.1);">
          <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Sehr selten (2P) / SF (5P)</div>
          <div style="font-size:28px;font-weight:700;color:#f59e0b;">${totalVeryRare}</div>
          <div style="font-size:11px;color:var(--muted);margin-top:2px;">${totalVeryRare - totalVeryRareSelffound} normal + ${totalVeryRareSelffound} SF</div>
        </div>
        <div class="card" style="background:rgba(16,185,129,0.1);">
          <div style="font-size:13px;color:var(--muted);margin-bottom:4px;">Selffound Gesamt</div>
          <div style="font-size:28px;font-weight:700;color:#10b981;">${totalRareSelffound + totalVeryRareSelffound}</div>
          <div style="font-size:11px;color:var(--muted);margin-top:2px;">Extra: +${totalSelffoundBonus} Punkte</div>
        </div>
      `;
      
      statsHtml += '</div>';
      
      // Detaillierte Tabelle
      statsHtml += `
        <div style="overflow-x:auto;">
          <table style="width:100%;border-collapse:collapse;font-size:13px;">
            <thead>
              <tr style="background:rgba(255,255,255,0.03);border-bottom:2px solid rgba(255,255,255,0.1);">
                <th style="padding:12px;text-align:left;">Rang</th>
                <th style="padding:12px;text-align:left;">Name</th>
                <th style="padding:12px;text-align:right;">Punkte</th>
                <th style="padding:12px;text-align:right;">Selten (1P)</th>
                <th style="padding:12px;text-align:right;">Sehr selten (2P)</th>
                <th style="padding:12px;text-align:right;">Selten SF (3P)</th>
                <th style="padding:12px;text-align:right;">Sehr selten SF (5P)</th>
                <th style="padding:12px;text-align:right;">Gesamt ${selectedYear === 'all' ? '' : selectedYear}</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      leaderboard.forEach((entry, index) => {
        statsHtml += `
          <tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
            <td style="padding:12px;">${index + 1}</td>
            <td style="padding:12px;font-weight:600;">${entry.name}</td>
            <td style="padding:12px;text-align:right;font-weight:700;color:#eab308;">${entry.points}</td>
            <td style="padding:12px;text-align:right;">${entry.rareCount - entry.rareSelffoundCount}</td>
            <td style="padding:12px;text-align:right;color:#f59e0b;">${entry.veryRareCount - entry.veryRareSelffoundCount}</td>
            <td style="padding:12px;text-align:right;color:#10b981;font-weight:600;">${entry.rareSelffoundCount}</td>
            <td style="padding:12px;text-align:right;color:#22c55e;font-weight:600;">${entry.veryRareSelffoundCount}</td>
            <td style="padding:12px;text-align:right;color:var(--muted);">${entry.totalFiltered}</td>
          </tr>
        `;
      });
      
      statsHtml += `
            </tbody>
          </table>
        </div>
      `;
      
      statsContainer.innerHTML = statsHtml;
    }
    
    console.log(`✅ Rarität-Challenge geladen (Jahr: ${selectedYear})`);
  } catch (error) {
    console.error('❌ Fehler beim Laden der Rarität-Challenge:', error);
    
    // Zeige Fehlermeldung im UI
    const leaderboardContainer = document.getElementById('rarityLeaderboard2026');
    if (leaderboardContainer) {
      leaderboardContainer.innerHTML = `
        <div style="text-align:center;padding:40px 20px;color:var(--danger);">
          <div style="font-size:48px;margin-bottom:12px;">❌</div>
          <p>Fehler beim Laden der Challenge</p>
          <p style="font-size:12px;margin-top:8px;color:var(--muted);">${error.message || 'Unbekannter Fehler'}</p>
        </div>
      `;
    }
    
    const statsContainer = document.getElementById('rarityDetailedStats2026');
    if (statsContainer) {
      statsContainer.innerHTML = '';
    }
  }
}

// Jahr-Wechsel-Handler
function changeRarityChallengeYear() {
  const yearSelect = document.getElementById('rarityChallengeYearSelect');
  const selectedYear = yearSelect.value;
  
  console.log('📅 Jahr gewechselt zu:', selectedYear);
  
  // Update Titel
  const titleYear = selectedYear === 'all' ? 'Alle Jahre' : selectedYear;
  const titleElements = document.querySelectorAll('#rarityChallengeYearTitle, #rarityLeaderboardYearTitle');
  titleElements.forEach(el => {
    el.textContent = titleYear;
  });
  
  // Lade Challenge neu
  renderRarityChallenge2026();
}

// Hauptfunktion zum Rendern des Gruppenvergleichs
async function renderGroupComparison() {
  console.log('🔍 Lade Gruppenvergleich...');
  
  if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
    console.log('⚠️ Kein Gruppenmodus aktiv');
    return;
  }
  
  try {
    // Lade alle Gruppendaten
    const groupData = await loadGroupData();
    
    // Rendere Beobachtungs-Leaderboard
    await renderObservationLeaderboard(groupData);
    
    // NEU: Rendere Arten-Leaderboard
    await renderSpeciesLeaderboard(groupData);
    
    // Rendere detaillierten Vergleich
    await renderDetailedObservationComparison(groupData);
    
    // Rendere Erfolgs-Leaderboard
    await renderAchievementLeaderboard(groupData);
    
    // Rendere Statistik-Vergleich
    await renderStatsComparison(groupData);
    
    console.log('✅ Gruppenvergleich geladen');
  } catch (error) {
    console.error('❌ Fehler beim Laden des Gruppenvergleichs:', error);
    showNotification('Fehler beim Laden der Gruppendaten', 3000);
  }
}

// Rendere Beobachtungs-Leaderboard
async function renderObservationLeaderboard(groupData) {
  const container = document.getElementById('observationLeaderboard');
  const users = Object.values(groupData.userStats);
  
  // Sortiere nach Anzahl der Beobachtungen
  users.sort((a, b) => b.totalCount - a.totalCount);
  
  if (users.length === 0) {
    container.innerHTML = `
      <div style="text-align:center;padding:20px;color:var(--muted);">
        <p>Noch keine Beobachtungen in dieser Gruppe</p>
      </div>
    `;
    return;
  }
  
  let html = '<div style="display:flex;flex-direction:column;gap:12px;margin-top:12px;">';
  
  users.forEach((user, index) => {
    const rank = index + 1;
    const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `#${rank}`;
    const isCurrentUser = user.userId === (window.FBA?.currentUser?.uid || '');
    
    html += `
      <div class="card" style="
        padding:16px;
        background:${isCurrentUser ? 'linear-gradient(135deg, rgba(6,182,212,0.15), rgba(124,58,237,0.08))' : 'rgba(255,255,255,0.02)'};
        border-left:4px solid ${rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : 'var(--accent)'};
      ">
        <div style="display:flex;align-items:center;gap:16px;">
          <div style="font-size:32px;min-width:50px;text-align:center;">${medal}</div>
          <div style="flex:1;">
            <div style="font-weight:600;font-size:16px;">
              ${user.userName}${isCurrentUser ? ' <span style="color:var(--accent);font-size:12px;">(Du)</span>' : ''}
            </div>
            <div style="display:flex;gap:16px;margin-top:8px;font-size:13px;color:var(--muted);">
              <div>📊 ${user.totalCount} Beobachtungen</div>
              <div>🐦 ${user.speciesCount} Arten</div>
              <div>📸 ${user.photosCount} Fotos</div>
            </div>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

// NEU: Rendere Arten-Leaderboard
async function renderSpeciesLeaderboard(groupData) {
  const container = document.getElementById('speciesLeaderboard');
  const users = Object.values(groupData.userStats);
  
  // Sortiere nach Anzahl der Arten
  users.sort((a, b) => b.speciesCount - a.speciesCount);
  
  if (users.length === 0) {
    container.innerHTML = `
      <div style="text-align:center;padding:20px;color:var(--muted);">
        <p>Noch keine Arten in dieser Gruppe</p>
      </div>
    `;
    return;
  }
  
  let html = '<div style="display:flex;flex-direction:column;gap:12px;margin-top:12px;">';
  
  users.forEach((user, index) => {
    const rank = index + 1;
    const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `#${rank}`;
    const isCurrentUser = user.userId === (window.FBA?.currentUser?.uid || '');
    
    html += `
      <div class="card" style="
        padding:16px;
        background:${isCurrentUser ? 'linear-gradient(135deg, rgba(168,85,247,0.15), rgba(236,72,153,0.08))' : 'rgba(255,255,255,0.02)'};
        border-left:4px solid ${rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#a855f7'};
      ">
        <div style="display:flex;align-items:center;gap:16px;">
          <div style="font-size:32px;min-width:50px;text-align:center;">${medal}</div>
          <div style="flex:1;">
            <div style="font-weight:600;font-size:16px;">
              ${user.userName}${isCurrentUser ? ' <span style="color:#a855f7;font-size:12px;">(Du)</span>' : ''}
            </div>
            <div style="display:flex;gap:16px;margin-top:8px;font-size:13px;color:var(--muted);">
              <div>🐦 ${user.speciesCount} Arten</div>
              <div>📊 ${user.totalCount} Beobachtungen</div>
              <div>📸 ${user.photosCount} Fotos</div>
            </div>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

// Rendere detaillierten Beobachtungsvergleich
async function renderDetailedObservationComparison(groupData) {
  const container = document.getElementById('detailedObservationComparison');
  const users = Object.values(groupData.userStats);
  
  if (users.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);">Keine Daten verfügbar</p>';
    return;
  }
  
  // Berechne Durchschnitt
  const avgObservations = users.reduce((sum, u) => sum + u.totalCount, 0) / users.length;
  const avgSpecies = users.reduce((sum, u) => sum + u.speciesCount, 0) / users.length;
  
  let html = `
    <div style="margin-bottom:16px;padding:12px;background:rgba(6,182,212,0.05);border-radius:8px;">
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(min(100%, 120px),1fr));gap:12px;text-align:center;">
        <div>
          <div style="font-size:24px;font-weight:700;color:var(--accent);">${users.length}</div>
          <div style="font-size:12px;color:var(--muted);">Mitglieder</div>
        </div>
        <div>
          <div style="font-size:24px;font-weight:700;color:var(--accent);">${Math.round(avgObservations)}</div>
          <div style="font-size:12px;color:var(--muted);">Ø Beobachtungen</div>
        </div>
        <div>
          <div style="font-size:24px;font-weight:700;color:var(--accent);">${Math.round(avgSpecies)}</div>
          <div style="font-size:12px;color:var(--muted);">Ø Arten</div>
        </div>
      </div>
    </div>
    
    <div style="display:flex;flex-direction:column;gap:8px;">
  `;
  
  users.forEach(user => {
    const obsPercentage = avgObservations > 0 ? (user.totalCount / avgObservations) * 100 : 0;
    const speciesPercentage = avgSpecies > 0 ? (user.speciesCount / avgSpecies) * 100 : 0;
    
    html += `
      <div style="padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;">
        <div style="font-weight:600;margin-bottom:8px;">${user.userName}</div>
        <div style="display:grid;gap:8px;">
          <div>
            <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
              <span>Beobachtungen</span>
              <span style="color:${obsPercentage >= 100 ? 'var(--success)' : 'var(--muted)'};">${user.totalCount}</span>
            </div>
            <div style="background:rgba(255,255,255,0.1);height:6px;border-radius:3px;overflow:hidden;">
              <div style="background:var(--accent);height:100%;width:${Math.min(obsPercentage, 200)}%;transition:width 0.5s ease;"></div>
            </div>
          </div>
          <div>
            <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
              <span>Arten</span>
              <span style="color:${speciesPercentage >= 100 ? 'var(--success)' : 'var(--muted)'};">${user.speciesCount}</span>
            </div>
            <div style="background:rgba(255,255,255,0.1);height:6px;border-radius:3px;overflow:hidden;">
              <div style="background:var(--accent-2);height:100%;width:${Math.min(speciesPercentage, 200)}%;transition:width 0.5s ease;"></div>
            </div>
          </div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
  
  // NEU: Rendere auch das Mitglieder-Vergleichs-Grid
  renderMemberComparisonGrid(groupData);
}

// NEU: Rendere Mitglieder-Vergleichs-Grid
async function renderMemberComparisonGrid(groupData) {
  const container = document.getElementById('memberComparisonGrid');
  const users = Object.values(groupData.userStats);
  
  if (users.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);text-align:center;grid-column:1/-1;padding:20px;">Keine Mitglieder gefunden</p>';
    return;
  }
  
  let html = '';
  
  users.forEach(user => {
    const isCurrentUser = user.userId === (window.FBA?.currentUser?.uid || '');
    
    // Finde häufigste Art
    const speciesCounts = {};
    user.observations.forEach(obs => {
      speciesCounts[obs.bird] = (speciesCounts[obs.bird] || 0) + 1;
    });
    const mostCommonSpecies = Object.entries(speciesCounts)
      .sort((a, b) => b[1] - a[1])[0];
    
    html += `
      <div class="member-card" style="${isCurrentUser ? 'border:2px solid var(--accent);' : ''}">
        <div class="member-header">
          <div class="member-avatar">${user.userName.charAt(0).toUpperCase()}</div>
          <div style="flex:1;">
            <div style="font-weight:600;font-size:15px;">
              ${user.userName}${isCurrentUser ? ' <span style="color:var(--accent);font-size:11px;">(Du)</span>' : ''}
            </div>
            <div style="font-size:12px;color:var(--muted);">${user.totalCount} Beobachtungen</div>
          </div>
        </div>
        <div class="comparison-stats">
          <div class="stat-row">
            <span class="stat-label">🐦 Arten</span>
            <span class="stat-value" style="color:var(--accent);">${user.speciesCount}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">📸 Fotos</span>
            <span class="stat-value" style="color:var(--success);">${user.photosCount}</span>
          </div>
          ${mostCommonSpecies ? `
            <div class="stat-row">
              <span class="stat-label">⭐ Top-Art</span>
              <span class="stat-value" style="font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${mostCommonSpecies[0]} (${mostCommonSpecies[1]}x)</span>
            </div>
          ` : ''}
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

// NEU: Öffne detaillierte Mitglieder-Vergleichsansicht
async function openDetailedMemberComparison() {
  if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
    showNotification('⚠️ Kein Gruppenmodus aktiv', 3000);
    return;
  }
  
  try {
    const groupData = await loadGroupData();
    const users = Object.values(groupData.userStats);
    
    if (users.length === 0) {
      showNotification('Keine Mitglieder in dieser Gruppe', 3000);
      return;
    }
    
    // Erstelle Modal
    const modal = document.createElement('div');
    modal.className = 'comparison-modal';
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    
    let html = `
      <div class="comparison-container">
        <div class="comparison-header">
          <div>
            <h2 style="margin:0;font-size:24px;">📊 Detaillierter Mitglieder-Vergleich</h2>
            <p style="margin:4px 0 0 0;color:var(--muted);font-size:14px;">
              ${groupData.groupInfo.name} • ${users.length} Mitglied${users.length !== 1 ? 'er' : ''}
            </p>
          </div>
          <button class="small-btn" onclick="this.closest('.comparison-modal').remove()" style="background:var(--danger);">
            ✕ Schließen
          </button>
        </div>
        
        <div class="comparison-grid">
    `;
    
    users.forEach(user => {
      const isCurrentUser = user.userId === (window.FBA?.currentUser?.uid || '');
      
      // Berechne zusätzliche Statistiken
      const datesSet = new Set(user.observations.map(obs => obs.date));
      const uniqueDays = datesSet.size;
      
      // Finde häufigste Arten (Top 3)
      const speciesCounts = {};
      user.observations.forEach(obs => {
        speciesCounts[obs.bird] = (speciesCounts[obs.bird] || 0) + 1;
      });
      const topSpecies = Object.entries(speciesCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);
      
      html += `
        <div class="member-card" style="${isCurrentUser ? 'border:2px solid var(--accent);box-shadow:0 4px 16px rgba(6,182,212,0.2);' : ''}">
          <div class="member-header">
            <div class="member-avatar" style="width:56px;height:56px;font-size:24px;">
              ${user.userName.charAt(0).toUpperCase()}
            </div>
            <div style="flex:1;min-width:0;">
              <div style="font-weight:700;font-size:17px;">
                ${user.userName}${isCurrentUser ? ' <span style="color:var(--accent);font-size:12px;">(Du)</span>' : ''}
              </div>
              <div style="font-size:13px;color:var(--muted);margin-top:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
                ${user.userEmail}
              </div>
            </div>
          </div>
          
          <div class="comparison-stats">
            <div class="stat-row">
              <span class="stat-label">📊 Gesamt-Beobachtungen</span>
              <span class="stat-value" style="font-size:18px;color:var(--accent);">${user.totalCount}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">🐦 Einzigartige Arten</span>
              <span class="stat-value" style="font-size:18px;color:var(--success);">${user.speciesCount}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">📸 Fotos</span>
              <span class="stat-value" style="font-size:18px;color:var(--accent-2);">${user.photosCount}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">📅 Aktive Tage</span>
              <span class="stat-value">${uniqueDays}</span>
            </div>
            ${user.totalCount > 0 ? `
              <div class="stat-row">
                <span class="stat-label">📈 Ø pro Tag</span>
                <span class="stat-value">${(user.totalCount / uniqueDays).toFixed(1)}</span>
              </div>
            ` : ''}
          </div>
          
          ${topSpecies.length > 0 ? `
            <div style="margin-top:12px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;">
              <div style="font-size:13px;font-weight:600;margin-bottom:8px;color:var(--muted);">⭐ Top-Arten:</div>
              <div style="display:flex;flex-direction:column;gap:6px;">
                ${topSpecies.map((species, idx) => {
                  const rarity = getRarityStyle(species[0]);
                  return `
                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:12px;gap:8px;">
                      <span class="${rarity.rarityClass}" style="flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${rarity.rarityIcon}${idx + 1}. ${species[0]}</span>
                      <span style="font-weight:600;color:var(--accent);flex-shrink:0;">${species[1]}x</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
  } catch (error) {
    console.error('Fehler beim Laden der Vergleichsdaten:', error);
    showNotification('❌ Fehler beim Laden der Daten', 3000);
  }
}

// Rendere Erfolgs-Leaderboard
async function renderAchievementLeaderboard(groupData) {
  const container = document.getElementById('achievementLeaderboard');
  
  // Für jetzt zeigen wir eine Platzhalter-Nachricht
  // In einer vollständigen Implementierung würden wir die Achievements aus Firebase laden
  container.innerHTML = `
    <div style="text-align:center;padding:20px;color:var(--muted);">
      <div style="font-size:32px;margin-bottom:8px;">🏅</div>
      <p style="margin:0;">Erfolgs-Vergleich</p>
      <p style="font-size:12px;margin-top:4px;">Erfolge werden lokal gespeichert und können derzeit nicht gruppenweit verglichen werden.</p>
    </div>
  `;
}

// Rendere detaillierten Erfolgsvergleich
async function renderDetailedAchievementComparison(groupData) {
  const container = document.getElementById('detailedAchievementComparison');
  
  container.innerHTML = `
    <div style="padding:20px;text-align:center;color:var(--muted);">
      <p>Diese Funktion wird in einer zukünftigen Version verfügbar sein.</p>
      <p style="font-size:12px;margin-top:8px;">Tipp: Erfolge sind aktuell nur lokal in deinem Browser gespeichert.</p>
    </div>
  `;
}

// Rendere Statistik-Vergleich
async function renderStatsComparison(groupData) {
  const users = Object.values(groupData.userStats);
  
  // Top Species Finders
  const topSpecies = [...users].sort((a, b) => b.speciesCount - a.speciesCount).slice(0, 3);
  const speciesHTML = topSpecies.map((user, i) => `
    <div style="display:flex;align-items:center;gap:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;margin-bottom:4px;">
      <div style="font-size:20px;">${i === 0 ? '🥇' : i === 1 ? '🥈' : '🥉'}</div>
      <div style="flex:1;">
        <div style="font-size:13px;font-weight:600;">${user.userName}</div>
        <div style="font-size:11px;color:var(--muted);">${user.speciesCount} Arten</div>
      </div>
    </div>
  `).join('');
  document.getElementById('topSpeciesFinders').innerHTML = speciesHTML || '<p style="color:var(--muted);font-size:12px;">Keine Daten</p>';
  
  // Top Photo Takers
  const topPhotos = [...users].sort((a, b) => b.photosCount - a.photosCount).slice(0, 3);
  const photosHTML = topPhotos.map((user, i) => `
    <div style="display:flex;align-items:center;gap:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;margin-bottom:4px;">
      <div style="font-size:20px;">${i === 0 ? '🥇' : i === 1 ? '🥈' : '🥉'}</div>
      <div style="flex:1;">
        <div style="font-size:13px;font-weight:600;">${user.userName}</div>
        <div style="font-size:11px;color:var(--muted);">${user.photosCount} Fotos</div>
      </div>
    </div>
  `).join('');
  document.getElementById('topPhotoTakers').innerHTML = photosHTML || '<p style="color:var(--muted);font-size:12px;">Keine Daten</p>';
  
  // Top Streaks (Platzhalter)
  document.getElementById('topStreaks').innerHTML = `
    <div style="padding:12px;text-align:center;color:var(--muted);font-size:12px;">
      <p>Streak-Berechnung wird in einer zukünftigen Version hinzugefügt</p>
    </div>
  `;
  
  // Gruppen-Übersicht
  const totalObs = users.reduce((sum, u) => sum + u.totalCount, 0);
  const totalSpecies = new Set();
  users.forEach(u => u.species.forEach(s => totalSpecies.add(s)));
  const totalPhotos = users.reduce((sum, u) => sum + u.photosCount, 0);
  
  document.getElementById('groupStatsOverview').innerHTML = `
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;text-align:center;">
      <div style="padding:16px;background:rgba(6,182,212,0.05);border-radius:8px;">
        <div style="font-size:32px;font-weight:700;color:var(--accent);">${totalObs}</div>
        <div style="font-size:12px;color:var(--muted);margin-top:4px;">Gesamt-Beobachtungen</div>
      </div>
      <div style="padding:16px;background:rgba(124,58,237,0.05);border-radius:8px;">
        <div style="font-size:32px;font-weight:700;color:var(--accent-2);">${totalSpecies.size}</div>
        <div style="font-size:12px;color:var(--muted);margin-top:4px;">Einzigartige Arten</div>
      </div>
      <div style="padding:16px;background:rgba(16,185,129,0.05);border-radius:8px;">
        <div style="font-size:32px;font-weight:700;color:var(--success);">${totalPhotos}</div>
        <div style="font-size:12px;color:var(--muted);margin-top:4px;">Gesamt-Fotos</div>
      </div>
      <div style="padding:16px;background:rgba(239,68,68,0.05);border-radius:8px;">
        <div style="font-size:32px;font-weight:700;color:var(--danger);">${users.length}</div>
        <div style="font-size:12px;color:var(--muted);margin-top:4px;">Aktive Mitglieder</div>
      </div>
    </div>
  `;
}

// Zeige/Verstecke Gruppenvergleichs-Menüpunkt basierend auf Gruppenmodus
function toggleGroupCompareVisibility() {
  const navButton = document.getElementById('groupCompareNav');
  if (navButton) {
    if (window.currentSelectedGroup && window.currentSelectedGroup !== 'personal') {
      navButton.style.display = 'flex';
    } else {
      navButton.style.display = 'none';
    }
  }
}

// Mache Funktionen global verfügbar
window.switchCompareTab = switchCompareTab;
window.renderGroupComparison = renderGroupComparison;
window.renderRarityChallenge2026 = renderRarityChallenge2026;
window.renderRarityChallenge = renderRarityChallenge2026; // Alias für Import-Code
window.changeRarityChallengeYear = changeRarityChallengeYear;
window.toggleGroupCompareVisibility = toggleGroupCompareVisibility;

// ============================================================
// BEOBACHTUNGEN IN GRUPPE KOPIEREN
// ============================================================

let selectedObservationIds = new Set();
let availableGroups = [];

// Lade verfügbare Gruppen für das Tool
async function loadAvailableGroupsForCopy() {
  if (!window.FBA || !window.FBA.currentUser) {
    return;
  }
  
  const select = document.getElementById('targetGroupSelect');
  if (!select) return;
  
  select.innerHTML = '<option value="">Gruppe auswählen...</option>';
  availableGroups = [];
  
  try {
    const snapshot = await window.FBD.ref('groups').once('value');
    const groups = snapshot.val();
    
    if (groups) {
      Object.keys(groups).forEach(groupId => {
        const group = groups[groupId];
        const userId = window.FBA.currentUser.uid;
        
        // Prüfe ob User Mitglied ist
        if (group.members && group.members[userId]) {
          availableGroups.push({
            id: groupId,
            name: group.name || 'Unbenannte Gruppe'
          });
          
          const option = document.createElement('option');
          option.value = groupId;
          option.textContent = group.name || 'Unbenannte Gruppe';
          select.appendChild(option);
        }
      });
    }
    
    // Status aktualisieren
    const status = document.getElementById('copyToGroupStatus');
    if (status) {
      if (availableGroups.length === 0) {
        status.textContent = 'Du bist in keiner Gruppe';
        status.style.color = 'var(--muted)';
      } else {
        status.textContent = `${availableGroups.length} Gruppe(n) verfügbar`;
        status.style.color = 'var(--success)';
      }
    }
  } catch (error) {
    console.error('Fehler beim Laden der Gruppen:', error);
  }
}

// Öffne Modal zum Auswählen der Beobachtungen
async function openCopyToGroupModal() {
  const select = document.getElementById('targetGroupSelect');
  const targetGroupId = select ? select.value : '';
  
  if (!targetGroupId) {
    showNotification('Bitte wähle zuerst eine Zielgruppe aus', 3000);
    return;
  }
  
  // Zeige Modal
  const modal = document.getElementById('copyToGroupModal');
  if (!modal) return;
  modal.style.display = 'flex';
  
  // Zeige Gruppennamen
  const targetGroup = availableGroups.find(g => g.id === targetGroupId);
  const groupNameEl = document.getElementById('copyModalTargetGroup');
  if (groupNameEl && targetGroup) {
    groupNameEl.textContent = targetGroup.name;
  }
  
  // Lade und zeige Beobachtungen
  await loadObservationsForSelection();
}

// Schließe Modal
function closeCopyToGroupModal() {
  const modal = document.getElementById('copyToGroupModal');
  if (modal) modal.style.display = 'none';
  selectedObservationIds.clear();
  updateSelectedCount();
}

// Lade Beobachtungen zur Auswahl
async function loadObservationsForSelection() {
  const container = document.getElementById('observationSelectionList');
  if (!container) return;
  
  try {
    const observations = await getAllFromIndexedDB('observations');
    
    if (observations.length === 0) {
      container.innerHTML = `
        <div style="text-align:center;padding:40px;color:var(--muted);">
          <div style="font-size:32px;margin-bottom:8px;">📋</div>
          <p>Keine privaten Beobachtungen vorhanden</p>
        </div>
      `;
      return;
    }
    
    // Sortiere nach Datum (neueste zuerst)
    observations.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    // NEU: Gruppiere nach Personen (wenn mehrere Personen vorhanden)
    const groupedByPerson = new Map();
    observations.forEach(obs => {
      const userId = obs.userId || obs.createdBy || 'personal';
      const userName = obs.userName || obs.userEmail || 'Meine Beobachtungen';
      
      if (!groupedByPerson.has(userId)) {
        groupedByPerson.set(userId, {
          userName: userName,
          observations: []
        });
      }
      groupedByPerson.get(userId).observations.push(obs);
    });
    
    // Wenn nur eine Person, zeige flache Liste
    if (groupedByPerson.size === 1) {
      let html = '';
      observations.forEach(obs => {
        const dateStr = obs.date ? new Date(obs.date).toLocaleDateString('de-DE') : 'Kein Datum';
        const isSelected = selectedObservationIds.has(obs.id);
        
        html += `
          <div class="observation-checkbox-item" data-obs-id="${obs.id}" style="
            display:flex;
            align-items:center;
            gap:12px;
            padding:12px;
            margin-bottom:8px;
            background:${isSelected ? 'rgba(6,182,212,0.1)' : 'rgba(255,255,255,0.02)'};
            border-radius:8px;
            border:1px solid ${isSelected ? 'var(--accent)' : 'rgba(255,255,255,0.06)'};
            cursor:pointer;
            transition:all 0.2s ease;
          " onclick="toggleObservationSelection('${obs.id}')">
            <input type="checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleObservationSelection('${obs.id}')" style="width:18px;height:18px;accent-color:var(--accent);cursor:pointer;">
            <div style="flex:1;">
              <div class="${obs.bird ? getRarityStyle(obs.bird).rarityClass : ''}" style="font-weight:600;margin-bottom:4px;">${getRarityStyle(obs.bird || '').rarityIcon}${obs.bird || 'Unbekannte Art'}</div>
              <div style="display:flex;gap:16px;font-size:12px;color:var(--muted);">
                <span>📅 ${dateStr}</span>
                ${obs.time ? `<span>⏰ ${obs.time}</span>` : ''}
                ${obs.lat && obs.lng ? `<span>📍 ${parseFloat(obs.lat).toFixed(4)}, ${parseFloat(obs.lng).toFixed(4)}</span>` : ''}
                ${obs.count ? `<span>🔢 ${obs.count}x</span>` : ''}
              </div>
            </div>
            ${obs.photo ? '<span style="font-size:20px;">📸</span>' : ''}
          </div>
        `;
      });
      container.innerHTML = html;
    } else {
      // NEU: Mehrere Personen - zeige mit Akkordeons
      let html = '<div style="display:flex;flex-direction:column;gap:12px;">';
      
      const sortedPersons = Array.from(groupedByPerson.entries()).sort((a, b) => 
        b[1].observations.length - a[1].observations.length
      );
      
      sortedPersons.forEach(([userId, personData]) => {
        const personObs = personData.observations;
        const personName = personData.userName;
        const personInitial = personName.charAt(0).toUpperCase();
        const accordionId = `selection-accordion-${userId}`;
        
        html += `
          <div class="person-accordion">
            <div class="person-accordion-header" onclick="togglePersonAccordion('${accordionId}')">
              <div class="person-info">
                <div class="person-avatar" style="width:32px;height:32px;font-size:14px;">${personInitial}</div>
                <div class="person-details">
                  <div class="person-name" style="font-size:14px;">${personName}</div>
                  <div class="person-stats">
                    <span>${personObs.length} Beobachtungen</span>
                  </div>
                </div>
              </div>
              <div class="person-toggle">
                <span>Anzeigen</span>
                <span class="person-toggle-icon">▼</span>
              </div>
            </div>
            
            <div class="person-accordion-content" id="${accordionId}">
              <div style="padding:12px;display:flex;flex-direction:column;gap:8px;">
        `;
        
        personObs.forEach(obs => {
          const dateStr = obs.date ? new Date(obs.date).toLocaleDateString('de-DE') : 'Kein Datum';
          const isSelected = selectedObservationIds.has(obs.id);
          
          html += `
            <div class="observation-checkbox-item" data-obs-id="${obs.id}" style="
              display:flex;
              align-items:center;
              gap:12px;
              padding:12px;
              background:${isSelected ? 'rgba(6,182,212,0.1)' : 'rgba(255,255,255,0.02)'};
              border-radius:8px;
              border:1px solid ${isSelected ? 'var(--accent)' : 'rgba(255,255,255,0.06)'};
              cursor:pointer;
              transition:all 0.2s ease;
            " onclick="toggleObservationSelection('${obs.id}')">
              <input type="checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleObservationSelection('${obs.id}')" style="width:18px;height:18px;accent-color:var(--accent);cursor:pointer;">
              <div style="flex:1;">
                <div class="${obs.bird ? getRarityStyle(obs.bird).rarityClass : ''}" style="font-weight:600;margin-bottom:4px;">${getRarityStyle(obs.bird || '').rarityIcon}${obs.bird || 'Unbekannte Art'}</div>
                <div style="display:flex;gap:16px;font-size:12px;color:var(--muted);">
                  <span>📅 ${dateStr}</span>
                  ${obs.time ? `<span>⏰ ${obs.time}</span>` : ''}
                  ${obs.lat && obs.lng ? `<span>📍 ${parseFloat(obs.lat).toFixed(4)}, ${parseFloat(obs.lng).toFixed(4)}</span>` : ''}
                  ${obs.count ? `<span>🔢 ${obs.count}x</span>` : ''}
                </div>
              </div>
              ${obs.photo ? '<span style="font-size:20px;">📸</span>' : ''}
            </div>
          `;
        });
        
        html += `
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    updateSelectedCount();
  } catch (error) {
    console.error('Fehler beim Laden der Beobachtungen:', error);
    container.innerHTML = `
      <div style="text-align:center;padding:40px;color:var(--danger);">
        <p>Fehler beim Laden der Beobachtungen</p>
      </div>
    `;
  }
}

// Toggle Auswahl einer Beobachtung
function toggleObservationSelection(obsId) {
  if (selectedObservationIds.has(obsId)) {
    selectedObservationIds.delete(obsId);
  } else {
    selectedObservationIds.add(obsId);
  }
  
  // UI aktualisieren
  const item = document.querySelector(`[data-obs-id="${obsId}"]`);
  if (item) {
    const checkbox = item.querySelector('input[type="checkbox"]');
    const isSelected = selectedObservationIds.has(obsId);
    
    if (checkbox) checkbox.checked = isSelected;
    item.style.background = isSelected ? 'rgba(6,182,212,0.1)' : 'rgba(255,255,255,0.02)';
    item.style.borderColor = isSelected ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  }
  
  updateSelectedCount();
}

// Alle auswählen
function selectAllObservations() {
  document.querySelectorAll('.observation-checkbox-item').forEach(item => {
    const obsId = item.getAttribute('data-obs-id');
    if (obsId) {
      selectedObservationIds.add(obsId);
      const checkbox = item.querySelector('input[type="checkbox"]');
      if (checkbox) checkbox.checked = true;
      item.style.background = 'rgba(6,182,212,0.1)';
      item.style.borderColor = 'var(--accent)';
    }
  });
  updateSelectedCount();
}

// Alle abwählen
function deselectAllObservations() {
  selectedObservationIds.clear();
  document.querySelectorAll('.observation-checkbox-item').forEach(item => {
    const checkbox = item.querySelector('input[type="checkbox"]');
    if (checkbox) checkbox.checked = false;
    item.style.background = 'rgba(255,255,255,0.02)';
    item.style.borderColor = 'rgba(255,255,255,0.06)';
  });
  updateSelectedCount();
}

// Aktualisiere Zähler
function updateSelectedCount() {
  const countEl = document.getElementById('selectedObsCount');
  if (countEl) {
    countEl.textContent = selectedObservationIds.size;
  }
  
  const btnText = document.getElementById('copyBtnText');
  if (btnText) {
    btnText.textContent = selectedObservationIds.size > 0 
      ? `📤 ${selectedObservationIds.size} Beobachtung(en) kopieren` 
      : '📤 In Gruppe kopieren';
  }
}

// Kopiere ausgewählte Beobachtungen in Gruppe
async function copySelectedObservationsToGroup() {
  if (selectedObservationIds.size === 0) {
    showNotification('Bitte wähle mindestens eine Beobachtung aus', 3000);
    return;
  }
  
  const select = document.getElementById('targetGroupSelect');
  const targetGroupId = select ? select.value : '';
  
  if (!targetGroupId) {
    showNotification('Keine Zielgruppe ausgewählt', 3000);
    return;
  }
  
  if (!window.FBA || !window.FBA.currentUser) {
    showNotification('Du musst angemeldet sein', 3000);
    return;
  }
  
  const btnText = document.getElementById('copyBtnText');
  const originalText = btnText ? btnText.textContent : '';
  if (btnText) btnText.textContent = '⏳ Kopiere...';
  
  try {
    const observations = await getAllFromIndexedDB('observations');
    const selectedObs = observations.filter(obs => selectedObservationIds.has(obs.id));
    
    const user = window.FBA.currentUser;
    const userName = user.displayName || user.email.split('@')[0];
    
    let successCount = 0;
    
    for (const obs of selectedObs) {
      const groupObservation = {
        bird: obs.bird,
        date: obs.date,
        lat: obs.lat || '',
        lng: obs.lng || '',
        time: obs.time || '',
        count: obs.count || '1',
        behavior: obs.behavior || '',
        weather: obs.weather || '',
        photo: obs.photo || '',
        userId: user.uid,
        userName: userName,
        userEmail: user.email,
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        copiedFrom: 'private',
        originalId: obs.id
      };
      
      try {
        await window.FBD.ref(`groups/${targetGroupId}/observations`).push(groupObservation);
        successCount++;
      } catch (error) {
        console.error('Fehler beim Kopieren einer Beobachtung:', error);
      }
    }
    
    if (successCount > 0) {
      showNotification(`✅ ${successCount} Beobachtung(en) erfolgreich in Gruppe kopiert!`, 4000);
      closeCopyToGroupModal();
      selectedObservationIds.clear();
    } else {
      showNotification('❌ Keine Beobachtungen konnten kopiert werden', 3000);
      if (btnText) btnText.textContent = originalText;
    }
  } catch (error) {
    console.error('Fehler beim Kopieren in Gruppe:', error);
    showNotification('❌ Fehler beim Kopieren: ' + error.message, 4000);
    if (btnText) btnText.textContent = originalText;
  }
}

// Initialisiere beim Laden des Tools
async function initializeCopyToGroupTool() {
  if (window.FBA && window.FBA.currentUser) {
    await loadAvailableGroupsForCopy();
  } else {
    // Verstecke Tool wenn nicht angemeldet
    const tool = document.getElementById('copyToGroupTool');
    if (tool) {
      tool.style.display = 'none';
    }
  }
}

// Event Listener für Tools-Seite
const originalUpdateSystemInfo = typeof updateSystemInfo !== 'undefined' ? updateSystemInfo : null;
if (typeof updateSystemInfo !== 'undefined') {
  updateSystemInfo = function() {
    if (typeof originalUpdateSystemInfo === 'function') {
      originalUpdateSystemInfo();
    }
    initializeCopyToGroupTool();
  };
}

// Mache Funktionen global verfügbar
window.openCopyToGroupModal = openCopyToGroupModal;
window.closeCopyToGroupModal = closeCopyToGroupModal;
window.toggleObservationSelection = toggleObservationSelection;
window.selectAllObservations = selectAllObservations;
window.deselectAllObservations = deselectAllObservations;
window.copySelectedObservationsToGroup = copySelectedObservationsToGroup;
window.loadAvailableGroupsForCopy = loadAvailableGroupsForCopy;
window.initializeCopyToGroupTool = initializeCopyToGroupTool;
window.openDetailedMemberComparison = openDetailedMemberComparison;
window.startChallenge = startChallenge;
window.renderChallenges = renderChallenges;
window.checkChallengeProgress = checkChallengeProgress;
window.openChallengeCreator = openChallengeCreator;
window.closeChallengeCreator = closeChallengeCreator;
window.selectIcon = selectIcon;
window.selectColor = selectColor;
window.selectTier = selectTier;
window.updateGoalValue = updateGoalValue;
window.updateXPValue = updateXPValue;
window.updateGoalHint = updateGoalHint;
window.createCustomChallenge = createCustomChallenge;
window.startChallenge = startChallenge;
window.cancelChallenge = cancelChallenge;
window.openCreateComparisonFolderModal = openCreateComparisonFolderModal;
window.closeCreateComparisonFolderModal = closeCreateComparisonFolderModal;
window.createComparisonFolder = createComparisonFolder;
window.renderComparisonFolders = renderComparisonFolders;
window.openAddListToFolderModal = openAddListToFolderModal;
window.closeAddListToFolderModal = closeAddListToFolderModal;
window.addListToComparisonFolder = addListToComparisonFolder;

// ==================== ARTEN-DATENBANK FUNKTIONEN ====================

// Globales Objekt für Gruppendaten
let groupSpeciesData = {
  memberNames: {}, // uid -> name
  speciesByMember: {}, // speciesName -> [uid1, uid2, ...]
  isGroupMode: false
};

// Lade Gruppen-Artendaten
async function loadGroupSpeciesData() {
  groupSpeciesData = {
    memberNames: {},
    speciesByMember: {},
    isGroupMode: false
  };
  
  const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
  
  if (!isGroupMode || !window.FBA || !window.FBD) {
    // Verstecke Gruppenfilter
    const groupFilters = document.getElementById('groupSpeciesFilters');
    if (groupFilters) groupFilters.style.display = 'none';
    return;
  }
  
  groupSpeciesData.isGroupMode = true;
  const groupId = window.currentSelectedGroup;
  
  try {
    // Zeige Gruppenfilter
    const groupFilters = document.getElementById('groupSpeciesFilters');
    if (groupFilters) groupFilters.style.display = 'flex';
    
    // Lade Gruppenmitglieder
    const membersSnapshot = await window.FBD.ref(`groups/${groupId}/members`).once('value');
    const members = membersSnapshot.val() || {};
    
    Object.keys(members).forEach(uid => {
      groupSpeciesData.memberNames[uid] = members[uid].name || members[uid].email || 'Unbekannt';
    });
    
    // Lade alle Beobachtungen der Gruppe
    const obsSnapshot = await window.FBD.ref(`groups/${groupId}/observations`).once('value');
    const observations = obsSnapshot.val() || {};
    
    // Analysiere welche Arten von wem gesehen wurden
    Object.values(observations).forEach(obs => {
      if (obs.bird && obs.userId && obs.tickable !== false) {
        if (!groupSpeciesData.speciesByMember[obs.bird]) {
          groupSpeciesData.speciesByMember[obs.bird] = new Set();
        }
        groupSpeciesData.speciesByMember[obs.bird].add(obs.userId);
      }
    });
    
    // Konvertiere Sets zu Arrays für einfachere Verarbeitung
    Object.keys(groupSpeciesData.speciesByMember).forEach(species => {
      groupSpeciesData.speciesByMember[species] = Array.from(groupSpeciesData.speciesByMember[species]);
    });
    
  } catch (error) {
    console.error('Fehler beim Laden der Gruppendaten:', error);
  }
}

// Arten-Datenbank laden und anzeigen
async function loadSpeciesDatabase() {
  const container = document.getElementById('speciesDatabase');
  if (!container) return;
  
  // Lade Gruppendaten falls im Gruppenmodus
  await loadGroupSpeciesData();
  
  const allObservations = await getAllFromIndexedDB('observations');
  
  // Erstelle zwei Maps: eine für alle Beobachtungen (Anzeige), eine für tickbare (Zählung)
  const speciesCounts = {};
  const tickableSpeciesCounts = {};
  
  allObservations.forEach(obs => {
    if (obs.bird) {
      // Alle Beobachtungen
      if (!speciesCounts[obs.bird]) {
        speciesCounts[obs.bird] = 0;
      }
      speciesCounts[obs.bird]++;
      
      // Nur tickbare für die Anzeige in der Karte
      if (obs.tickable !== false) {
        if (!tickableSpeciesCounts[obs.bird]) {
          tickableSpeciesCounts[obs.bird] = 0;
        }
        tickableSpeciesCounts[obs.bird]++;
      }
    }
  });
  
  // Alle Arten aus der Datenbank
  const allSpecies = Object.keys(birdDatabase).sort();
  
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill, minmax(min(100%, 280px), 1fr));gap:12px;">';
  
  allSpecies.forEach(speciesName => {
    const species = birdDatabase[speciesName];
    const totalCount = speciesCounts[speciesName] || 0;
    const tickableCount = tickableSpeciesCounts[speciesName] || 0;
    const rarity = getRarityStyle(speciesName);
    
    // Status-Badge
    let statusBadge = '';
    let statusColor = 'var(--muted)';
    if (species.status === 'sehr selten') {
      statusBadge = 'Sehr selten';
      statusColor = '#dc2626';
    } else if (species.status === 'selten') {
      statusBadge = 'Selten';
      statusColor = '#ef4444';
    } else if (species.status && species.status.toLowerCase() === 'escape') {
      statusBadge = 'Escape';
      statusColor = '#3b82f6';
    } else if (species.status === 'häufig') {
      statusBadge = 'Häufig';
      statusColor = 'var(--success)';
    }
    
    // Zeige tickable Count, mit Hinweis auf Gesamt wenn unterschiedlich
    const countDisplay = totalCount !== tickableCount 
      ? `${tickableCount} (${totalCount} gesamt)` 
      : `${totalCount}`;
    
    // NEU: Prüfe ob Art bereits gesehen wurde
    const hasBeenSeen = totalCount > 0;
    
    // Gruppenmitglieder-Info (falls im Gruppenmodus)
    let groupMembersHtml = '';
    if (groupSpeciesData.isGroupMode && groupSpeciesData.speciesByMember[speciesName]) {
      const members = groupSpeciesData.speciesByMember[speciesName];
      const currentUserId = window.FBA?.currentUser?.uid;
      const allMemberCount = Object.keys(groupSpeciesData.memberNames).length;
      const seenByAll = members.length === allMemberCount;
      
      groupMembersHtml = '<div class="group-members-seen">';
      
      if (seenByAll) {
        groupMembersHtml += '<span class="all-members-badge">🌟 Von allen gesehen</span>';
      } else {
        groupMembersHtml += '<div style="font-size:10px;color:var(--muted);width:100%;margin-bottom:4px;">Gesehen von:</div>';
        members.forEach(uid => {
          const isMe = uid === currentUserId;
          const name = groupSpeciesData.memberNames[uid] || 'Unbekannt';
          const displayName = isMe ? 'Ich' : name.split('@')[0].split(' ')[0];
          groupMembersHtml += `<span class="member-badge ${isMe ? 'me' : ''}">${isMe ? '✓' : '👤'} ${displayName}</span>`;
        });
      }
      
      groupMembersHtml += '</div>';
    }
    
    // Prominenter Seen/Unseen Badge
    const seenBadge = hasBeenSeen 
      ? '<div class="species-seen-badge"><span>✓</span><span>GESEHEN</span></div>'
      : '<div class="species-unseen-badge">Noch nicht gesehen</div>';
    
    // CSS-Klasse für gesehen/nicht gesehen
    const cardClass = hasBeenSeen ? 'species-card-seen' : 'species-card-unseen';
    
    html += `
      <div class="card species-card ${cardClass}" onclick="openSpeciesDetail('${speciesName}')" 
           style="cursor:pointer;transition:all 0.3s;position:relative;padding:16px;"
           onmouseover="this.style.transform='translateY(-6px)';this.style.boxShadow='0 12px 32px rgba(0,0,0,0.4)';"
           onmouseout="this.style.transform='';this.style.boxShadow='';">
        ${seenBadge}
        ${statusBadge ? `<span style="position:absolute;top:12px;left:12px;font-size:10px;padding:3px 8px;border-radius:12px;background:${statusColor};color:white;white-space:nowrap;z-index:10;">${statusBadge}</span>` : ''}
        <div style="margin-bottom:8px;padding-right:8px;padding-top:${statusBadge ? '30px' : '35px'};padding-left:${statusBadge ? '85px' : '0'};">
          <div>
            <div class="${rarity.rarityClass}" style="font-weight:600;font-size:15px;">${rarity.rarityIcon}${speciesName}</div>
            <div style="font-size:12px;color:var(--muted);font-style:italic;">${species.scientific || ''}</div>
          </div>
        </div>
        <div style="font-size:13px;color:var(--soft);margin-bottom:8px;">${species.family || ''}</div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.04);">
          <span style="font-size:12px;color:var(--muted);">${species.size || ''}</span>
          <span class="${hasBeenSeen ? 'species-count-seen' : 'species-count-unseen'}" style="font-size:13px;" title="${totalCount !== tickableCount ? tickableCount + ' tickbar, ' + (totalCount - tickableCount) + ' nicht tickbar' : ''}">${hasBeenSeen ? countDisplay + ' ×' : 'Keine Beobachtungen'}</span>
        </div>
        ${groupMembersHtml}
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

// Arten-Detail-Modal öffnen
async function openSpeciesDetail(speciesName) {
  const modal = document.getElementById('speciesDetailModal');
  const species = birdDatabase[speciesName];
  
  if (!species) {
    showNotification('Vogelart nicht in Datenbank gefunden', 3000);
    return;
  }
  
  // Lade alle Beobachtungen dieser Art
  const allObservations = await getAllFromIndexedDB('observations');
  // Alle Beobachtungen dieser Art (für Anzeige)
  const allSpeciesObservations = allObservations.filter(obs => obs.bird === speciesName);
  // Nur tickbare (für Statistik)
  const tickableObservations = allSpeciesObservations.filter(obs => obs.tickable !== false);
  const speciesObservations = allSpeciesObservations; // Zeige alle
  
  // Titel und Badge
  const rarity = getRarityStyle(speciesName);
  document.getElementById('speciesDetailName').innerHTML = `${rarity.rarityIcon}${speciesName}`;
  document.getElementById('speciesDetailName').className = rarity.rarityClass;
  
  const badge = document.getElementById('speciesDetailBadge');
  if (species.status === 'sehr selten') {
    badge.textContent = 'Sehr selten';
    badge.style.background = '#dc2626';
    badge.style.color = 'white';
    badge.style.display = 'inline-block';
  } else if (species.status === 'selten') {
    badge.textContent = 'Selten';
    badge.style.background = '#ef4444';
    badge.style.color = 'white';
    badge.style.display = 'inline-block';
  } else if (species.status && species.status.toLowerCase() === 'escape') {
    badge.textContent = 'Escape';
    badge.style.background = '#3b82f6';
    badge.style.color = 'white';
    badge.style.display = 'inline-block';
  } else if (species.status === 'häufig') {
    badge.textContent = 'Häufig';
    badge.style.background = 'var(--success)';
    badge.style.color = 'white';
    badge.style.display = 'inline-block';
  } else {
    // Kein Status - Badge verstecken
    badge.style.display = 'none';
  }
  
  // Arten-Info
  const infoContainer = document.querySelector('#speciesDetailInfo .species-details');
  let infoHtml = '';
  
  // Nur Felder anzeigen, die tatsächlich Werte haben
  if (species.scientific) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Wissenschaftlich:</div>
        <div style="font-style:italic;">${species.scientific}</div>
      </div>`;
  }
  
  if (species.family) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Familie:</div>
        <div>${species.family}</div>
      </div>`;
  }
  
  if (species.size) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Größe:</div>
        <div>${species.size}</div>
      </div>`;
  }
  
  if (species.migratory) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Zugverhalten:</div>
        <div>${species.migratory}</div>
      </div>`;
  }
  
  if (species.redList) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Rote Liste:</div>
        <div>${species.redList}</div>
      </div>`;
  }
  
  if (species.protection) {
    infoHtml += `
      <div class="species-detail">
        <div class="label">Schutz:</div>
        <div>${species.protection}</div>
      </div>`;
  }
  
  if (species.description) {
    infoHtml += `
      <div class="species-detail" style="grid-column:1/-1;">
        <div class="label">Beschreibung:</div>
        <div>${species.description}</div>
      </div>`;
  }
  
  // Zeige Nachricht, wenn keine Informationen vorhanden sind
  if (!infoHtml) {
    infoHtml = '<div class="muted" style="text-align:center;padding:20px;">Keine zusätzlichen Informationen vorhanden</div>';
  }
  
  infoContainer.innerHTML = infoHtml;
  
  // Statistiken - zeige alle Beobachtungen mit Hinweis auf tickbare
  const tickableCount = tickableObservations.length;
  const totalCount = speciesObservations.length;
  const countDisplay = tickableCount !== totalCount 
    ? `${tickableCount} (${totalCount} gesamt)`
    : `${totalCount}`;
  
  document.getElementById('speciesObsCount').textContent = countDisplay;
  document.getElementById('speciesObsCount').title = tickableCount !== totalCount 
    ? `${tickableCount} tickbare, ${totalCount - tickableCount} nicht tickbare`
    : '';
  
  const photosWithData = speciesObservations.filter(obs => obs.photo);
  document.getElementById('speciesPhotoCount').textContent = photosWithData.length;
  
  if (speciesObservations.length > 0) {
    const sortedObs = [...speciesObservations].sort((a, b) => new Date(a.date) - new Date(b.date));
    document.getElementById('speciesFirstSeen').textContent = formatDateForDisplay(sortedObs[0].date);
    document.getElementById('speciesLastSeen').textContent = formatDateForDisplay(sortedObs[sortedObs.length - 1].date);
  } else {
    document.getElementById('speciesFirstSeen').textContent = '-';
    document.getElementById('speciesLastSeen').textContent = '-';
  }
  
  // Foto-Galerie
  const photoContainer = document.getElementById('speciesPhotos');
  if (photosWithData.length > 0) {
    let photoHtml = '';
    photosWithData.forEach(obs => {
      photoHtml += `
        <div style="position:relative;cursor:pointer;border-radius:8px;overflow:hidden;aspect-ratio:1;background:var(--glass);"
             onclick="openPhotoLightbox('${obs.photo}', '${speciesName} - ${formatDateForDisplay(obs.date)}')">
          <img src="${obs.photo}" style="width:100%;height:100%;object-fit:cover;" alt="${speciesName}">
          <div style="position:absolute;bottom:0;left:0;right:0;background:linear-gradient(transparent, rgba(0,0,0,0.7));padding:8px;color:white;font-size:11px;">
            ${formatDateForDisplay(obs.date)}
          </div>
        </div>
      `;
    });
    photoContainer.innerHTML = photoHtml;
  } else {
    photoContainer.innerHTML = '<div class="muted">Keine Fotos vorhanden</div>';
  }
  
  // Beobachtungen
  const obsContainer = document.getElementById('speciesObservations');
  if (speciesObservations.length > 0) {
    let obsHtml = '';
    speciesObservations.sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(obs => {
      obsHtml += `
        <div class="card" style="padding:12px;cursor:pointer;transition:all 0.2s;" 
             onclick="showObservationDetail('${obs.id}')"
             onmouseover="this.style.background='rgba(255,255,255,0.04)';"
             onmouseout="this.style.background='';">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <div style="font-weight:600;">${formatDateForDisplay(obs.date)}</div>
              <div style="font-size:13px;color:var(--muted);margin-top:4px;">
                ${obs.time || '--:--'} Uhr • ${obs.count || '1'} Individuen
                ${obs.folderName ? `• ${obs.folderName}` : ''}
              </div>
              ${obs.behavior ? `<div style="font-size:12px;color:var(--soft);margin-top:4px;">💭 ${obs.behavior}</div>` : ''}
            </div>
            ${obs.photo ? '<span style="font-size:20px;">📸</span>' : ''}
          </div>
        </div>
      `;
    });
    obsContainer.innerHTML = obsHtml;
  } else {
    obsContainer.innerHTML = '<div class="muted">Noch keine Beobachtungen für diese Art</div>';
  }
  
  // Modal anzeigen
  modal.style.display = 'flex';
}

// Arten-Detail-Modal schließen
function closeSpeciesDetail() {
  document.getElementById('speciesDetailModal').style.display = 'none';
}

// Arten filtern
let currentFilter = 'all';
// NEU: Array für aktive Filter (Mehrfachauswahl möglich)
let activeSpeciesFilters = [];
let speciesSearchTerm = '';

// NEU: Funktionen für aktive Filter-Anzeige in Arten-Datenbank
function updateSpeciesActiveFiltersDisplay() {
  const container = document.getElementById('speciesActiveFiltersContainer');
  const badgesContainer = document.getElementById('speciesActiveFilterBadges');
  
  if (!container || !badgesContainer) return;
  
  badgesContainer.innerHTML = '';
  let hasFilters = false;
  
  // Suchfilter
  if (speciesSearchTerm) {
    hasFilters = true;
    addSpeciesFilterBadge('🔍 Suche', speciesSearchTerm, 'search');
  }
  
  // Filter-Namen Mapping
  const filterNames = {
    'seen': '✓ Gesehen (Ich)',
    'unseen': 'Noch nicht gesehen',
    'common': 'Häufig',
    'rare': 'Selten',
    'very-rare': 'Sehr selten',
    'selffound': '🔴 Selffound',
    'group-all': '🌍 Von allen gesehen',
    'group-any': '👤 Von Mitgliedern gesehen',
    'group-missing': '❌ Von niemand gesehen'
  };
  
  // Aktive Filter anzeigen
  activeSpeciesFilters.forEach(filter => {
    if (filter !== 'all' && filterNames[filter]) {
      hasFilters = true;
      addSpeciesFilterBadge('Filter', filterNames[filter], filter);
    }
  });
  
  // Container ein/ausblenden
  if (hasFilters) {
    container.classList.add('has-filters');
  } else {
    container.classList.remove('has-filters');
  }
}

function addSpeciesFilterBadge(label, value, filterType) {
  const badgesContainer = document.getElementById('speciesActiveFilterBadges');
  if (!badgesContainer) return;
  
  const badge = document.createElement('div');
  badge.className = 'filter-badge';
  badge.innerHTML = `
    <span>${label}: ${value}</span>
    <button class="filter-badge-remove" onclick="removeSpeciesFilter('${filterType}')" title="Filter entfernen">×</button>
  `;
  badgesContainer.appendChild(badge);
}

function removeSpeciesFilter(filterType) {
  if (filterType === 'search') {
    // Suchfeld leeren
    const searchInput = document.getElementById('speciesSearch');
    if (searchInput) {
      searchInput.value = '';
      speciesSearchTerm = '';
      
      // Alle Karten wieder anzeigen
      const cards = document.querySelectorAll('.species-card');
      cards.forEach(card => {
        card.style.display = '';
      });
    }
  } else {
    // Filter aus activeSpeciesFilters entfernen
    const filterIndex = activeSpeciesFilters.indexOf(filterType);
    if (filterIndex > -1) {
      activeSpeciesFilters.splice(filterIndex, 1);
      
      // Button-Status aktualisieren
      const buttons = document.querySelectorAll('#arten .small-btn');
      buttons.forEach(btn => {
        if (btn.onclick && btn.onclick.toString().includes(`'${filterType}'`)) {
          btn.classList.remove('active');
        }
      });
      
      // Wenn keine Filter mehr aktiv, "Alle" aktivieren
      if (activeSpeciesFilters.length === 0) {
        const allButton = Array.from(buttons).find(btn => 
          btn.textContent.trim() === 'Alle'
        );
        if (allButton) {
          allButton.classList.add('active');
        }
      }
    }
    
    // Neu filtern
    filterSpecies('refresh');
  }
  
  updateSpeciesActiveFiltersDisplay();
}

function clearAllSpeciesFilters() {
  // Suchfeld leeren
  const searchInput = document.getElementById('speciesSearch');
  if (searchInput) {
    searchInput.value = '';
    speciesSearchTerm = '';
  }
  
  // Alle Filter entfernen
  activeSpeciesFilters = [];
  
  // Alle Button-Styles zurücksetzen
  const buttons = document.querySelectorAll('#arten .small-btn');
  buttons.forEach(btn => {
    btn.classList.remove('active');
  });
  
  // "Alle" Button aktivieren
  const allButton = Array.from(buttons).find(btn => 
    btn.textContent.trim() === 'Alle'
  );
  if (allButton) {
    allButton.classList.add('active');
  }
  
  // Neu laden
  filterSpecies('all');
}


async function filterSpecies(filter) {
  // NEU: Wenn "refresh" übergeben wird, überspringe Toggle-Logik
  if (filter !== 'refresh') {
    // NEU: Gegenseitig ausschließende Filter
    if (filter === 'seen' && activeSpeciesFilters.includes('unseen')) {
      // Entferne "unseen" wenn "seen" gewählt wird
      const unseenIndex = activeSpeciesFilters.indexOf('unseen');
      activeSpeciesFilters.splice(unseenIndex, 1);
      
      // Entferne active-Klasse vom unseen-Button
      const buttons = document.querySelectorAll('#arten .small-btn');
      buttons.forEach(btn => {
        if (btn.textContent.includes('Noch nicht gesehen')) {
          btn.classList.remove('active');
        }
      });
    } else if (filter === 'unseen' && activeSpeciesFilters.includes('seen')) {
      // Entferne "seen" wenn "unseen" gewählt wird
      const seenIndex = activeSpeciesFilters.indexOf('seen');
      activeSpeciesFilters.splice(seenIndex, 1);
      
      // Entferne active-Klasse vom seen-Button
      const buttons = document.querySelectorAll('#arten .small-btn');
      buttons.forEach(btn => {
        if (btn.textContent.includes('Gesehen (Ich)')) {
          btn.classList.remove('active');
        }
      });
    }
    
    // Toggle-Logik: Filter hinzufügen oder entfernen
    const filterIndex = activeSpeciesFilters.indexOf(filter);
    
    if (filterIndex > -1) {
      // Filter ist schon aktiv → entfernen
      activeSpeciesFilters.splice(filterIndex, 1);
      event.target.classList.remove('active');
    } else {
      // Filter ist nicht aktiv → hinzufügen
      activeSpeciesFilters.push(filter);
      event.target.classList.add('active');
    }
    
    // Sonderfall: "Alle" deaktiviert alle anderen Filter
    if (filter === 'all') {
      activeSpeciesFilters = [];
      document.querySelectorAll('#arten .small-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
    } else {
      // Wenn ein anderer Filter aktiviert wird, "Alle" deaktivieren
      const allButton = Array.from(document.querySelectorAll('#arten .small-btn')).find(btn => 
        btn.textContent.trim() === 'Alle'
      );
      if (allButton) {
        allButton.classList.remove('active');
      }
    }
  }
  
  console.log('🔍 Aktive Filter:', activeSpeciesFilters);
  
  const container = document.getElementById('speciesDatabase');
  const observations = await getAllFromIndexedDB('observations');
  
  // Beobachtungszählungen - zwei Maps wie in loadSpeciesDatabase
  const speciesCounts = {};
  const tickableSpeciesCounts = {};
  
  observations.forEach(obs => {
    if (obs.bird) {
      // Alle Beobachtungen
      if (!speciesCounts[obs.bird]) {
        speciesCounts[obs.bird] = 0;
      }
      speciesCounts[obs.bird]++;
      
      // Nur tickbare
      if (obs.tickable !== false) {
        if (!tickableSpeciesCounts[obs.bird]) {
          tickableSpeciesCounts[obs.bird] = 0;
        }
        tickableSpeciesCounts[obs.bird]++;
      }
    }
  });
  
  // Arten filtern
  let filteredSpecies = Object.keys(birdDatabase);
  
  // Wenn keine Filter aktiv oder nur "all", zeige alle
  if (activeSpeciesFilters.length === 0 || activeSpeciesFilters.includes('all')) {
    // Zeige alle Arten
  } else {
    // NEU: Separate Filter nach Typ
    const statusFilters = activeSpeciesFilters.filter(f => ['common', 'rare', 'very-rare'].includes(f));
    const otherFilters = activeSpeciesFilters.filter(f => !['common', 'rare', 'very-rare'].includes(f));
    
    filteredSpecies = filteredSpecies.filter(name => {
      const species = birdDatabase[name];
      
      // 1. Prüfe Status-Filter (ODER-Verknüpfung)
      let statusMatch = statusFilters.length === 0; // Wenn keine Status-Filter, dann Match
      if (statusFilters.length > 0) {
        statusMatch = statusFilters.some(filter => {
          if (filter === 'common') {
            return species.status === 'häufig';
          } else if (filter === 'rare') {
            return species.status === 'selten';
          } else if (filter === 'very-rare') {
            return species.status === 'sehr selten';
          }
          return false;
        });
      }
      
      // 2. Prüfe andere Filter (UND-Verknüpfung)
      const otherMatch = otherFilters.every(filter => {
        if (filter === 'seen') {
          return (tickableSpeciesCounts[name] || 0) > 0;
        } else if (filter === 'unseen') {
          return (tickableSpeciesCounts[name] || 0) === 0;
        } else if (filter === 'selffound') {
          // Prüfe ob diese Art als Selffound markiert wurde
          const obs = observations.find(o => o.bird === name && o.selffound === true);
          return obs !== undefined;
        } else if (filter === 'group-all') {
          if (groupSpeciesData.isGroupMode) {
            const allMemberCount = Object.keys(groupSpeciesData.memberNames).length;
            const members = groupSpeciesData.speciesByMember[name];
            return members && members.length === allMemberCount;
          }
          return true;
        } else if (filter === 'group-any') {
          if (groupSpeciesData.isGroupMode) {
            return groupSpeciesData.speciesByMember[name] && groupSpeciesData.speciesByMember[name].length > 0;
          }
          return true;
        } else if (filter === 'group-missing') {
          if (groupSpeciesData.isGroupMode) {
            return !groupSpeciesData.speciesByMember[name] || groupSpeciesData.speciesByMember[name].length === 0;
          }
          return true;
        }
        return true;
      });
      
      // Beide Bedingungen müssen erfüllt sein
      return statusMatch && otherMatch;
    });
  }
  
  filteredSpecies.sort();
  
  // HTML generieren (gleicher Code wie in loadSpeciesDatabase)
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill, minmax(min(100%, 280px), 1fr));gap:12px;">';
  
  filteredSpecies.forEach(speciesName => {
    const species = birdDatabase[speciesName];
    const totalCount = speciesCounts[speciesName] || 0;
    const tickableCount = tickableSpeciesCounts[speciesName] || 0;
    const rarity = getRarityStyle(speciesName);
    
    let statusBadge = '';
    let statusColor = 'var(--muted)';
    if (species.status === 'sehr selten') {
      statusBadge = 'Sehr selten';
      statusColor = '#dc2626';
    } else if (species.status === 'selten') {
      statusBadge = 'Selten';
      statusColor = '#ef4444';
    } else if (species.status && species.status.toLowerCase() === 'escape') {
      statusBadge = 'Escape';
      statusColor = '#3b82f6';
    } else if (species.status === 'häufig') {
      statusBadge = 'Häufig';
      statusColor = 'var(--success)';
    }
    
    // Zeige tickable Count, mit Hinweis auf Gesamt wenn unterschiedlich
    const countDisplay = totalCount !== tickableCount 
      ? `${tickableCount} (${totalCount} gesamt)` 
      : `${totalCount}`;
    
    // NEU: Prüfe ob Art bereits gesehen wurde
    const hasBeenSeen = totalCount > 0;
    
    // Gruppenmitglieder-Info (falls im Gruppenmodus)
    let groupMembersHtml = '';
    if (groupSpeciesData.isGroupMode && groupSpeciesData.speciesByMember[speciesName]) {
      const members = groupSpeciesData.speciesByMember[speciesName];
      const currentUserId = window.FBA?.currentUser?.uid;
      const allMemberCount = Object.keys(groupSpeciesData.memberNames).length;
      const seenByAll = members.length === allMemberCount;
      
      groupMembersHtml = '<div class="group-members-seen">';
      
      if (seenByAll) {
        groupMembersHtml += '<span class="all-members-badge">🌟 Von allen gesehen</span>';
      } else {
        groupMembersHtml += '<div style="font-size:10px;color:var(--muted);width:100%;margin-bottom:4px;">Gesehen von:</div>';
        members.forEach(uid => {
          const isMe = uid === currentUserId;
          const name = groupSpeciesData.memberNames[uid] || 'Unbekannt';
          const displayName = isMe ? 'Ich' : name.split('@')[0].split(' ')[0];
          groupMembersHtml += `<span class="member-badge ${isMe ? 'me' : ''}">${isMe ? '✓' : '👤'} ${displayName}</span>`;
        });
      }
      
      groupMembersHtml += '</div>';
    }
    
    // Prominenter Seen/Unseen Badge
    const seenBadge = hasBeenSeen 
      ? '<div class="species-seen-badge"><span>✓</span><span>GESEHEN</span></div>'
      : '<div class="species-unseen-badge">Noch nicht gesehen</div>';
    
    // CSS-Klasse für gesehen/nicht gesehen
    const cardClass = hasBeenSeen ? 'species-card-seen' : 'species-card-unseen';
    
    html += `
      <div class="card species-card ${cardClass}" onclick="openSpeciesDetail('${speciesName}')" 
           style="cursor:pointer;transition:all 0.3s;position:relative;padding:16px;"
           onmouseover="this.style.transform='translateY(-6px)';this.style.boxShadow='0 12px 32px rgba(0,0,0,0.4)';"
           onmouseout="this.style.transform='';this.style.boxShadow='';">
        ${seenBadge}
        ${statusBadge ? `<span style="position:absolute;top:12px;left:12px;font-size:10px;padding:3px 8px;border-radius:12px;background:${statusColor};color:white;white-space:nowrap;z-index:10;">${statusBadge}</span>` : ''}
        <div style="margin-bottom:8px;padding-right:8px;padding-top:${statusBadge ? '30px' : '35px'};padding-left:${statusBadge ? '85px' : '0'};">
          <div>
            <div class="${rarity.rarityClass}" style="font-weight:600;font-size:15px;">${rarity.rarityIcon}${speciesName}</div>
            <div style="font-size:12px;color:var(--muted);font-style:italic;">${species.scientific || ''}</div>
          </div>
        </div>
        <div style="font-size:13px;color:var(--soft);margin-bottom:8px;">${species.family || ''}</div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.04);">
          <span style="font-size:12px;color:var(--muted);">${species.size || ''}</span>
          <span class="${hasBeenSeen ? 'species-count-seen' : 'species-count-unseen'}" style="font-size:13px;" title="${totalCount !== tickableCount ? tickableCount + ' tickbar, ' + (totalCount - tickableCount) + ' nicht tickbar' : ''}">${hasBeenSeen ? countDisplay + ' ×' : 'Keine Beobachtungen'}</span>
        </div>
        ${groupMembersHtml}
      </div>
    `;
  });
  
  html += '</div>';
  
  // NEU: Zeige Anzahl der aktiven Filter und gefundenen Arten
  const filterInfo = activeSpeciesFilters.length > 0 
    ? `<div style="margin-top:12px;padding:10px;background:rgba(124,58,237,0.1);border-radius:8px;border:1px solid rgba(124,58,237,0.3);font-size:13px;color:var(--soft);">
         🔍 <strong>${activeSpeciesFilters.length}</strong> Filter aktiv: ${activeSpeciesFilters.join(', ')} • 
         <strong>${filteredSpecies.length}</strong> ${filteredSpecies.length === 1 ? 'Art' : 'Arten'} gefunden
       </div>`
    : `<div style="margin-top:12px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:13px;color:var(--muted);">
         📊 <strong>${filteredSpecies.length}</strong> ${filteredSpecies.length === 1 ? 'Art' : 'Arten'} insgesamt
       </div>`;
  
  html += filterInfo;
  
  if (filteredSpecies.length === 0) {
    html = '<div class="muted" style="text-align:center;padding:40px;">Keine Arten gefunden für die ausgewählten Filter</div>';
    html += filterInfo;
  }
  
  container.innerHTML = html;
  
  // NEU: Aktive Filter anzeigen
  updateSpeciesActiveFiltersDisplay();
}

// Arten-Suche
document.addEventListener('DOMContentLoaded', function() {
  const searchInput = document.getElementById('speciesSearch');
  if (searchInput) {
    searchInput.addEventListener('input', function(e) {
      const searchTerm = e.target.value.toLowerCase();
      speciesSearchTerm = e.target.value; // NEU: Speichere den Suchbegriff
      const cards = document.querySelectorAll('.species-card');
      
      cards.forEach(card => {
        const text = card.textContent.toLowerCase();
        if (text.includes(searchTerm)) {
          card.style.display = '';
        } else {
          card.style.display = 'none';
        }
      });
      
      // NEU: Aktive Filter anzeigen
      updateSpeciesActiveFiltersDisplay();
    });
  }
});

// Globale Funktionen verfügbar machen
window.loadSpeciesDatabase = loadSpeciesDatabase;
window.loadGroupSpeciesData = loadGroupSpeciesData;
window.openSpeciesDetail = openSpeciesDetail;
window.closeSpeciesDetail = closeSpeciesDetail;
window.filterSpecies = filterSpecies;
window.updateSpeciesActiveFiltersDisplay = updateSpeciesActiveFiltersDisplay;
window.removeSpeciesFilter = removeSpeciesFilter;
window.clearAllSpeciesFilters = clearAllSpeciesFilters;

// ==================== TICKABLE & SELFFOUND TOGGLE FUNKTIONEN ====================

// Toggle Tickable Status
async function toggleTickable(observationId) {
  try {
    // Prüfe ob im Gruppenmodus
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // NEU: Prüfe ob Firebase verfügbar ist
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 2000);
        console.error('Firebase ist nicht initialisiert');
        return;
      }
      
      // NEU: Prüfe Berechtigung
      let user = null;
      try {
        user = window.FBA.currentUser;
      } catch (authError) {
        console.error('Auth-Fehler:', authError);
        showNotification('❌ Nicht angemeldet', 2000);
        return;
      }
      
      if (!user) {
        showNotification('❌ Nicht angemeldet', 2000);
        return;
      }
      
      // Firebase-Modus
      const groupId = window.currentSelectedGroup;
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      
      // Lade aktuelle Beobachtung
      const snapshot = await obsRef.once('value');
      const obs = snapshot.val();
      
      if (!obs) {
        showNotification('Beobachtung nicht gefunden', 3000);
        console.error('Beobachtung nicht in Firebase gefunden:', observationId);
        return;
      }
      
      // NEU: Prüfe ob Owner oder Admin
      const isOwner = obs.userId === user.uid || obs.createdBy === user.email;
      
      let isAdmin = false;
      try {
        const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${user.uid}`).once('value');
        isAdmin = memberSnapshot.exists() && memberSnapshot.val().role === 'admin';
      } catch (error) {
        console.warn('Konnte Admin-Status nicht prüfen:', error);
      }
      
      if (!isOwner && !isAdmin) {
        showNotification('❌ Keine Berechtigung (nur eigene Beobachtungen oder Admin)', 2000);
        return;
      }
      
      // Toggle: wenn undefined oder true, dann false, sonst true
      const newTickable = obs.tickable === false ? true : false;
      await obsRef.update({
        tickable: newTickable,
        updatedAt: new Date().toISOString()
      });
      
      // Visuelles Update
      updateToggleButtonVisuals(observationId, 'tickable', newTickable);
      
      showNotification(
        newTickable ? '✅ Als tickbar markiert' : '❌ Als nicht tickbar markiert',
        2000
      );
      
      // Aktualisiere Challenge falls auf der Seite
      if (document.getElementById('compareRarity2026View') && 
          document.getElementById('compareRarity2026View').style.display !== 'none') {
        setTimeout(() => renderRarityChallenge2026(), 500);
      }
      
    } else {
      // IndexedDB-Modus (persönliche Beobachtungen)
      const observations = await getAllFromIndexedDB('observations');
      const obs = observations.find(o => o.id === observationId);
      
      if (!obs) {
        showNotification('Beobachtung nicht gefunden', 3000);
        return;
      }
      
      // Toggle: wenn undefined oder true, dann false, sonst true
      obs.tickable = obs.tickable === false ? true : false;
      obs.updatedAt = new Date().toISOString();
      
      await saveToIndexedDB('observations', obs);
      
      // Nur visuelles Update ohne komplettes Neuladen
      updateToggleButtonVisuals(observationId, 'tickable', obs.tickable);
      
      // Statistiken im Hintergrund aktualisieren
      setTimeout(() => {
        if (typeof updateAdvancedStatistics === 'function') {
          updateAdvancedStatistics();
        }
        if (typeof updateChart === 'function') {
          updateChart();
        }
      }, 100);
      
      showNotification(
        obs.tickable ? '✅ Als tickbar markiert' : '❌ Als nicht tickbar markiert',
        2000
      );
    }
    
    // Listen-Ansicht aktualisieren (falls offen)
    if (currentListId && document.getElementById('listDetailView').style.display === 'block') {
      setTimeout(() => {
        openListDetail(currentListId);
      }, 100);
    }
    
    // Beobachtungen-Manager aktualisieren (falls offen)
    if (document.getElementById('beobachtungen') && document.getElementById('beobachtungen').style.display !== 'none') {
      setTimeout(() => {
        if (typeof renderObservationManager === 'function') {
          renderObservationManager();
        }
      }, 100);
    }
    
  } catch (error) {
    console.error('Fehler beim Toggle Tickable:', error);
    showNotification('❌ Fehler beim Aktualisieren: ' + error.message, 3000);
  }
}

// Toggle Selffound Status
async function toggleSelffound(observationId) {
  try {
    // Prüfe ob im Gruppenmodus
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // NEU: Prüfe ob Firebase verfügbar ist
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 2000);
        console.error('Firebase ist nicht initialisiert');
        return;
      }
      
      // NEU: Prüfe Berechtigung
      let user = null;
      try {
        user = window.FBA.currentUser;
      } catch (authError) {
        console.error('Auth-Fehler:', authError);
        showNotification('❌ Nicht angemeldet', 2000);
        return;
      }
      
      if (!user) {
        showNotification('❌ Nicht angemeldet', 2000);
        return;
      }
      
      // Firebase-Modus
      const groupId = window.currentSelectedGroup;
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      
      // Lade aktuelle Beobachtung
      const snapshot = await obsRef.once('value');
      const obs = snapshot.val();
      
      if (!obs) {
        showNotification('Beobachtung nicht gefunden', 3000);
        console.error('Beobachtung nicht in Firebase gefunden:', observationId);
        return;
      }
      
      // NEU: Prüfe ob Owner oder Admin
      const isOwner = obs.userId === user.uid || obs.createdBy === user.email;
      
      let isAdmin = false;
      try {
        const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${user.uid}`).once('value');
        isAdmin = memberSnapshot.exists() && memberSnapshot.val().role === 'admin';
      } catch (error) {
        console.warn('Konnte Admin-Status nicht prüfen:', error);
      }
      
      if (!isOwner && !isAdmin) {
        showNotification('❌ Keine Berechtigung (nur eigene Beobachtungen oder Admin)', 2000);
        return;
      }
      
      // Toggle selffound
      const newSelffound = !obs.selffound;
      await obsRef.update({
        selffound: newSelffound,
        updatedAt: new Date().toISOString()
      });
      
      // Visuelles Update
      updateToggleButtonVisuals(observationId, 'selffound', newSelffound);
      
      showNotification(
        newSelffound ? '🔴 Als Selffound markiert' : '⚪ Selffound entfernt',
        2000
      );
      
      // Aktualisiere Challenge falls auf der Seite
      if (document.getElementById('compareRarity2026View') && 
          document.getElementById('compareRarity2026View').style.display !== 'none') {
        setTimeout(() => renderRarityChallenge2026(), 500);
      }
      
    } else {
      // IndexedDB-Modus (persönliche Beobachtungen)
      const observations = await getAllFromIndexedDB('observations');
      const obs = observations.find(o => o.id === observationId);
      
      if (!obs) {
        showNotification('Beobachtung nicht gefunden', 3000);
        console.error('Beobachtung nicht in IndexedDB gefunden:', observationId);
        return;
      }
      
      // Toggle
      obs.selffound = !obs.selffound;
      obs.updatedAt = new Date().toISOString();
      
      await saveToIndexedDB('observations', obs);
      
      // Nur visuelles Update ohne komplettes Neuladen
      updateToggleButtonVisuals(observationId, 'selffound', obs.selffound);
      
      showNotification(
        obs.selffound ? '🔴 Als Selffound markiert' : '⚪ Selffound entfernt',
        2000
      );
    }
    
    // Listen-Ansicht aktualisieren (falls offen)
    if (currentListId && document.getElementById('listDetailView').style.display === 'block') {
      setTimeout(() => {
        openListDetail(currentListId);
      }, 100);
    }
    
    // Beobachtungen-Manager aktualisieren (falls offen)
    if (document.getElementById('beobachtungen') && document.getElementById('beobachtungen').style.display !== 'none') {
      setTimeout(() => {
        if (typeof renderObservationManager === 'function') {
          renderObservationManager();
        }
      }, 100);
    }
    
  } catch (error) {
    console.error('Fehler beim Toggle Selffound:', error);
    showNotification('❌ Fehler beim Aktualisieren: ' + error.message, 3000);
  }
}

// Hilfsfunktion: Aktualisiert nur die visuellen Toggle-Buttons
function updateToggleButtonVisuals(observationId, toggleType, isActive) {
  // Finde alle Toggle-Buttons mit dieser Observations-ID
  const buttons = document.querySelectorAll(`.obs-toggle.${toggleType}`);
  
  buttons.forEach(button => {
    // Prüfe ob dieser Button zur richtigen Beobachtung gehört
    const onclick = button.getAttribute('onclick');
    if (onclick && onclick.includes(observationId)) {
      if (isActive && isActive !== false) {
        button.classList.add('active');
        if (toggleType === 'tickable') {
          button.innerHTML = '✓';
          button.setAttribute('title', 'Tickbar');
        } else if (toggleType === 'selffound') {
          button.innerHTML = '🔴';
          button.setAttribute('title', 'Selbst gefunden');
        }
      } else {
        button.classList.remove('active');
        button.innerHTML = '';
        if (toggleType === 'tickable') {
          button.setAttribute('title', 'Nicht tickbar');
        } else if (toggleType === 'selffound') {
          button.setAttribute('title', 'Nicht selbst gefunden');
        }
      }
    }
  });
}

// Globale Funktionen verfügbar machen
// ==================== BEOBACHTUNGEN MANAGER ====================

// NEU: Funktionen für aktive Filter-Anzeige
function updateActiveFiltersDisplay() {
  const container = document.getElementById('activeFiltersContainer');
  const badgesContainer = document.getElementById('activeFilterBadges');
  
  if (!container || !badgesContainer) return;
  
  badgesContainer.innerHTML = '';
  let hasFilters = false;
  
  // Suchfilter
  const searchTerm = document.getElementById('obsManagerSearch')?.value || '';
  if (searchTerm) {
    hasFilters = true;
    addFilterBadge('🔍 Suche', searchTerm, 'search');
  }
  
  // Datumsfilter
  const dateFrom = document.getElementById('obsManagerDateFrom')?.value;
  const dateTo = document.getElementById('obsManagerDateTo')?.value;
  if (dateFrom || dateTo) {
    hasFilters = true;
    const dateRange = `${dateFrom || '...'} bis ${dateTo || '...'}`;
    addFilterBadge('📅 Zeitraum', dateRange, 'daterange');
  }
  
  // Benutzerfilter (nur im Gruppenmodus)
  const userFilter = document.getElementById('obsManagerUserFilter')?.value;
  if (userFilter && userFilter !== 'all') {
    hasFilters = true;
    const userSelect = document.getElementById('obsManagerUserFilter');
    const userName = userSelect.options[userSelect.selectedIndex]?.text || userFilter;
    addFilterBadge('👤 Benutzer', userName, 'user');
  }
  
  // Kategoriefilter
  const filterNames = {
    'rare': '⭐ Selten',
    'very-rare': '⭐⭐ Sehr selten',
    'selffound': '🔴 Selffound',
    'tickable': '✓ Tickbar',
    'with-photo': '📸 Mit Foto',
    'others-not-me': '👀 Von anderen gesehen',
    'only-me': '✨ Nur ich gesehen',
    'all-members': '🌟 Von allen gesehen'
  };
  
  if (obsManagerCurrentFilter && obsManagerCurrentFilter !== 'all' && filterNames[obsManagerCurrentFilter]) {
    hasFilters = true;
    addFilterBadge('Kategorie', filterNames[obsManagerCurrentFilter], 'category');
  }
  
  // Spezifischer Mitgliedsfilter
  if (obsManagerSpecificMember) {
    hasFilters = true;
    const memberSelect = document.getElementById('obsManagerMemberFilter');
    const memberName = memberSelect.options[memberSelect.selectedIndex]?.text || obsManagerSpecificMember;
    addFilterBadge('🔍 Arten von', memberName, 'member');
  }
  
  // Container ein/ausblenden
  if (hasFilters) {
    container.classList.add('has-filters');
  } else {
    container.classList.remove('has-filters');
  }
}

function addFilterBadge(label, value, filterType) {
  const badgesContainer = document.getElementById('activeFilterBadges');
  if (!badgesContainer) return;
  
  const badge = document.createElement('div');
  badge.className = 'filter-badge';
  badge.innerHTML = `
    <span>${label}: ${value}</span>
    <button class="filter-badge-remove" onclick="removeObsManagerFilter('${filterType}')" title="Filter entfernen">×</button>
  `;
  badgesContainer.appendChild(badge);
}

function removeObsManagerFilter(filterType) {
  switch(filterType) {
    case 'search':
      document.getElementById('obsManagerSearch').value = '';
      break;
    case 'daterange':
      document.getElementById('obsManagerDateFrom').value = '';
      document.getElementById('obsManagerDateTo').value = '';
      break;
    case 'user':
      document.getElementById('obsManagerUserFilter').value = 'all';
      break;
    case 'category':
      setObsManagerFilter('all');
      break;
    case 'member':
      clearObsManagerMemberFilter();
      break;
  }
  filterObservationManager();
}

function clearAllObsManagerFilters() {
  // Alle Filter zurücksetzen
  document.getElementById('obsManagerSearch').value = '';
  document.getElementById('obsManagerDateFrom').value = '';
  document.getElementById('obsManagerDateTo').value = '';
  
  const userFilter = document.getElementById('obsManagerUserFilter');
  if (userFilter) {
    userFilter.value = 'all';
  }
  
  setObsManagerFilter('all');
  clearObsManagerMemberFilter();
  
  // Neu rendern
  filterObservationManager();
}

// ==================== BEOBACHTUNGEN MANAGER ====================

let obsManagerCurrentFilter = 'all';
let obsManagerCurrentSort = 'date-desc';
let obsManagerSpecificMember = ''; // Für spezifisches Mitglied

async function renderObservationManager() {
  console.log('📝 Lade Beobachtungen Manager...');
  
  try {
    // NEU: Prüfe ob im Gruppenmodus und ob User Admin ist
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    let isAdmin = false;
    
    // NEU: Lade Gruppendaten für Filter
    await loadGroupSpeciesData();
    
    // Zeige/Verstecke Gruppenfilter
    const groupFilters = document.getElementById('obsManagerGroupFilters');
    if (groupFilters) {
      groupFilters.style.display = isGroupMode ? 'flex' : 'none';
    }
    
    // NEU: Fülle Mitglieder-Dropdown
    if (isGroupMode && groupSpeciesData.isGroupMode) {
      const memberSelect = document.getElementById('obsManagerMemberFilter');
      if (memberSelect) {
        const currentUserId = window.FBA?.currentUser?.uid;
        let optionsHTML = '<option value="">-- Mitglied auswählen --</option>';
        
        Object.entries(groupSpeciesData.memberNames).forEach(([uid, name]) => {
          if (uid !== currentUserId) { // Zeige nur andere Mitglieder
            const displayName = name.split('@')[0]; // Kürze Email
            optionsHTML += `<option value="${uid}">${displayName}</option>`;
          }
        });
        
        memberSelect.innerHTML = optionsHTML;
      }
    }
    
    if (isGroupMode && window.FBA && window.FBD) {
      const user = window.FBA.currentUser;
      if (user) {
        const groupId = window.currentSelectedGroup;
        const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${user.uid}`).once('value');
        if (memberSnapshot.exists()) {
          isAdmin = memberSnapshot.val().role === 'admin';
        }
      }
    }
    
    // Lade alle Beobachtungen
    const allObservations = await getAllObservationsWithDetails();
    
    // NEU: Wenn im Gruppenmodus und Admin, zeige Benutzerfilter an
    const userFilterContainer = document.getElementById('obsManagerUserFilterContainer');
    if (isGroupMode && isAdmin && allObservations.length > 0) {
      // Sammle alle einzigartigen Benutzer
      const users = new Map();
      allObservations.forEach(obs => {
        const userId = obs.userId || obs.createdBy;
        const userName = obs.userName || obs.userEmail || 'Unbekannter Benutzer';
        if (userId && !users.has(userId)) {
          users.set(userId, userName);
        }
      });
      
      // Fülle Dropdown
      const userSelect = document.getElementById('obsManagerUserFilter');
      let optionsHTML = '<option value="all">Alle Benutzer anzeigen</option>';
      users.forEach((name, id) => {
        optionsHTML += `<option value="${id}">${name}</option>`;
      });
      userSelect.innerHTML = optionsHTML;
      userFilterContainer.style.display = 'block';
    } else {
      userFilterContainer.style.display = 'none';
    }
    
    if (!allObservations || allObservations.length === 0) {
      document.getElementById('obsManagerList').innerHTML = `
        <div class="card" style="text-align:center;padding:40px 20px;">
          <div style="font-size:48px;margin-bottom:16px;">🐦</div>
          <h3 style="margin:0 0 8px 0;">Noch keine Beobachtungen</h3>
          <p style="color:var(--muted);margin:0 0 16px 0;">Erstelle deine erste Beobachtung</p>
          <button class="btn" onclick="document.querySelector('.nav button[data-page=\\'eingabe\\']').click()">➕ Neue Beobachtung</button>
        </div>
      `;
      
      // Statistiken zurücksetzen
      document.getElementById('obsManagerCount').textContent = '0';
      document.getElementById('obsManagerSpecies').textContent = '0';
      document.getElementById('obsManagerRare').textContent = '0';
      document.getElementById('obsManagerVeryRare').textContent = '0';
      
      return;
    }
    
    // Filter anwenden
    let filteredObs = filterObservationsByManager(allObservations);
    
    // Sortierung anwenden
    filteredObs = sortObservationsByManager(filteredObs);
    
    // Statistiken berechnen
    const uniqueSpecies = new Set(filteredObs.map(o => o.bird)).size;
    const rareCount = filteredObs.filter(o => {
      const rarity = o.rarity || (birdDatabase[o.bird] ? birdDatabase[o.bird].status : null);
      return rarity === 'selten';
    }).length;
    const veryRareCount = filteredObs.filter(o => {
      const rarity = o.rarity || (birdDatabase[o.bird] ? birdDatabase[o.bird].status : null);
      return rarity === 'sehr selten';
    }).length;
    
    // Statistiken anzeigen
    document.getElementById('obsManagerCount').textContent = filteredObs.length;
    document.getElementById('obsManagerSpecies').textContent = uniqueSpecies;
    document.getElementById('obsManagerRare').textContent = rareCount;
    document.getElementById('obsManagerVeryRare').textContent = veryRareCount;
    
    // NEU: Aktive Filter anzeigen
    updateActiveFiltersDisplay();
    
    // NEU: Zeige Info wenn spezifischer Mitgliederfilter aktiv ist
    let filterInfoHtml = '';
    if (obsManagerSpecificMember && groupSpeciesData.memberNames[obsManagerSpecificMember]) {
      const memberName = groupSpeciesData.memberNames[obsManagerSpecificMember];
      const displayName = memberName.split('@')[0];
      filterInfoHtml = `
        <div class="card" style="background:linear-gradient(135deg, rgba(124,58,237,0.15), rgba(6,182,212,0.1));border:2px solid rgba(124,58,237,0.4);margin-bottom:16px;">
          <div style="display:flex;align-items:center;gap:12px;">
            <div style="font-size:24px;">🔍</div>
            <div style="flex:1;">
              <div style="font-weight:700;font-size:15px;margin-bottom:4px;">
                Aktiver Filter: Arten von ${displayName}
              </div>
              <div style="font-size:13px;color:var(--muted);">
                Zeigt Arten, die ${displayName} gesehen hat, aber du noch nicht
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // NEU: Gruppiere Beobachtungen nach Personen
    const groupedByPerson = new Map();
    filteredObs.forEach(obs => {
      const userId = obs.userId || obs.createdBy || 'unknown';
      const userName = obs.userName || obs.userEmail || 'Unbekannter Benutzer';
      
      // NEU: Im Gruppenmodus nur Beobachtungen von aktuellen Mitgliedern anzeigen
      if (isGroupMode && groupSpeciesData.isGroupMode) {
        // Prüfe ob userId ein bekanntes Gruppenmitglied ist
        if (!groupSpeciesData.memberNames[userId]) {
          // Überspringe Beobachtungen von unbekannten/ehemaligen Mitgliedern
          return;
        }
      }
      
      if (!groupedByPerson.has(userId)) {
        groupedByPerson.set(userId, {
          userName: userName,
          observations: []
        });
      }
      groupedByPerson.get(userId).observations.push(obs);
    });
    
    // Liste rendern mit zusammenklappbaren Bereichen pro Person
    let html = filterInfoHtml + '<div style="display:flex;flex-direction:column;gap:16px;">';
    
    // Sortiere Personen nach Anzahl der Beobachtungen (absteigend)
    const sortedPersons = Array.from(groupedByPerson.entries()).sort((a, b) => 
      b[1].observations.length - a[1].observations.length
    );
    
    sortedPersons.forEach(([userId, personData]) => {
      const personObs = personData.observations;
      const personName = personData.userName;
      const personInitial = personName.charAt(0).toUpperCase();
      
      // Berechne Statistiken für diese Person
      const personUniqueSpecies = new Set(personObs.map(o => o.bird)).size;
      const personRareCount = personObs.filter(o => {
        const rarity = o.rarity || (birdDatabase[o.bird] ? birdDatabase[o.bird].status : null);
        return rarity === 'selten';
      }).length;
      const personVeryRareCount = personObs.filter(o => {
        const rarity = o.rarity || (birdDatabase[o.bird] ? birdDatabase[o.bird].status : null);
        return rarity === 'sehr selten';
      }).length;
      
      const accordionId = `person-accordion-${userId}`;
      
      html += `
        <div class="person-accordion">
          <div class="person-accordion-header" onclick="togglePersonAccordion('${accordionId}')">
            <div class="person-info">
              <div class="person-avatar">${personInitial}</div>
              <div class="person-details">
                <div class="person-name">${personName}</div>
                <div class="person-stats">
                  <span>📊 ${personObs.length} Beobachtungen</span>
                  <span>🐦 ${personUniqueSpecies} Arten</span>
                  ${personRareCount > 0 ? `<span>⭐ ${personRareCount} selten</span>` : ''}
                  ${personVeryRareCount > 0 ? `<span>💎 ${personVeryRareCount} sehr selten</span>` : ''}
                </div>
              </div>
            </div>
            <div class="person-toggle">
              <span>Anzeigen</span>
              <span class="person-toggle-icon">▼</span>
            </div>
          </div>
          
          <div class="person-accordion-content" id="${accordionId}">
            <div class="person-observations">
      `;
      
      // Rendere alle Beobachtungen dieser Person
      personObs.forEach(obs => {
        const speciesInfo = birdDatabase[obs.bird] || {};
        const rarity = obs.rarity || speciesInfo.status || '';
        const rarityStyle = getRarityStyle(obs.bird, obs.rarity);
        
        html += `
          <div class="card" style="background:rgba(255,255,255,0.02);border-left:3px solid ${obs.folderColor || 'var(--accent)'};">
            <div style="display:flex;justify-content:space-between;align-items:start;gap:16px;">
              <div style="flex:1;">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
                  <div class="observation-species ${rarityStyle.rarityClass}" style="font-size:18px;font-weight:600;">
                    ${rarityStyle.rarityIcon}${obs.bird}
                  </div>
                  ${obs.selffound ? '<span style="font-size:16px;" title="Selffound">🔴</span>' : ''}
                  ${obs.tickable !== false ? '<span style="font-size:16px;" title="Tickbar">✓</span>' : ''}
                  ${obs.photo ? '<span style="font-size:16px;" title="Mit Foto">📸</span>' : ''}
                </div>
                
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:8px;font-size:13px;color:var(--muted);">
                  <div>
                    <span style="opacity:0.7;">📅</span>
                    <span style="margin-left:4px;">${formatDateForDisplay(obs.date)}</span>
                    ${obs.time ? `<span style="margin-left:8px;">🕒 ${obs.time}</span>` : ''}
                  </div>
                  <div>
                    <span style="opacity:0.7;">📍</span>
                    <span style="margin-left:4px;">${obs.folderName || 'Unbekannt'}</span>
                  </div>
                  <div>
                    <span style="opacity:0.7;">🔢</span>
                    <span style="margin-left:4px;">${obs.count || '1'} Exemplar(e)</span>
                  </div>
                  ${obs.behavior ? `
                  <div>
                    <span style="opacity:0.7;">🎭</span>
                    <span style="margin-left:4px;">${obs.behavior}</span>
                  </div>
                  ` : ''}
                </div>
                
                ${speciesInfo.scientific ? `
                <div style="font-size:12px;color:var(--muted);margin-top:4px;font-style:italic;">
                  ${speciesInfo.scientific}
                </div>
                ` : ''}
              </div>
              
              <div style="display:flex;flex-direction:column;gap:6px;min-width:120px;">
                <button class="small-btn" onclick="showObservationDetail('${obs.id}')" style="width:100%;">
                  👁️ Details
                </button>
                <button class="small-btn" onclick="openEditModal('${obs.id}')" style="width:100%;background:rgba(249,115,22,0.1);">
                  ✏️ Bearbeiten
                </button>
                <button class="small-btn" onclick="openQuickRarityEditor('${obs.id}', '${obs.bird}')" style="width:100%;background:rgba(124,58,237,0.1);">
                  ⭐ Seltenheit
                </button>
                
                <!-- Toggle Buttons mit Labels -->
                <div style="display:flex;flex-direction:column;gap:4px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;">
                  <label style="font-size:10px;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:0.5px;">Status</label>
                  <button class="small-btn" onclick="toggleTickable('${obs.id}')" 
                          style="width:100%;display:flex;align-items:center;justify-content:center;gap:6px;background:${obs.tickable !== false ? 'rgba(16,185,129,0.25)' : 'rgba(255,255,255,0.05)'};border:2px solid ${obs.tickable !== false ? 'rgba(16,185,129,0.5)' : 'transparent'};" 
                          title="Tickbar umschalten">
                    <span style="font-size:14px;">${obs.tickable !== false ? '✓' : '○'}</span>
                    <span style="font-size:11px;font-weight:600;">Tickbar</span>
                  </button>
                  <button class="small-btn" onclick="toggleSelffound('${obs.id}')" 
                          style="width:100%;display:flex;align-items:center;justify-content:center;gap:6px;background:${obs.selffound ? 'rgba(239,68,68,0.25)' : 'rgba(255,255,255,0.05)'};border:2px solid ${obs.selffound ? 'rgba(239,68,68,0.5)' : 'transparent'};" 
                          title="Selffound umschalten">
                    <span style="font-size:14px;">${obs.selffound ? '🔴' : '○'}</span>
                    <span style="font-size:11px;font-weight:600;">Selffound</span>
                  </button>
                </div>
                
                <button class="small-btn" onclick="showObservationOnMap('${obs.id}')" style="width:100%;background:rgba(6,182,212,0.1);">
                  🗺️ Karte
                </button>
                <button class="small-btn" onclick="deleteObservationFromManager('${obs.id}')" style="width:100%;background:var(--danger);">
                  🗑️ Löschen
                </button>
              </div>
            </div>
            
            ${obs.photo ? `
            <div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.05);">
              <img src="${obs.photo}" 
                   onclick="openPhotoLightbox('${obs.photo}', '${obs.bird} - ${formatDateForDisplay(obs.date)}')" 
                   style="width:100%;max-height:400px;object-fit:contain;border-radius:8px;cursor:pointer;background:rgba(0,0,0,0.2);" 
                   alt="Beobachtungsfoto">
            </div>
            ` : ''}
          </div>
        `;
      });
      
      html += `
            </div>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    
    if (filteredObs.length === 0) {
      html = `
        <div class="card" style="text-align:center;padding:40px 20px;">
          <div style="font-size:48px;margin-bottom:16px;">🔍</div>
          <h3 style="margin:0 0 8px 0;">Keine Beobachtungen gefunden</h3>
          <p style="color:var(--muted);margin:0;">Versuche andere Filter-Einstellungen</p>
        </div>
      `;
    }
    
    document.getElementById('obsManagerList').innerHTML = html;
    
  } catch (error) {
    console.error('Fehler beim Laden der Beobachtungen:', error);
    document.getElementById('obsManagerList').innerHTML = `
      <div class="card" style="text-align:center;padding:40px 20px;background:rgba(239,68,68,0.1);">
        <div style="font-size:48px;margin-bottom:16px;">❌</div>
        <h3 style="margin:0 0 8px 0;">Fehler beim Laden</h3>
        <p style="color:var(--muted);margin:0;">${error.message}</p>
      </div>
    `;
  }
}

function filterObservationsByManager(observations) {
  let filtered = [...observations];
  
  // NEU: Benutzerfilter (nur im Gruppenmodus)
  const userFilter = document.getElementById('obsManagerUserFilter')?.value || 'all';
  if (userFilter !== 'all') {
    filtered = filtered.filter(obs => obs.userId === userFilter || obs.createdBy === userFilter);
  }
  
  // Textsuche
  const searchTerm = document.getElementById('obsManagerSearch')?.value.toLowerCase() || '';
  if (searchTerm) {
    filtered = filtered.filter(obs => 
      obs.bird.toLowerCase().includes(searchTerm) ||
      (obs.folderName && obs.folderName.toLowerCase().includes(searchTerm)) ||
      (obs.behavior && obs.behavior.toLowerCase().includes(searchTerm))
    );
  }
  
  // Datumsfilter
  const dateFrom = document.getElementById('obsManagerDateFrom')?.value;
  const dateTo = document.getElementById('obsManagerDateTo')?.value;
  
  if (dateFrom) {
    filtered = filtered.filter(obs => obs.date >= dateFrom);
  }
  if (dateTo) {
    filtered = filtered.filter(obs => obs.date <= dateTo);
  }
  
  // Kategoriefilter
  switch (obsManagerCurrentFilter) {
    case 'rare':
      filtered = filtered.filter(obs => {
        const rarity = obs.rarity || (birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : null);
        return rarity === 'selten';
      });
      break;
    case 'very-rare':
      filtered = filtered.filter(obs => {
        const rarity = obs.rarity || (birdDatabase[obs.bird] ? birdDatabase[obs.bird].status : null);
        return rarity === 'sehr selten';
      });
      break;
    case 'selffound':
      filtered = filtered.filter(obs => obs.selffound === true);
      break;
    case 'tickable':
      filtered = filtered.filter(obs => obs.tickable !== false);
      break;
    case 'with-photo':
      filtered = filtered.filter(obs => obs.photo);
      break;
    
    // NEU: Gruppenfilter
    case 'others-not-me':
      // Zeige nur Arten, die andere Gruppenmitglieder gesehen haben, aber ich nicht
      if (groupSpeciesData.isGroupMode) {
        const currentUserId = window.FBA?.currentUser?.uid;
        const mySpecies = new Set();
        
        // Sammle alle meine Arten
        filtered.forEach(obs => {
          if (obs.userId === currentUserId || obs.createdBy === currentUserId) {
            if (obs.tickable !== false) {
              mySpecies.add(obs.bird);
            }
          }
        });
        
        // Filtere: Zeige nur Beobachtungen von Arten, die andere gesehen haben, aber ich nicht
        filtered = filtered.filter(obs => {
          const speciesSeenByOthers = groupSpeciesData.speciesByMember[obs.bird];
          const speciesSeenByMe = mySpecies.has(obs.bird);
          
          // Art wurde von anderen gesehen UND ich habe sie nicht gesehen
          return speciesSeenByOthers && speciesSeenByOthers.length > 0 && !speciesSeenByMe;
        });
      }
      break;
      
    case 'only-me':
      // Zeige nur Arten, die nur ich gesehen habe (nicht andere Gruppenmitglieder)
      if (groupSpeciesData.isGroupMode) {
        const currentUserId = window.FBA?.currentUser?.uid;
        
        filtered = filtered.filter(obs => {
          const speciesSeenBy = groupSpeciesData.speciesByMember[obs.bird];
          // Art wurde nur von mir gesehen (Array hat nur meine UID)
          return speciesSeenBy && speciesSeenBy.length === 1 && speciesSeenBy[0] === currentUserId;
        });
      }
      break;
      
    case 'all-members':
      // Zeige nur Arten, die von ALLEN Gruppenmitgliedern gesehen wurden
      if (groupSpeciesData.isGroupMode) {
        const allMemberCount = Object.keys(groupSpeciesData.memberNames).length;
        
        filtered = filtered.filter(obs => {
          const speciesSeenBy = groupSpeciesData.speciesByMember[obs.bird];
          // Art wurde von allen gesehen
          return speciesSeenBy && speciesSeenBy.length === allMemberCount;
        });
      }
      break;
  }
  
  // NEU: Spezifischer Mitgliederfilter
  if (obsManagerSpecificMember && groupSpeciesData.isGroupMode) {
    const currentUserId = window.FBA?.currentUser?.uid;
    const mySpecies = new Set();
    
    // Sammle alle meine Arten
    filtered.forEach(obs => {
      if (obs.userId === currentUserId || obs.createdBy === currentUserId) {
        if (obs.tickable !== false) {
          mySpecies.add(obs.bird);
        }
      }
    });
    
    // Zeige nur Arten, die das gewählte Mitglied gesehen hat, aber ich nicht
    filtered = filtered.filter(obs => {
      const speciesSeenBy = groupSpeciesData.speciesByMember[obs.bird];
      const memberHasSpecies = speciesSeenBy && speciesSeenBy.includes(obsManagerSpecificMember);
      const iDontHaveSpecies = !mySpecies.has(obs.bird);
      
      return memberHasSpecies && iDontHaveSpecies;
    });
  }
  
  return filtered;
}

function sortObservationsByManager(observations) {
  const sorted = [...observations];
  
  switch (obsManagerCurrentSort) {
    case 'date-desc':
      sorted.sort((a, b) => new Date(b.date) - new Date(a.date));
      break;
    case 'date-asc':
      sorted.sort((a, b) => new Date(a.date) - new Date(b.date));
      break;
    case 'species':
      sorted.sort((a, b) => a.bird.localeCompare(b.bird));
      break;
  }
  
  return sorted;
}

function setObsManagerFilter(filter) {
  obsManagerCurrentFilter = filter;
  
  // Update Button-Styles
  document.querySelectorAll('.obs-filter-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
  
  renderObservationManager();
}

function setObsManagerSort(sort) {
  obsManagerCurrentSort = sort;
  
  // Update Button-Styles
  document.querySelectorAll('[id^="sort"]').forEach(btn => {
    btn.style.background = 'transparent';
  });
  
  const buttonId = sort === 'date-desc' ? 'sortDateDesc' : 
                   sort === 'date-asc' ? 'sortDateAsc' : 'sortSpecies';
  const button = document.getElementById(buttonId);
  if (button) {
    button.style.background = 'var(--accent)';
  }
  
  renderObservationManager();
}

// NEU: Spezifischen Mitgliederfilter setzen
function setObsManagerMemberFilter() {
  const memberSelect = document.getElementById('obsManagerMemberFilter');
  if (memberSelect) {
    obsManagerSpecificMember = memberSelect.value;
    
    if (obsManagerSpecificMember) {
      // Deaktiviere andere Filter-Buttons wenn spezifisches Mitglied gewählt
      document.querySelectorAll('.obs-filter-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Markiere das Dropdown visuell
      memberSelect.style.borderColor = 'var(--accent)';
      memberSelect.style.background = 'rgba(124,58,237,0.1)';
    }
    
    renderObservationManager();
  }
}

// NEU: Mitgliederfilter zurücksetzen
function clearObsManagerMemberFilter() {
  obsManagerSpecificMember = '';
  const memberSelect = document.getElementById('obsManagerMemberFilter');
  if (memberSelect) {
    memberSelect.value = '';
    memberSelect.style.borderColor = '';
    memberSelect.style.background = '';
  }
  renderObservationManager();
}

function filterObservationManager() {
  renderObservationManager();
}

async function deleteObservationFromManager(observationId) {
  if (!confirm('Möchtest du diese Beobachtung wirklich löschen?')) {
    return;
  }
  
  try {
    // Prüfe ob im Gruppenmodus
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // NEU: Prüfe ob Firebase verfügbar ist
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 3000);
        console.error('Firebase ist nicht initialisiert');
        return;
      }
      
      // NEU: Prüfe ob User Admin ist oder die Beobachtung selbst erstellt hat
      let user = null;
      try {
        user = window.FBA.currentUser;
      } catch (authError) {
        console.error('Auth-Fehler:', authError);
        showNotification('❌ Nicht angemeldet', 3000);
        return;
      }
      
      if (!user) {
        showNotification('❌ Nicht angemeldet', 3000);
        return;
      }
      
      // Lade die Beobachtung
      const groupId = window.currentSelectedGroup;
      const obsSnapshot = await window.FBD.ref(`groups/${groupId}/observations/${observationId}`).once('value');
      
      if (!obsSnapshot.exists()) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
      
      const obs = obsSnapshot.val();
      const isOwner = obs.userId === user.uid || obs.createdBy === user.email;
      
      // Prüfe Admin-Status
      let isAdmin = false;
      try {
        const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${user.uid}`).once('value');
        isAdmin = memberSnapshot.exists() && memberSnapshot.val().role === 'admin';
      } catch (error) {
        console.warn('Konnte Admin-Status nicht prüfen:', error);
      }
      
      // Nur Owner oder Admin dürfen löschen
      if (!isOwner && !isAdmin) {
        showNotification('❌ Keine Berechtigung zum Löschen (nur eigene Beobachtungen oder Admin)', 3000);
        return;
      }
      
      // Firebase-Modus: Löschen
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      await obsRef.remove();
      
      showNotification('✅ Beobachtung aus Gruppe gelöscht', 3000);
    } else {
      // Lokaler Modus
      
      // Marker von der Karte entfernen
      if (window.markers && window.markers.has(observationId)) {
        const marker = window.markers.get(observationId);
        if (marker) {
          if (window.markerCluster) {
            window.markerCluster.removeLayer(marker);
          }
          marker.remove();
          window.markers.delete(observationId);
        }
      }
      
      // Aus IndexedDB löschen
      await deleteObservationFromDB(observationId);
      
      showNotification('✅ Beobachtung gelöscht', 2000);
    }
    
    // Liste neu laden
    await renderObservationManager();
    
    // NEU: Synchronisiere geteilte Listen (nur im privaten Modus)
    if (!isGroupMode) {
      await syncSharedListsAfterNewObservation();
    }
    
    // Andere UI-Elemente aktualisieren
    if (typeof updateDashboard === 'function') updateDashboard();
    if (typeof updateChart === 'function') updateChart();
    if (typeof updateAdvancedStatistics === 'function') updateAdvancedStatistics();
    
  } catch (error) {
    console.error('Fehler beim Löschen:', error);
    showNotification('❌ Fehler beim Löschen: ' + error.message, 3000);
  }
}

// Globale Funktionen verfügbar machen
window.renderObservationManager = renderObservationManager;
window.setObsManagerFilter = setObsManagerFilter;
window.setObsManagerSort = setObsManagerSort;
window.filterObservationManager = filterObservationManager;
window.setObsManagerMemberFilter = setObsManagerMemberFilter;
window.clearObsManagerMemberFilter = clearObsManagerMemberFilter;
window.deleteObservationFromManager = deleteObservationFromManager;
window.updateActiveFiltersDisplay = updateActiveFiltersDisplay;
window.removeObsManagerFilter = removeObsManagerFilter;
window.clearAllObsManagerFilters = clearAllObsManagerFilters;

    // ==================== ENDE BEOBACHTUNGEN MANAGER ====================

// NEU: Funktion zum Löschen ALLER Listen (für Debugging)
async function clearAllLists() {
  if (!confirm('Möchtest du wirklich ALLE Listen löschen? Dies kann nicht rückgängig gemacht werden!')) {
    return;
  }
  
  try {
    const lists = await getAllFromIndexedDB('lists');
    console.log('Lösche', lists.length, 'Listen...');
    
    for (const list of lists) {
      await deleteFromIndexedDB('lists', list.id);
    }
    
    userLists = [];
    await renderLists();
    showNotification('✅ Alle Listen gelöscht', 3000);
    console.log('Alle Listen wurden gelöscht');
  } catch (error) {
    console.error('Fehler beim Löschen der Listen:', error);
    showNotification('❌ Fehler beim Löschen', 3000);
  }
}

// Mache Funktion global verfügbar (kann in der Console aufgerufen werden mit: clearAllLists())
window.clearAllLists = clearAllLists;

// NEU: Funktion zum Ein-/Ausblenden der Raritäten-Details
function toggleRarityDetails(detailsId) {
  const detailsElement = document.getElementById(detailsId);
  if (detailsElement) {
    if (detailsElement.style.display === 'none') {
      detailsElement.style.display = 'block';
    } else {
      detailsElement.style.display = 'none';
    }
  }
}

window.toggleRarityDetails = toggleRarityDetails;

// NEU: Selffound-Status in Challenge-Ansicht ändern
async function toggleSelffoundInChallenge(observationId, newSelffoundStatus) {
  try {
    // NEU: Merke geöffnete Details-Bereiche
    const openPanels = [];
    document.querySelectorAll('[id^="details_"], [id^="blocked_"]').forEach(panel => {
      if (panel.style.display !== 'none') {
        openPanels.push(panel.id);
      }
    });
    
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // Gruppenmodus: Update in Firebase
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 3000);
        return;
      }
      
      const groupId = window.currentSelectedGroup;
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      
      await obsRef.update({
        selffound: newSelffoundStatus,
        updatedAt: new Date().toISOString()
      });
      
      showNotification(`✅ Selffound ${newSelffoundStatus ? 'gesetzt' : 'entfernt'}`, 2000);
    } else {
      // Lokaler Modus: Update in IndexedDB
      const obs = await getFromIndexedDB('observations', observationId);
      if (!obs) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
      
      obs.selffound = newSelffoundStatus;
      obs.updatedAt = new Date().toISOString();
      
      await saveToIndexedDB('observations', obs);
      showNotification(`✅ Selffound ${newSelffoundStatus ? 'gesetzt' : 'entfernt'}`, 2000);
    }
    
    // Leaderboard neu laden
    await renderRarityChallenge2026();
    
    // NEU: Öffne die zuvor geöffneten Panels wieder
    setTimeout(() => {
      openPanels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel) {
          panel.style.display = 'block';
        }
      });
    }, 100);
    
  } catch (error) {
    console.error('Fehler beim Ändern des Selffound-Status:', error);
    showNotification('❌ Fehler: ' + error.message, 3000);
  }
}

// NEU: Prüfe ob der aktuelle User ein Gruppenadmin ist
async function isCurrentUserGroupAdmin() {
  if (!window.currentSelectedGroup || window.currentSelectedGroup === 'personal') {
    return false;
  }
  
  if (!window.FBA || !window.FBD || !window.FBA.currentUser) {
    return false;
  }
  
  try {
    const groupId = window.currentSelectedGroup;
    const userId = window.FBA.currentUser.uid;
    
    const memberSnapshot = await window.FBD.ref(`groups/${groupId}/members/${userId}`).once('value');
    const memberData = memberSnapshot.val();
    
    return memberData && memberData.role === 'admin';
  } catch (error) {
    console.error('Fehler beim Prüfen der Admin-Rechte:', error);
    return false;
  }
}

// NEU: Manuelle Entblockierung einer Art (mit Admin-Support)
async function manualUnblockSpecies(observationId, blockedByUserId, targetUserId) {
  // Prüfe ob User Admin ist oder es seine eigene Beobachtung ist
  const isAdmin = await isCurrentUserGroupAdmin();
  const currentUserId = window.FBA?.currentUser?.uid;
  const isOwnObservation = targetUserId === currentUserId;
  
  if (!isAdmin && !isOwnObservation) {
    showNotification('❌ Nur Admins können Beobachtungen anderer Nutzer entblocken', 3000);
    return;
  }
  
  const confirmMessage = isOwnObservation 
    ? 'Möchtest du diese Art wirklich manuell entblocken? Sie wird dann Punkte bringen, obwohl sie bereits in der Nähe gemeldet wurde.'
    : '🔐 Admin-Aktion: Möchtest du diese Art eines anderen Gruppenmitglieds wirklich entblocken? Sie wird dann Punkte bringen.';
  
  if (!confirm(confirmMessage)) {
    return;
  }
  
  try {
    // NEU: Merke geöffnete Details-Bereiche
    const openPanels = [];
    document.querySelectorAll('[id^="details_"], [id^="blocked_"]').forEach(panel => {
      if (panel.style.display !== 'none') {
        openPanels.push(panel.id);
      }
    });
    
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // Gruppenmodus: Setze ein Flag in Firebase
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 3000);
        return;
      }
      
      const groupId = window.currentSelectedGroup;
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      
      await obsRef.update({
        manuallyUnblocked: true, // NEU: Flag dass diese Art manuell entblockt wurde
        manuallyBlocked: false, // Entferne evtl. vorhandenes Block-Flag
        unblockedAt: new Date().toISOString(),
        unblockedBy: currentUserId, // NEU: Wer hat entblockt
        unblockedByAdmin: isAdmin && !isOwnObservation, // NEU: War es eine Admin-Aktion
        updatedAt: new Date().toISOString()
      });
      
      const successMsg = isAdmin && !isOwnObservation 
        ? '✅ Admin: Art wurde entblockt und bringt jetzt Punkte!'
        : '✅ Art wurde entblockt und bringt jetzt Punkte!';
      showNotification(successMsg, 3000);
    } else {
      // Lokaler Modus: Update in IndexedDB
      const obs = await getFromIndexedDB('observations', observationId);
      if (!obs) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
      
      obs.manuallyUnblocked = true;
      obs.manuallyBlocked = false;
      obs.unblockedAt = new Date().toISOString();
      obs.updatedAt = new Date().toISOString();
      
      await saveToIndexedDB('observations', obs);
      showNotification('✅ Art wurde entblockt und bringt jetzt Punkte!', 3000);
    }
    
    // Warte kurz, damit Firebase/IndexedDB-Update abgeschlossen ist
    await new Promise(resolve => setTimeout(resolve, 300));
    
    console.log(`✅ Art entblockt: ${observationId} - Lade Leaderboard neu...`);
    
    // Leaderboard neu laden
    await renderRarityChallenge2026();
    
    console.log('✅ Leaderboard neu geladen - Punkte sollten aktualisiert sein');
    
    // NEU: Öffne die zuvor geöffneten Panels wieder
    setTimeout(() => {
      openPanels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel) {
          panel.style.display = 'block';
        }
      });
    }, 100);
    
  } catch (error) {
    console.error('Fehler beim Entblocken:', error);
    showNotification('❌ Fehler: ' + error.message, 3000);
  }
}

// NEU: Funktion zum wieder Blockieren einer Art (mit Admin-Support)
async function manualBlockSpecies(observationId, targetUserId) {
  // Prüfe ob User Admin ist oder es seine eigene Beobachtung ist
  const isAdmin = await isCurrentUserGroupAdmin();
  const currentUserId = window.FBA?.currentUser?.uid;
  const isOwnObservation = targetUserId === currentUserId;
  
  if (!isAdmin && !isOwnObservation) {
    showNotification('❌ Nur Admins können Beobachtungen anderer Nutzer blockieren', 3000);
    return;
  }
  
  const confirmMessage = isOwnObservation 
    ? 'Möchtest du diese Art wirklich blockieren? Sie wird dann keine Punkte mehr bringen.'
    : '🔐 Admin-Aktion: Möchtest du diese Art eines anderen Gruppenmitglieds wirklich blockieren? Sie wird dann keine Punkte mehr bringen.';
  
  if (!confirm(confirmMessage)) {
    return;
  }
  
  try {
    // NEU: Merke geöffnete Details-Bereiche
    const openPanels = [];
    document.querySelectorAll('[id^="details_"], [id^="blocked_"]').forEach(panel => {
      if (panel.style.display !== 'none') {
        openPanels.push(panel.id);
      }
    });
    
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    if (isGroupMode) {
      // Gruppenmodus: Setze das manuallyBlocked Flag in Firebase
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 3000);
        return;
      }
      
      const groupId = window.currentSelectedGroup;
      const obsRef = window.FBD.ref(`groups/${groupId}/observations/${observationId}`);
      
      // DEBUG: Zeige welche Beobachtung blockiert wird
      const obsSnapshot = await obsRef.once('value');
      const obsData = obsSnapshot.val();
      console.log('🔒 BLOCKIERE BEOBACHTUNG:', {
        id: observationId,
        bird: obsData.bird,
        date: obsData.date,
        time: obsData.time,
        lat: obsData.lat,
        lng: obsData.lng,
        currentUserId: currentUserId,
        targetUserId: targetUserId
      });
      
      await obsRef.update({
        manuallyBlocked: true, // NEU: Flag dass diese Art manuell blockiert wurde
        manuallyUnblocked: false, // Entferne evtl. vorhandenes Unblock-Flag
        blockedAt: new Date().toISOString(),
        blockedBy: currentUserId, // NEU: Wer hat blockiert
        blockedByAdmin: isAdmin && !isOwnObservation, // NEU: War es eine Admin-Aktion
        updatedAt: new Date().toISOString()
      });
      
      // DEBUG: Verifiziere dass die Daten gespeichert wurden
      console.log('✅ Firebase UPDATE durchgeführt für Observation:', observationId);
      const verifySnapshot = await obsRef.once('value');
      const verifyData = verifySnapshot.val();
      console.log('🔍 Verifiziere gespeicherte Daten:', {
        id: observationId,
        bird: verifyData.bird,
        manuallyBlocked: verifyData.manuallyBlocked,
        blockedAt: verifyData.blockedAt,
        blockedBy: verifyData.blockedBy
      });
      
      const successMsg = isAdmin && !isOwnObservation 
        ? '✅ Admin: Art wurde blockiert und bringt keine Punkte mehr!'
        : '✅ Art wurde blockiert und bringt keine Punkte mehr!';
      showNotification(successMsg, 3000);
    } else {
      // Lokaler Modus: Update in IndexedDB
      const obs = await getFromIndexedDB('observations', observationId);
      if (!obs) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
      
      obs.manuallyBlocked = true;
      obs.manuallyUnblocked = false;
      obs.blockedAt = new Date().toISOString();
      obs.updatedAt = new Date().toISOString();
      
      await saveToIndexedDB('observations', obs);
      showNotification('✅ Art wurde blockiert und bringt keine Punkte mehr!', 3000);
    }
    
    // Warte kurz, damit Firebase/IndexedDB-Update abgeschlossen ist
    await new Promise(resolve => setTimeout(resolve, 300));
    
    console.log(`🚫 Art blockiert: ${observationId} - Lade Leaderboard neu...`);
    
    // Leaderboard neu laden
    await renderRarityChallenge2026();
    
    console.log('✅ Leaderboard neu geladen - Punkte sollten aktualisiert sein');
    
    // NEU: Öffne die zuvor geöffneten Panels wieder
    setTimeout(() => {
      openPanels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel) {
          panel.style.display = 'block';
        }
      });
    }, 100);
    
  } catch (error) {
    console.error('Fehler beim Blockieren:', error);
    showNotification('❌ Fehler: ' + error.message, 3000);
  }
}

window.isCurrentUserGroupAdmin = isCurrentUserGroupAdmin;

window.toggleSelffoundInChallenge = toggleSelffoundInChallenge;
window.manualUnblockSpecies = manualUnblockSpecies;
window.manualBlockSpecies = manualBlockSpecies;

// NEU: Zeige Beobachtung auf der Karte an (mit Koordinaten)
function showObservationOnMapByCoords(lat, lng, birdName) {
  console.log('🗺️ Zeige auf Karte:', { lat, lng, birdName });
  
  // Wechsle zur Karte-Ansicht
  const mapButton = document.querySelector('.nav button[data-page="karte"]');
  if (mapButton) {
    mapButton.click();
  }
  
  // Warte kurz, damit die Karte geladen ist
  setTimeout(() => {
    // Prüfe sowohl window.map als auch window.mapObj
    const activeMap = window.mapObj || window.map;
    
    if (activeMap) {
      console.log('✅ Karte gefunden, zentriere auf Position');
      
      // Zentriere Karte auf Position mit gutem Zoom
      activeMap.setView([lat, lng], 16);
      
      // Erstelle temporären Marker (roter Marker für Hervorhebung)
      const tempMarker = L.marker([lat, lng], {
        icon: L.divIcon({
          className: 'temp-highlight-marker',
          html: '<div style="background:#ef4444;width:30px;height:30px;border-radius:50%;border:3px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;font-size:16px;">📍</div>',
          iconSize: [30, 30],
          iconAnchor: [15, 15]
        })
      }).addTo(activeMap);
      
      // Popup mit Vogelnamen
      tempMarker.bindPopup(`
        <div style="text-align:center;padding:4px;">
          <strong style="font-size:14px;">${birdName}</strong><br>
          <span style="font-size:11px;color:#666;">Lat: ${lat.toFixed(5)}, Lng: ${lng.toFixed(5)}</span>
        </div>
      `).openPopup();
      
      // Marker nach 15 Sekunden entfernen
      setTimeout(() => {
        activeMap.removeLayer(tempMarker);
        console.log('🗑️ Temporärer Marker entfernt');
      }, 15000);
      
      showNotification(`📍 ${birdName} auf Karte angezeigt`, 2000);
    } else {
      console.error('❌ Karte nicht gefunden (weder window.mapObj noch window.map)');
      showNotification('⚠️ Karte nicht verfügbar', 2000);
    }
  }, 500);  // Erhöht von 300ms auf 500ms für bessere Ladezeit
}

window.showObservationOnMapByCoords = showObservationOnMapByCoords;

// ==================== PERSONEN-AKKORDEON ====================

// NEU: Toggle-Funktion für Personen-Akkordeons
function togglePersonAccordion(accordionId) {
  const content = document.getElementById(accordionId);
  const header = content.previousElementSibling;
  const toggleIcon = header.querySelector('.person-toggle-icon');
  const toggleText = header.querySelector('.person-toggle span:first-child');
  
  if (content.classList.contains('expanded')) {
    // Zuklappen
    content.classList.remove('expanded');
    header.classList.add('collapsed');
    toggleIcon.classList.remove('expanded');
    toggleText.textContent = 'Anzeigen';
  } else {
    // Aufklappen
    content.classList.add('expanded');
    header.classList.remove('collapsed');
    toggleIcon.classList.add('expanded');
    toggleText.textContent = 'Verbergen';
  }
}

window.togglePersonAccordion = togglePersonAccordion;

// NEU: Alle Personen-Akkordeons auf-/zuklappen
function toggleAllPersonAccordions(expand = true) {
  const allContents = document.querySelectorAll('.person-accordion-content');
  allContents.forEach(content => {
    const accordionId = content.id;
    const header = content.previousElementSibling;
    const toggleIcon = header.querySelector('.person-toggle-icon');
    const toggleText = header.querySelector('.person-toggle span:first-child');
    
    if (expand) {
      content.classList.add('expanded');
      header.classList.remove('collapsed');
      toggleIcon.classList.add('expanded');
      toggleText.textContent = 'Verbergen';
    } else {
      content.classList.remove('expanded');
      header.classList.add('collapsed');
      toggleIcon.classList.remove('expanded');
      toggleText.textContent = 'Anzeigen';
    }
  });
}

window.toggleAllPersonAccordions = toggleAllPersonAccordions;

// ==================== ENDE PERSONEN-AKKORDEON ====================

// ==================== FIREBASE HELPERS ====================

// Entferne undefined Werte aus Objekt (Firebase erlaubt keine undefined Werte)
function removeUndefinedFields(obj) {
  const cleaned = {};
  for (const key in obj) {
    if (obj[key] !== undefined) {
      cleaned[key] = obj[key];
    }
  }
  return cleaned;
}

window.removeUndefinedFields = removeUndefinedFields;

// ==================== ENDE FIREBASE HELPERS ====================

// ==================== IMPORT PROGRESS ====================

function showImportProgress(current, total) {
  const overlay = document.getElementById('importProgressOverlay');
  if (overlay) {
    overlay.classList.add('active');
    updateImportProgress(0, current, total, 'Starte Import...');
  }
}

function updateImportProgress(percentage, current, total, message = '') {
  const progressBar = document.getElementById('importProgressBar');
  const progressText = document.getElementById('importProgressText');
  const progressDetails = document.getElementById('importProgressDetails');
  const progressSubtitle = document.getElementById('importProgressSubtitle');
  
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
  
  if (progressText) {
    progressText.textContent = percentage + '%';
  }
  
  if (progressDetails) {
    progressDetails.textContent = `${current} von ${total} Beobachtungen gespeichert`;
  }
  
  if (progressSubtitle && message) {
    progressSubtitle.textContent = message;
  }
}

function hideImportProgress() {
  const overlay = document.getElementById('importProgressOverlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
}

window.showImportProgress = showImportProgress;
window.updateImportProgress = updateImportProgress;
window.hideImportProgress = hideImportProgress;

// ==================== ENDE IMPORT PROGRESS ====================

// ==================== BILDKOMPRIMIERUNG ====================

// NEU: Komprimiere Bild vor dem Hochladen
async function compressImage(file, maxWidth = 1920, maxHeight = 1080, quality = 0.85) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      const img = new Image();
      
      img.onload = function() {
        // Berechne neue Dimensionen
        let width = img.width;
        let height = img.height;
        
        // Skaliere runter wenn zu groß
        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;
          
          if (width > height) {
            width = maxWidth;
            height = width / aspectRatio;
          } else {
            height = maxHeight;
            width = height * aspectRatio;
          }
        }
        
        // Erstelle Canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        
        // Zeichne Bild auf Canvas
        ctx.drawImage(img, 0, 0, width, height);
        
        // Konvertiere zu Base64 mit Kompression
        const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
        
        // Prüfe Größe
        const sizeInBytes = compressedBase64.length;
        const sizeInMB = sizeInBytes / (1024 * 1024);
        
        console.log(`📸 Bild komprimiert: ${(img.width)}x${(img.height)} → ${Math.round(width)}x${Math.round(height)}, ${sizeInMB.toFixed(2)} MB`);
        
        // Wenn immer noch zu groß, reduziere weiter
        if (sizeInMB > 9) {
          console.log('⚠️ Bild immer noch zu groß, reduziere Qualität weiter...');
          const reducedQuality = canvas.toDataURL('image/jpeg', 0.6);
          const reducedSize = reducedQuality.length / (1024 * 1024);
          
          if (reducedSize > 9) {
            // Noch kleiner machen
            const verySmall = canvas.toDataURL('image/jpeg', 0.4);
            resolve(verySmall);
          } else {
            resolve(reducedQuality);
          }
        } else {
          resolve(compressedBase64);
        }
      };
      
      img.onerror = function() {
        reject(new Error('Fehler beim Laden des Bildes'));
      };
      
      img.src = e.target.result;
    };
    
    reader.onerror = function() {
      reject(new Error('Fehler beim Lesen der Datei'));
    };
    
    reader.readAsDataURL(file);
  });
}

window.compressImage = compressImage;

// ==================== ENDE BILDKOMPRIMIERUNG ====================

// ==================== BEOBACHTUNG BEARBEITEN ====================

// Öffne Bearbeitungs-Modal
async function openEditModal(observationId) {
  try {
    // Lade Beobachtung
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    let obs;
    
    if (isGroupMode) {
      // Gruppenmodus
      if (!window.FBA || !window.FBD) {
        showNotification('❌ Firebase nicht verfügbar', 3000);
        return;
      }
      
      const groupId = window.currentSelectedGroup;
      const obsSnapshot = await window.FBD.ref(`groups/${groupId}/observations/${observationId}`).once('value');
      
      if (!obsSnapshot.exists()) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
      
      obs = { id: observationId, ...obsSnapshot.val() };
    } else {
      // Lokaler Modus
      obs = await getFromIndexedDB('observations', observationId);
      
      if (!obs) {
        showNotification('❌ Beobachtung nicht gefunden', 3000);
        return;
      }
    }
    
    // Fülle Formular
    document.getElementById('editObsId').value = observationId;
    document.getElementById('editBird').value = obs.bird || '';
    document.getElementById('editDate').value = obs.date || '';
    // NEU: Zeit ohne Sekunden (nur HH:MM)
    const timeValue = obs.time || '';
    document.getElementById('editTime').value = timeValue.substring(0, 5); // Nur HH:MM, keine Sekunden
    document.getElementById('editCount').value = obs.count || '';
    document.getElementById('editBehavior').value = obs.behavior || '';
    document.getElementById('editWeather').value = obs.weather || '';
    document.getElementById('editLat').value = obs.lat || '';
    document.getElementById('editLng').value = obs.lng || '';
    document.getElementById('editNotes').value = obs.notes || '';
    document.getElementById('editTickable').checked = obs.tickable !== false;
    document.getElementById('editSelffound').checked = obs.selffound || false;
    
    // Seltenheit
    const rarityValue = obs.rarity === 'selten' ? 1 : obs.rarity === 'sehr selten' ? 2 : obs.rarity === 'escape' ? 3 : 0;
    document.getElementById('editRarity').value = rarityValue;
    updateEditRarityLabel(rarityValue);
    
    // Ordner-Dropdown füllen
    await populateEditFolderDropdown(obs.folderId);
    
    // Foto
    if (obs.photo) {
      document.getElementById('editPhotoImg').src = obs.photo;
      document.getElementById('editPhotoPreview').style.display = 'block';
      document.getElementById('editPhotoActions').style.display = 'flex';
    } else {
      document.getElementById('editPhotoPreview').style.display = 'none';
      document.getElementById('editPhotoActions').style.display = 'none';
    }
    
    // Fülle Vogel-Datalist
    const datalist = document.getElementById('birdSpeciesListEdit');
    datalist.innerHTML = '';
    Object.keys(birdDatabase).forEach(bird => {
      const option = document.createElement('option');
      option.value = bird;
      datalist.appendChild(option);
    });
    
    // Zeige Modal
    document.getElementById('editModal').classList.add('active');
    
  } catch (error) {
    console.error('Fehler beim Öffnen des Bearbeitungs-Modals:', error);
    showNotification('❌ Fehler: ' + error.message, 3000);
  }
}

// Ordner-Dropdown für Bearbeitung füllen
async function populateEditFolderDropdown(currentFolderId) {
  const select = document.getElementById('editFolder');
  select.innerHTML = '<option value="">Kein Ordner</option>';
  
  try {
    const folders = await getAllFromIndexedDB('folders');
    folders.forEach(folder => {
      const option = document.createElement('option');
      option.value = folder.id;
      option.textContent = folder.name;
      if (folder.id === currentFolderId) {
        option.selected = true;
      }
      select.appendChild(option);
    });
  } catch (error) {
    console.error('Fehler beim Laden der Ordner:', error);
  }
}

// Schließe Bearbeitungs-Modal
function closeEditModal() {
  document.getElementById('editModal').classList.remove('active');
  document.getElementById('editObservationForm').reset();
  document.getElementById('editPhotoPreview').style.display = 'none';
  document.getElementById('editPhotoActions').style.display = 'none';
}

// Handle Foto-Upload in Bearbeitung
async function handleEditPhotoUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    showNotification('📸 Komprimiere Bild...', 2000);
    
    // Komprimiere Bild
    const compressedBase64 = await compressImage(file);
    
    // Zeige Vorschau
    document.getElementById('editPhotoImg').src = compressedBase64;
    document.getElementById('editPhotoPreview').style.display = 'block';
    document.getElementById('editPhotoActions').style.display = 'flex';
    
    // Speichere komprimiertes Bild im Input (als Data-Attribut)
    document.getElementById('editPhotoInput').dataset.compressedPhoto = compressedBase64;
    
    showNotification('✅ Bild komprimiert und bereit', 2000);
  } catch (error) {
    console.error('Fehler beim Komprimieren des Bildes:', error);
    showNotification('❌ Fehler beim Verarbeiten des Bildes', 3000);
  }
}

// Entferne Foto in Bearbeitung
function removeEditPhoto() {
  const photoInput = document.getElementById('editPhotoInput');
  photoInput.value = '';
  delete photoInput.dataset.compressedPhoto; // NEU: Entferne komprimierte Daten
  document.getElementById('editPhotoImg').src = '';
  document.getElementById('editPhotoPreview').style.display = 'none';
  document.getElementById('editPhotoActions').style.display = 'none';
}

// Update Seltenheits-Label in Bearbeitung
function updateEditRarityLabel(value) {
  const labels = ['Standard (aus Datenbank)', '⭐ Selten', '💎 Sehr selten', '🦜 Escape'];
  document.getElementById('editRarityLabel').textContent = labels[value] || labels[0];
}

// Speichere bearbeitete Beobachtung
async function saveEditedObservation(event) {
  event.preventDefault();
  
  try {
    const observationId = document.getElementById('editObsId').value;
    const isGroupMode = window.currentSelectedGroup && window.currentSelectedGroup !== 'personal';
    
    // Hole aktuelle Beobachtung
    let existingObs;
    if (isGroupMode) {
      const groupId = window.currentSelectedGroup;
      const obsSnapshot = await window.FBD.ref(`groups/${groupId}/observations/${observationId}`).once('value');
      existingObs = obsSnapshot.val();
    } else {
      existingObs = await getFromIndexedDB('observations', observationId);
    }
    
    if (!existingObs) {
      showNotification('❌ Beobachtung nicht gefunden', 3000);
      return;
    }
    
    // Sammle Formulardaten
    const bird = document.getElementById('editBird').value;
    const date = document.getElementById('editDate').value;
    const time = document.getElementById('editTime').value;
    const count = document.getElementById('editCount').value;
    const behavior = document.getElementById('editBehavior').value;
    const weather = document.getElementById('editWeather').value;
    const lat = document.getElementById('editLat').value;
    const lng = document.getElementById('editLng').value;
    const notes = document.getElementById('editNotes').value;
    const tickable = document.getElementById('editTickable').checked;
    const selffound = document.getElementById('editSelffound').checked;
    const folderId = document.getElementById('editFolder').value;
    
    // Seltenheit
    const rarityValue = parseInt(document.getElementById('editRarity').value);
    const rarityMap = ['', 'selten', 'sehr selten', 'escape'];
    const rarity = rarityMap[rarityValue] || '';
    
    // Foto
    let photo = existingObs.photo || '';
    const photoInput = document.getElementById('editPhotoInput');
    
    // Prüfe ob ein komprimiertes Foto vorhanden ist
    if (photoInput.dataset.compressedPhoto) {
      photo = photoInput.dataset.compressedPhoto;
    } else if (photoInput.files && photoInput.files[0]) {
      // Falls nicht komprimiert, komprimiere jetzt
      showNotification('📸 Komprimiere Bild...', 2000);
      photo = await compressImage(photoInput.files[0]);
    } else if (document.getElementById('editPhotoPreview').style.display === 'none') {
      photo = ''; // Foto wurde entfernt
    }
    
    // NEU: Validiere Foto-Größe
    if (photo && photo.length > 0) {
      const sizeInMB = photo.length / (1024 * 1024);
      if (sizeInMB > 9) {
        showNotification('⚠️ Foto ist zu groß (' + sizeInMB.toFixed(1) + ' MB)! Maximal 9 MB erlaubt.', 5000);
        return;
      }
      console.log('📸 Foto-Größe OK: ' + sizeInMB.toFixed(2) + ' MB');
    }
    
    // Hole Ordner-Infos
    let folderName = '';
    let folderColor = '#06b6d4';
    if (folderId) {
      const folder = await getFromIndexedDB('folders', folderId);
      if (folder) {
        folderName = folder.name;
        folderColor = folder.color || '#06b6d4';
      }
    }
    
    // Update Beobachtung
    const updatedObs = {
      ...existingObs,
      bird,
      date,
      time,
      count: count ? parseInt(count) : undefined,
      behavior,
      weather,
      lat: lat ? parseFloat(lat) : undefined,
      lng: lng ? parseFloat(lng) : undefined,
      notes,
      tickable,
      selffound,
      rarity: rarity || undefined,
      folderId: folderId || undefined,
      folderName,
      folderColor,
      photo,
      updatedAt: new Date().toISOString()
    };
    
    // Speichern
    if (isGroupMode) {
      // NEU: Entferne undefined Werte für Firebase
      const cleanedObs = removeUndefinedFields(updatedObs);
      const groupId = window.currentSelectedGroup;
      await window.FBD.ref(`groups/${groupId}/observations/${observationId}`).update(cleanedObs);
    } else {
      await saveToIndexedDB('observations', updatedObs);
    }
    
    showNotification('✅ Beobachtung erfolgreich aktualisiert!', 2000);
    closeEditModal();
    
    // Aktualisiere Ansichten
    await renderObservationManager();
    updateDashboard();
    updateChart();
    updateAdvancedStatistics();
    if (window.mapObj && typeof updateMarkersFromData === 'function') {
      await updateMarkersFromData();
    }
    
  } catch (error) {
    console.error('Fehler beim Speichern der Beobachtung:', error);
    showNotification('❌ Fehler beim Speichern: ' + error.message, 3000);
  }
}

window.openEditModal = openEditModal;
window.closeEditModal = closeEditModal;
window.handleEditPhotoUpload = handleEditPhotoUpload;
window.removeEditPhoto = removeEditPhoto;
window.updateEditRarityLabel = updateEditRarityLabel;
window.saveEditedObservation = saveEditedObservation;

// Event Listener für Modal-Schließung
document.addEventListener('DOMContentLoaded', function() {
  // Schließe Modal bei Klick außerhalb
  const editModal = document.getElementById('editModal');
  if (editModal) {
    editModal.addEventListener('click', function(e) {
      if (e.target === editModal) {
        closeEditModal();
      }
    });
  }
  
  // Schließe Modal bei Escape-Taste
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      const editModal = document.getElementById('editModal');
      if (editModal && editModal.classList.contains('active')) {
        closeEditModal();
      }
    }
  });
  
  // Drag & Drop für Foto-Upload
  const photoInput = document.getElementById('editPhotoInput');
  if (photoInput) {
    const dropZone = photoInput.parentElement;
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, function() {
        dropZone.style.background = 'rgba(6,182,212,0.1)';
        dropZone.style.borderColor = 'var(--accent)';
      }, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, function() {
        dropZone.style.background = '';
        dropZone.style.borderColor = '';
      }, false);
    });
    
    dropZone.addEventListener('drop', function(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (files.length > 0) {
        photoInput.files = files;
        handleEditPhotoUpload({ target: photoInput });
      }
    }, false);
  }
});

// ==================== ENDE BEOBACHTUNG BEARBEITEN ====================

// ==================== ENDE BEOBACHTUNGEN MANAGER ====================

window.toggleTickable = toggleTickable;
window.toggleSelffound = toggleSelffound;
window.updateToggleButtonVisuals = updateToggleButtonVisuals;
window.updateObsRarityLabel = updateObsRarityLabel;
window.saveObservationRarity = saveObservationRarity;
window.openQuickRarityEditor = openQuickRarityEditor;
window.updateQuickRarityLabel = updateQuickRarityLabel;
window.saveQuickRarity = saveQuickRarity;
window.updateSystemInfo = updateSystemInfo;

// ==================== MOBILE MENU FUNCTIONS ====================
function toggleMobileMenu() {
  console.log('🍔 toggleMobileMenu aufgerufen');
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.getElementById('mobileOverlay');
  const menuBtn = document.getElementById('mobileMenuBtn');
  
  console.log('Sidebar Element:', sidebar);
  console.log('Overlay Element:', overlay);
  console.log('Menu Button:', menuBtn);
  
  if (sidebar && overlay && menuBtn) {
    const wasVisible = sidebar.classList.contains('mobile-visible');
    console.log('War sichtbar:', wasVisible);
    
    sidebar.classList.toggle('mobile-visible');
    overlay.classList.toggle('active');
    document.body.classList.toggle('sidebar-open');
    menuBtn.classList.toggle('menu-open'); // NEU: Klasse auf Button selbst
    
    // Update Button Aria-Label
    if (sidebar.classList.contains('mobile-visible')) {
      menuBtn.setAttribute('aria-label', 'Menü schließen');
      menuBtn.setAttribute('aria-expanded', 'true');
    } else {
      menuBtn.setAttribute('aria-label', 'Menü öffnen');
      menuBtn.setAttribute('aria-expanded', 'false');
    }
    
    console.log('Ist jetzt sichtbar:', sidebar.classList.contains('mobile-visible'));
    console.log('Overlay aktiv:', overlay.classList.contains('active'));
    console.log('Button menu-open:', menuBtn.classList.contains('menu-open'));
    
    // Verhindere Scrollen wenn Menü offen ist
    if (sidebar.classList.contains('mobile-visible')) {
      document.body.style.overflow = 'hidden';
      console.log('Menü geöffnet - Scrollen verhindert');
    } else {
      document.body.style.overflow = '';
      console.log('Menü geschlossen - Scrollen erlaubt');
    }
  } else {
    console.error('❌ Sidebar, Overlay oder Button nicht gefunden!');
  }
}

function closeMobileMenu() {
  console.log('❌ closeMobileMenu aufgerufen');
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.getElementById('mobileOverlay');
  const menuBtn = document.getElementById('mobileMenuBtn');
  
  if (sidebar && overlay && menuBtn) {
    sidebar.classList.remove('mobile-visible');
    overlay.classList.remove('active');
    document.body.classList.remove('sidebar-open');
    menuBtn.classList.remove('menu-open'); // NEU: Klasse entfernen
    document.body.style.overflow = '';
    
    // Update Button Aria-Label
    menuBtn.setAttribute('aria-label', 'Menü öffnen');
    menuBtn.setAttribute('aria-expanded', 'false');
    
    console.log('✅ Menü geschlossen');
  } else {
    console.error('❌ Sidebar, Overlay oder Button nicht gefunden beim Schließen!');
  }
}

// NEU: Stelle sicher, dass auf Mobile die richtige Ansicht beim Laden angezeigt wird
function initMobileView() {
  if (window.innerWidth <= 700) {
    // Entferne map-full Klasse beim Laden
    document.documentElement.classList.remove('map-full');
    
    // WICHTIG: Stelle sicher, dass Sidebar geschlossen ist
    const sidebar = document.querySelector('.sidebar');
    const overlay = document.getElementById('mobileOverlay');
    if (sidebar) {
      sidebar.classList.remove('mobile-visible');
    }
    if (overlay) {
      overlay.classList.remove('active');
    }
    document.body.classList.remove('sidebar-open');
    document.body.style.overflow = '';
    
    // Stelle sicher, dass home-Section sichtbar ist
    const homeSection = document.getElementById('home');
    if (homeSection) {
      homeSection.style.display = 'block';
    }
    
    // Verstecke alle anderen Sections
    document.querySelectorAll('main section').forEach(section => {
      if (section.id !== 'home') {
        section.style.display = 'none';
      }
    });
    
    // Setze Home-Button als aktiv
    document.querySelectorAll('.nav button').forEach(btn => {
      if (btn.getAttribute('data-page') === 'home') {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }
}

// Schließe Menü bei Navigation
document.addEventListener('DOMContentLoaded', function() {
  console.log('📱 Mobile Menu wird initialisiert...');
  
  // NEU: Initialisiere Mobile-Ansicht
  initMobileView();
  
  const navButtons = document.querySelectorAll('.nav button');
  navButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      console.log('Nav-Button geklickt - Schließe Menü');
      closeMobileMenu();
    });
  });
  
  // NEU: Schließe Sidebar beim Resize auf Desktop
  window.addEventListener('resize', function() {
    if (window.innerWidth > 700) {
      console.log('Resize zu Desktop - Schließe Menü');
      closeMobileMenu();
    }
  });
  
  // NEU: Stelle sicher, dass Overlay funktioniert - mit mehreren Methoden
  const overlay = document.getElementById('mobileOverlay');
  if (overlay) {
    console.log('✅ Overlay gefunden, füge Event-Listener hinzu');
    
    // Methode 1: Click Event
    overlay.addEventListener('click', function(e) {
      console.log('🖱️ Overlay geklickt (addEventListener)');
      e.preventDefault();
      e.stopPropagation();
      closeMobileMenu();
    });
    
    // Methode 2: Touch Event für Mobile
    overlay.addEventListener('touchstart', function(e) {
      console.log('👆 Overlay touched');
      e.preventDefault();
      closeMobileMenu();
    }, { passive: false });
  } else {
    console.error('❌ Overlay nicht gefunden!');
  }
  
  // Debug: Log Sidebar-Status
  const sidebar = document.querySelector('.sidebar');
  if (sidebar) {
    console.log('✅ Sidebar gefunden');
    console.log('   Klassen:', sidebar.className);
    
    // NEU: Swipe-Geste zum Schließen
    let touchStartX = 0;
    let touchEndX = 0;
    
    sidebar.addEventListener('touchstart', function(e) {
      touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });
    
    sidebar.addEventListener('touchend', function(e) {
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
    }, { passive: true });
    
    function handleSwipe() {
      const swipeDistance = touchEndX - touchStartX;
      // Wenn nach links gewischt (mindestens 50px), schließe Sidebar
      if (swipeDistance < -50 && sidebar.classList.contains('mobile-visible')) {
        console.log('👈 Nach links gewischt - Schließe Menü');
        closeMobileMenu();
      }
    }
  } else {
    console.error('❌ Sidebar nicht gefunden!');
  }
});

window.toggleMobileMenu = toggleMobileMenu;
window.closeMobileMenu = closeMobileMenu;
window.initMobileView = initMobileView;
// ==================== ENDE MOBILE MENU ====================



if(document.readyState==="loading"){
  document.addEventListener("DOMContentLoaded",init)
}else{
  setTimeout(init,100)
}
})();
</script>
<!-- ============================================================== -->

<!-- Bearbeitungs-Modal -->
<div id="editModal" class="edit-modal">
  <div class="edit-modal-content">
    <div class="edit-modal-header">
      <h2>
        <span>✏️</span>
        <span>Beobachtung bearbeiten</span>
      </h2>
      <button class="edit-modal-close" onclick="closeEditModal()">×</button>
    </div>
    
    <div class="edit-modal-body">
      <form id="editObservationForm" onsubmit="saveEditedObservation(event)">
        <input type="hidden" id="editObsId">
        
        <div class="edit-form-group">
          <label class="edit-form-label">🐦 Vogelart</label>
          <input type="text" id="editBird" class="edit-form-input" list="birdSpeciesListEdit" required>
          <datalist id="birdSpeciesListEdit"></datalist>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div class="edit-form-group">
            <label class="edit-form-label">📅 Datum</label>
            <input type="date" id="editDate" class="edit-form-input" required>
          </div>
          
          <div class="edit-form-group">
            <label class="edit-form-label">🕒 Uhrzeit</label>
            <input type="time" id="editTime" class="edit-form-input">
          </div>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div class="edit-form-group">
            <label class="edit-form-label">🔢 Anzahl</label>
            <input type="number" id="editCount" class="edit-form-input" min="1">
          </div>
          
          <div class="edit-form-group">
            <label class="edit-form-label">📍 Ordner</label>
            <select id="editFolder" class="edit-form-input">
              <!-- Wird dynamisch gefüllt -->
            </select>
          </div>
        </div>
        
        <div class="edit-form-group">
          <label class="edit-form-label">🎭 Verhalten</label>
          <input type="text" id="editBehavior" class="edit-form-input" placeholder="z.B. singend, jagend, rastend...">
        </div>
        
        <div class="edit-form-group">
          <label class="edit-form-label">🌤️ Wetter</label>
          <input type="text" id="editWeather" class="edit-form-input" placeholder="z.B. sonnig, bewölkt...">
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div class="edit-form-group">
            <label class="edit-form-label">🌍 Breitengrad</label>
            <input type="number" id="editLat" class="edit-form-input" step="0.000001">
          </div>
          
          <div class="edit-form-group">
            <label class="edit-form-label">🌍 Längengrad</label>
            <input type="number" id="editLng" class="edit-form-input" step="0.000001">
          </div>
        </div>
        
        <div class="edit-form-group">
          <label class="edit-form-label">⭐ Seltenheit</label>
          <input type="range" id="editRarity" min="0" max="3" value="0" step="1" 
                 style="width:100%; accent-color:var(--accent);" 
                 oninput="updateEditRarityLabel(this.value)">
          <div style="display:flex; justify-content:space-between; font-size:11px; color:var(--muted); margin-top:4px;">
            <span>Häufig</span>
            <span>Selten</span>
            <span>Sehr selten</span>
            <span>Escape</span>
          </div>
          <div id="editRarityLabel" style="text-align:center; font-size:13px; color:var(--text); font-weight:600; margin-top:8px;">
            Standard (aus Datenbank)
          </div>
        </div>
        
        <div class="edit-form-group">
          <label class="edit-form-label">📸 Foto</label>
          <input type="file" id="editPhotoInput" class="edit-form-input" accept="image/*" onchange="handleEditPhotoUpload(event)">
          <div style="font-size:11px;color:var(--muted);margin-top:4px;">
            ℹ️ Bilder werden automatisch komprimiert (max. 1920x1080px, JPEG)
          </div>
          <div id="editPhotoPreview" class="edit-photo-preview" style="display:none;">
            <img id="editPhotoImg" src="" alt="Foto-Vorschau">
          </div>
          <div class="edit-photo-actions" id="editPhotoActions" style="display:none;">
            <button type="button" class="small-btn" onclick="removeEditPhoto()" style="background:var(--danger);">
              🗑️ Foto entfernen
            </button>
          </div>
        </div>
        
        <div class="edit-form-group">
          <label class="edit-form-label">📝 Notizen</label>
          <textarea id="editNotes" class="edit-form-input" rows="3" placeholder="Zusätzliche Notizen..."></textarea>
        </div>
        
        <div class="edit-form-group">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="editTickable" style="width:18px;height:18px;accent-color:var(--success);">
            <span style="font-size:14px;color:var(--text);">✓ Tickbar</span>
          </label>
        </div>
        
        <div class="edit-form-group">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="editSelffound" style="width:18px;height:18px;accent-color:var(--danger);">
            <span style="font-size:14px;color:var(--text);">🔴 Selffound</span>
          </label>
        </div>
      </form>
    </div>
    
    <div class="edit-modal-footer">
      <button type="button" class="btn ghost" onclick="closeEditModal()">Abbrechen</button>
      <button type="submit" form="editObservationForm" class="btn">💾 Speichern</button>
    </div>
<!-- Import Progress Overlay -->
<div id="importProgressOverlay" class="import-progress-overlay">
  <div class="import-progress-content">
    <div class="import-progress-title">
      <div class="import-spinner"></div>
      <span>Importiere Beobachtungen</span>
    </div>
    <div class="import-progress-subtitle" id="importProgressSubtitle">
      Bitte warten Sie, während die Beobachtungen gespeichert werden...
    </div>
    <div class="import-progress-bar-container">
      <div class="import-progress-bar" id="importProgressBar"></div>
    </div>
    <div class="import-progress-text" id="importProgressText">0%</div>
    <div class="import-progress-details" id="importProgressDetails">
      0 von 0 Beobachtungen gespeichert
    </div>
  </div>
</div>

<!-- NEU: Mobile Welcome Popup -->
<div id="mobileWelcome" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:10000; align-items:center; justify-content:center; padding:20px;">
  <div style="background:var(--card); border-radius:16px; padding:24px; max-width:400px; width:100%; box-shadow:0 20px 60px rgba(0,0,0,0.8); border:1px solid rgba(6,182,212,0.3);">
    <div style="text-align:center; margin-bottom:20px;">
      <div style="font-size:48px; margin-bottom:12px;">📱</div>
      <h2 style="margin:0 0 8px 0; font-size:22px; color:var(--text);">BirdCount auf dem Handy</h2>
      <p style="color:var(--muted); font-size:14px; margin:0;">Installiere BirdCount als App!</p>
    </div>
    
    <div style="background:rgba(6,182,212,0.1); border-radius:12px; padding:16px; margin-bottom:20px;">
      <div style="font-size:14px; line-height:1.6; color:var(--text);">
        <div style="margin-bottom:12px;">
          <strong style="color:var(--accent);">🍎 iPhone/iPad:</strong><br>
          <span style="font-size:13px;">Safari → Teilen-Symbol → "Zum Home-Bildschirm"</span>
        </div>
        <div>
          <strong style="color:var(--accent);">🤖 Android:</strong><br>
          <span style="font-size:13px;">Chrome → Menü (⋮) → "App installieren"</span>
        </div>
      </div>
    </div>
    
    <div style="display:grid; grid-template-columns:repeat(2, 1fr); gap:12px; margin-bottom:12px;">
      <div style="text-align:center; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px;">
        <div style="font-size:24px; margin-bottom:4px;">📍</div>
        <div style="font-size:11px; color:var(--muted);">GPS-Standort</div>
      </div>
      <div style="text-align:center; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px;">
        <div style="font-size:24px; margin-bottom:4px;">📸</div>
        <div style="font-size:11px; color:var(--muted);">Kamera nutzen</div>
      </div>
      <div style="text-align:center; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px;">
        <div style="font-size:24px; margin-bottom:4px;">🌐</div>
        <div style="font-size:11px; color:var(--muted);">Offline-Modus</div>
      </div>
      <div style="text-align:center; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px;">
        <div style="font-size:24px; margin-bottom:4px;">☰</div>
        <div style="font-size:11px; color:var(--muted);">Touch-Menü</div>
      </div>
    </div>
    
    <button onclick="closeMobileWelcome()" style="width:100%; background:linear-gradient(135deg, var(--accent), var(--accent-2)); color:white; border:none; padding:14px; border-radius:10px; font-size:16px; font-weight:600; cursor:pointer;">
      Los geht's! 🚀
    </button>
    
    <div style="text-align:center; margin-top:12px;">
      <label style="display:flex; align-items:center; justify-content:center; gap:8px; font-size:13px; color:var(--muted); cursor:pointer;">
        <input type="checkbox" id="dontShowAgain" style="width:16px; height:16px;">
        <span>Nicht mehr anzeigen</span>
      </label>
    </div>
  </div>
</div>

<script>
// Mobile Welcome Screen
function closeMobileWelcome() {
  const popup = document.getElementById('mobileWelcome');
  const dontShow = document.getElementById('dontShowAgain');
  
  if (popup) {
    popup.style.display = 'none';
    
    if (dontShow && dontShow.checked) {
      localStorage.setItem('birdcount_mobile_welcome_shown', 'true');
    }
  }
}

// Zeige Welcome Screen beim ersten Besuch auf Mobile
if (window.innerWidth <= 700 && !localStorage.getItem('birdcount_mobile_welcome_shown')) {
  setTimeout(() => {
    const popup = document.getElementById('mobileWelcome');
    if (popup) {
      popup.style.display = 'flex';
    }
  }, 1000);
}

// ==================== SCHNELLEINGABE (QUICK ADD) ====================

function openQuickAdd() {
  const modal = document.getElementById('quickAddModal');
  const birdInput = document.getElementById('quickAddBird');
  const dateInput = document.getElementById('quickAddDate');
  const countInput = document.getElementById('quickAddCount');
  const noteInput = document.getElementById('quickAddNote');
  
  // Setze heutiges Datum
  dateInput.value = new Date().toISOString().split('T')[0];
  
  // Setze Anzahl auf 1
  countInput.value = 1;
  
  // Leere Felder
  birdInput.value = '';
  noteInput.value = '';
  
  // Lade Vogelnamen für Autocomplete
  populateQuickBirdSuggestions();
  
  // Zeige Modal mit Animation
  modal.style.display = 'flex';
  
  // Focus auf Vogelart-Feld
  setTimeout(() => birdInput.focus(), 100);
}

function closeQuickAdd() {
  const modal = document.getElementById('quickAddModal');
  modal.style.display = 'none';
}

function populateQuickBirdSuggestions() {
  const datalist = document.getElementById('quickBirdSuggestions');
  datalist.innerHTML = '';
  
  // Hole alle verfügbaren Vogelnamen aus der Datenbank
  const birdNames = Object.keys(birdDatabase || {}).sort();
  
  birdNames.forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    datalist.appendChild(option);
  });
}

async function saveQuickAdd() {
  const bird = document.getElementById('quickAddBird').value.trim();
  const date = document.getElementById('quickAddDate').value;
  const count = document.getElementById('quickAddCount').value;
  const note = document.getElementById('quickAddNote').value.trim();
  
  // Validierung
  if (!bird) {
    showToast('Bitte gib eine Vogelart ein!', 'error');
    document.getElementById('quickAddBird').focus();
    return;
  }
  
  if (!date) {
    showToast('Bitte wähle ein Datum!', 'error');
    document.getElementById('quickAddDate').focus();
    return;
  }
  
  // Zeige Loading
  showToast('Speichere Beobachtung...', 'info');
  
  try {
    // Hole aktuellen Standort (falls verfügbar)
    let lat = null;
    let lng = null;
    
    if (navigator.geolocation) {
      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            timeout: 3000,
            maximumAge: 60000
          });
        });
        lat = position.coords.latitude;
        lng = position.coords.longitude;
      } catch (err) {
        console.log('Standort nicht verfügbar:', err);
      }
    }
    
    // Erstelle Beobachtung
    const observation = {
      id: 'obs_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      bird: bird,
      date: date,
      count: parseInt(count) || 1,
      behavior: note || '',
      lat: lat,
      lng: lng,
      timestamp: new Date().toISOString(),
      tickable: true,
      selffound: false
    };
    
    // Speichere in Firebase
    if (window.FBA && window.FBD && currentUser) {
      const folderSelect = document.getElementById('folderSelect');
      const currentFolder = folderSelect ? folderSelect.value : null;
      
      if (isGroupMode && currentGroupId) {
        // Gruppen-Modus
        const userEmailKey = currentUser.email.replace(/\./g, '_');
        await window.FBD.ref(`groups/${currentGroupId}/observations/${userEmailKey}`).push(observation);
      } else if (currentFolder) {
        // Mit Ordner
        await window.FBD.ref(`observations/${currentUser.uid}/${currentFolder}`).push(observation);
      } else {
        // Standard
        await window.FBD.ref(`observations/${currentUser.uid}`).push(observation);
      }
      
      // Erfolgsmeldung
      showToast(`✅ ${bird} erfolgreich gespeichert!`, 'success');
      
      // Schließe Modal
      closeQuickAdd();
      
      // Aktualisiere Ansicht
      if (typeof loadObservations === 'function') {
        loadObservations();
      }
      
      // Aktualisiere Karte falls sichtbar
      if (lat && lng && typeof addMarkerAtCoords === 'function') {
        setTimeout(() => {
          addMarkerAtCoords(lat, lng, bird, date, count);
        }, 500);
      }
      
    } else {
      showToast('Nicht angemeldet! Bitte melde dich an.', 'error');
    }
    
  } catch (error) {
    console.error('Fehler beim Speichern:', error);
    showToast('Fehler beim Speichern! Bitte versuche es erneut.', 'error');
  }
}

// Toast-Benachrichtigungen
function showToast(message, type = 'info') {
  // Entferne alte Toasts
  const oldToasts = document.querySelectorAll('.toast');
  oldToasts.forEach(toast => toast.remove());
  
  // Erstelle neuen Toast
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  
  // Füge Icons hinzu
  const icons = {
    success: '✅ ',
    error: '❌ ',
    info: 'ℹ️ '
  };
  toast.textContent = (icons[type] || '') + message;
  
  document.body.appendChild(toast);
  
  // Entferne nach 3 Sekunden
  setTimeout(() => {
    toast.style.animation = 'fadeOut 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Keyboard Shortcut: Strg+Q für Quick Add
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'q') {
    e.preventDefault();
    openQuickAdd();
  }
  
  // ESC um Quick Add zu schließen
  if (e.key === 'Escape') {
    const quickAddModal = document.getElementById('quickAddModal');
    if (quickAddModal && quickAddModal.style.display === 'flex') {
      closeQuickAdd();
    }
  }
});

// Enter-Taste im Quick Add Modal
document.addEventListener('DOMContentLoaded', () => {
  const quickAddModal = document.getElementById('quickAddModal');
  if (quickAddModal) {
    quickAddModal.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveQuickAdd();
      }
    });
  }
});

// Fadeout Animation für Toast
const style = document.createElement('style');
style.textContent = `
  @keyframes fadeOut {
    from { opacity: 1; transform: translateX(0); }
    to { opacity: 0; transform: translateX(100px); }
  }
`;
document.head.appendChild(style);

// === NEUE FEATURES: JavaScript === //

// Tutorial Manager
const TutorialManager = {
  currentStep: 0,
  steps: [
    {
      title: "Willkommen bei BirdCount! 🦅",
      text: "Herzlich willkommen! BirdCount ist dein professioneller Begleiter für Vogelbeobachtungen. Lass uns gemeinsam die wichtigsten Funktionen erkunden.",
      image: "🎉"
    },
    {
      title: "Schnelleingabe ⚡",
      text: "Mit dem blau leuchtenden Button unten rechts (oder Strg+Q) kannst du blitzschnell neue Beobachtungen erfassen. Der Standort wird automatisch erfasst!",
      image: "⚡",
      highlight: ".fab-quick-add"
    },
    {
      title: "Erweiterte Statistiken 📊",
      text: "Der neue Statistiken+ Button zeigt dir detaillierte Analysen: Jahresvergleiche, Heatmaps nach Tageszeit und Monat, sowie deine persönlichen Meilensteine!",
      image: "📊",
      highlight: "#btnEnhancedStats"
    },
    {
      title: "Mehrfachbearbeitung 📦",
      text: "Wähle mehrere Beobachtungen aus (Checkboxen), um sie gleichzeitig zu bearbeiten: Datum ändern, Notizen hinzufügen, exportieren oder löschen!",
      image: "📦"
    },
    {
      title: "Karte & Navigation 🗺️",
      text: "Klicke auf die Karte, um Beobachtungen hinzuzufügen. Alle deine Sichtungen werden als Marker angezeigt. Nutze die Filter für bessere Übersicht!",
      image: "🗺️"
    },
    {
      title: "Bereit zum Start! 🚀",
      text: "Das war's! Du bist jetzt bereit, deine Vogelbeobachtungen professionell zu dokumentieren. Viel Erfolg und gute Beobachtungen!",
      image: "🚀"
    }
  ],
  
  init() {
    const tutorialSeen = localStorage.getItem('birdcount_tutorial_seen');
    if (!tutorialSeen) {
      setTimeout(() => this.start(), 2000);
    }
  },
  
  start() {
    this.currentStep = 0;
    this.showStep();
    document.getElementById('tutorialOverlay').style.display = 'flex';
  },
  
  showStep() {
    const step = this.steps[this.currentStep];
    document.getElementById('tutorialTitle').textContent = step.title;
    document.getElementById('tutorialText').textContent = step.text;
    document.getElementById('tutorialImage').textContent = step.image;
    document.getElementById('tutorialProgress').textContent = `${this.currentStep + 1} / ${this.steps.length}`;
    
    document.getElementById('tutorialPrev').style.display = this.currentStep > 0 ? 'inline-block' : 'none';
    document.getElementById('tutorialNext').textContent = this.currentStep < this.steps.length - 1 ? 'Weiter' : 'Fertig';
    
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    
    if (step.highlight) {
      const element = document.querySelector(step.highlight);
      if (element) {
        element.classList.add('tutorial-highlight');
        setTimeout(() => element.scrollIntoView({ behavior: 'smooth', block: 'center' }), 300);
      }
    }
  },
  
  next() {
    if (this.currentStep < this.steps.length - 1) {
      this.currentStep++;
      this.showStep();
    } else {
      this.complete();
    }
  },
  
  prev() {
    if (this.currentStep > 0) {
      this.currentStep--;
      this.showStep();
    }
  },
  
  skip() {
    this.complete();
  },
  
  complete() {
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    document.getElementById('tutorialOverlay').style.display = 'none';
    localStorage.setItem('birdcount_tutorial_seen', 'true');
    showToast('Tutorial abgeschlossen! Viel Erfolg! 🎉', 'success');
  }
};

// Tooltip Manager
const TooltipManager = {
  tooltips: {
    '.fab-quick-add': 'Schnelleingabe (Strg+Q): Füge blitzschnell eine neue Beobachtung hinzu',
    '#btnEnhancedStats': 'Erweiterte Statistiken: Jahresvergleiche, Heatmaps und Meilensteine',
    '#btnBulkEdit': 'Mehrfachbearbeitung: Bearbeite mehrere Beobachtungen gleichzeitig',
    '#exportBtn': 'Exportiere alle Beobachtungen als CSV',
    '#importBtn': 'Importiere Beobachtungen aus CSV',
  },
  
  container: null,
  
  init() {
    this.container = document.getElementById('tooltipContainer');
    setTimeout(() => this.attachListeners(), 500);
  },
  
  attachListeners() {
    Object.keys(this.tooltips).forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(element => {
        element.addEventListener('mouseenter', (e) => this.show(e, selector));
        element.addEventListener('mouseleave', () => this.hide());
      });
    });
  },
  
  show(event, selector) {
    if (!this.container) return;
    const text = this.tooltips[selector];
    if (!text) return;
    
    this.container.textContent = text;
    this.container.style.display = 'block';
    
    const rect = event.target.getBoundingClientRect();
    const tooltipRect = this.container.getBoundingClientRect();
    
    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
    let top = rect.top - tooltipRect.height - 10;
    
    if (left < 10) left = 10;
    if (left + tooltipRect.width > window.innerWidth - 10) {
      left = window.innerWidth - tooltipRect.width - 10;
    }
    if (top < 10) top = rect.bottom + 10;
    
    this.container.style.left = left + 'px';
    this.container.style.top = top + 'px';
  },
  
  hide() {
    if (this.container) {
      setTimeout(() => this.container.style.display = 'none', 200);
    }
  }
};

// Bulk Edit Manager
const BulkEditManager = {
  selectedObservations: new Set(),
  
  init() {
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('obs-checkbox')) {
        this.handleCheckbox(e.target);
      }
    });
  },
  
  handleCheckbox(checkbox) {
    const obsId = checkbox.dataset.obsId;
    const obsData = checkbox.dataset.obsData;
    
    if (checkbox.checked) {
      this.selectedObservations.set(obsId, JSON.parse(obsData));
    } else {
      this.selectedObservations.delete(obsId);
    }
    
    this.updateUI();
  },
  
  updateUI() {
    const count = this.selectedObservations.size;
    const bulkEditBtn = document.getElementById('btnBulkEdit');
    
    if (bulkEditBtn) {
      if (count > 0) {
        bulkEditBtn.textContent = `📦 Bulk-Edit (${count})`;
        bulkEditBtn.style.display = 'inline-block';
      } else {
        bulkEditBtn.style.display = 'none';
      }
    }
  },
  
  open() {
    if (this.selectedObservations.size === 0) {
      showToast('Bitte wähle zuerst Beobachtungen aus!', 'info');
      return;
    }
    
    document.getElementById('bulkSelectedCount').textContent = this.selectedObservations.size;
    this.renderSelectedList();
    document.getElementById('bulkEditModal').style.display = 'flex';
  },
  
  close() {
    document.getElementById('bulkEditModal').style.display = 'none';
  },
  
  renderSelectedList() {
    const container = document.getElementById('bulkSelectedList');
    container.innerHTML = '';
    
    this.selectedObservations.forEach((obs, id) => {
      const item = document.createElement('div');
      item.className = 'bulk-selected-item';
      item.innerHTML = `
        <div>
          <strong>${obs.bird || 'Unbekannt'}</strong><br>
          <small style="color: var(--muted);">${obs.date || 'Kein Datum'} - ${obs.count || 1}x</small>
        </div>
        <button onclick="BulkEditManager.removeFromSelection('${id}')" class="small-btn" style="background: var(--danger);">✕</button>
      `;
      container.appendChild(item);
    });
  },
  
  removeFromSelection(obsId) {
    this.selectedObservations.delete(obsId);
    const checkbox = document.querySelector(`input[data-obs-id="${obsId}"]`);
    if (checkbox) checkbox.checked = false;
    this.renderSelectedList();
    this.updateUI();
    if (this.selectedObservations.size === 0) this.close();
  },
  
  async changeDate() {
    const newDate = prompt('Neues Datum (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
    if (!newDate) return;
    
    showToast('Datum wird geändert...', 'info');
    
    for (let [id, obs] of this.selectedObservations) {
      obs.date = newDate;
      await this.updateObservation(id, obs);
    }
    
    showToast(`✅ Datum für ${this.selectedObservations.size} Beobachtungen geändert!`, 'success');
    this.close();
    this.clearSelection();
    loadObservations();
  },
  
  async changeLocation() {
    const newLat = prompt('Neue Breite (Latitude):');
    if (!newLat) return;
    const newLng = prompt('Neue Länge (Longitude):');
    if (!newLng) return;
    
    showToast('Standort wird geändert...', 'info');
    
    for (let [id, obs] of this.selectedObservations) {
      obs.lat = parseFloat(newLat);
      obs.lng = parseFloat(newLng);
      await this.updateObservation(id, obs);
    }
    
    showToast(`✅ Standort für ${this.selectedObservations.size} Beobachtungen geändert!`, 'success');
    this.close();
    this.clearSelection();
    loadObservations();
  },
  
  async addNote() {
    const note = prompt('Notiz hinzufügen:');
    if (!note) return;
    
    showToast('Notiz wird hinzugefügt...', 'info');
    
    for (let [id, obs] of this.selectedObservations) {
      obs.behavior = obs.behavior ? obs.behavior + ' | ' + note : note;
      await this.updateObservation(id, obs);
    }
    
    showToast(`✅ Notiz zu ${this.selectedObservations.size} Beobachtungen hinzugefügt!`, 'success');
    this.close();
    this.clearSelection();
    loadObservations();
  },
  
  async deleteSelected() {
    if (!confirm(`Möchtest du wirklich ${this.selectedObservations.size} Beobachtungen löschen?`)) return;
    
    showToast('Beobachtungen werden gelöscht...', 'info');
    
    for (let id of this.selectedObservations.keys()) {
      await this.deleteObservation(id);
    }
    
    showToast(`✅ ${this.selectedObservations.size} Beobachtungen gelöscht!`, 'success');
    this.close();
    this.clearSelection();
    loadObservations();
  },
  
  exportSelected() {
    let csv = 'Vogelart,Datum,Anzahl,Verhalten,Latitude,Longitude\n';
    this.selectedObservations.forEach(obs => {
      csv += `"${obs.bird || ''}","${obs.date || ''}",${obs.count || 1},"${obs.behavior || ''}",${obs.lat || ''},${obs.lng || ''}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `birdcount_bulk_export_${new Date().toISOString().split('T')[0]}.csv`;
    link.click();
    
    showToast('✅ Export erfolgreich!', 'success');
  },
  
  async moveToFolder() {
    const folderName = prompt('Ordnername:');
    if (!folderName) return;
    
    showToast('Beobachtungen werden verschoben...', 'info');
    
    for (let [id, obs] of this.selectedObservations) {
      await this.deleteObservation(id);
      await FBD.ref(`observations/${currentUser.uid}/${folderName}`).push(obs);
    }
    
    showToast(`✅ ${this.selectedObservations.size} Beobachtungen nach "${folderName}" verschoben!`, 'success');
    this.close();
    this.clearSelection();
    loadObservations();
  },
  
  clearSelection() {
    this.selectedObservations.clear();
    document.querySelectorAll('.obs-checkbox').forEach(cb => cb.checked = false);
    this.updateUI();
  },
  
  async updateObservation(id, data) {
    if (!FBD || !currentUser) return;
    const folderSelect = document.getElementById('folderSelect');
    const currentFolder = folderSelect ? folderSelect.value : null;
    const path = isGroupMode && currentGroupId
      ? `groups/${currentGroupId}/observations/${currentUser.email.replace(/\./g, '_')}/${id}`
      : currentFolder
        ? `observations/${currentUser.uid}/${currentFolder}/${id}`
        : `observations/${currentUser.uid}/${id}`;
    await FBD.ref(path).update(data);
  },
  
  async deleteObservation(id) {
    if (!FBD || !currentUser) return;
    const folderSelect = document.getElementById('folderSelect');
    const currentFolder = folderSelect ? folderSelect.value : null;
    const path = isGroupMode && currentGroupId
      ? `groups/${currentGroupId}/observations/${currentUser.email.replace(/\./g, '_')}/${id}`
      : currentFolder
        ? `observations/${currentUser.uid}/${currentFolder}/${id}`
        : `observations/${currentUser.uid}/${id}`;
    await FBD.ref(path).remove();
  }
};

// ==================== ENHANCED STATISTICS MANAGER ====================
const EnhancedStatsManager = {
  observations: [],
  currentYear: new Date().getFullYear(),
  charts: {},
  
  async open() {
    if (!window.Chart) {
      await this.loadChartJS();
    }
    await this.loadObservations();
    document.getElementById('enhancedStatsModal').style.display = 'flex';
    this.showTab('overview');
  },
  
  async loadChartJS() {
    return new Promise((resolve, reject) => {
      if (window.Chart) { resolve(); return; }
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
      script.onload = resolve;
      script.onerror = reject;
      document.body.appendChild(script);
    });
  },
  
  close() {
    document.getElementById('enhancedStatsModal').style.display = 'none';
    Object.values(this.charts).forEach(chart => { if (chart) chart.destroy(); });
    this.charts = {};
  },
  
  async loadObservations() {
    if (window.FBD && currentUser) {
      try {
        const snapshot = await window.FBD.ref(`observations/${currentUser.uid}`).once('value');
        const data = snapshot.val();
        this.observations = [];
        if (data) {
          Object.keys(data).forEach(key => {
            if (typeof data[key] === 'object') {
              Object.values(data[key]).forEach(obs => {
                if (obs && obs.bird) this.observations.push(obs);
              });
            }
          });
        }
      } catch (error) {
        console.error('Fehler beim Laden:', error);
        this.observations = [];
      }
    } else {
      this.observations = window.observations || [];
    }
  },
  
  showTab(tabName) {
    document.querySelectorAll('.stats-tab-content').forEach(tab => tab.style.display = 'none');
    document.querySelectorAll('.stats-tab').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`statsTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).style.display = 'block';
    event?.target?.classList.add('active');
    
    switch(tabName) {
      case 'overview': this.renderOverview(); break;
      case 'yearly': this.renderYearlyComparison(); break;
      case 'heatmap': this.renderHeatmap(); break;
      case 'milestones': this.renderMilestones(); break;
    }
  },
  
  renderOverview() {
    const totalSpecies = new Set(this.observations.map(o => o.bird)).size;
    const totalObs = this.observations.length;
    
    const now = new Date();
    const thisMonth = this.observations.filter(o => {
      const obsDate = new Date(o.date);
      return obsDate.getMonth() === now.getMonth() && obsDate.getFullYear() === now.getFullYear();
    });
    const thisMonthSpecies = new Set(thisMonth.map(o => o.bird)).size;
    
    const birdCounts = {};
    this.observations.forEach(o => {
      birdCounts[o.bird] = (birdCounts[o.bird] || 0) + (o.count || 1);
    });
    const topBird = Object.entries(birdCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || '-';
    
    document.getElementById('totalSpecies').textContent = totalSpecies;
    document.getElementById('totalObservations').textContent = totalObs;
    document.getElementById('thisMonthSpecies').textContent = thisMonthSpecies;
    document.getElementById('topBird').textContent = topBird;
    
    this.renderTopSpeciesChart(birdCounts);
  },
  
  renderTopSpeciesChart(birdCounts) {
    const canvas = document.getElementById('topSpeciesChart');
    if (!canvas) return;
    if (this.charts.topSpecies) this.charts.topSpecies.destroy();
    
    const top10 = Object.entries(birdCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);
    const ctx = canvas.getContext('2d');
    this.charts.topSpecies = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: top10.map(([bird]) => bird),
        datasets: [{
          label: 'Anzahl Beobachtungen',
          data: top10.map(([, count]) => count),
          backgroundColor: 'rgba(6, 182, 212, 0.6)',
          borderColor: 'rgba(6, 182, 212, 1)',
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.04)' } },
          x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
        }
      }
    });
  },
  
  renderYearlyComparison() {
    document.getElementById('currentYearDisplay').textContent = this.currentYear;
    
    const yearObs = this.observations.filter(o => new Date(o.date).getFullYear() === this.currentYear);
    const yearSpecies = new Set(yearObs.map(o => o.bird)).size;
    const yearCount = yearObs.length;
    
    document.getElementById('yearTitle').textContent = this.currentYear;
    document.getElementById('yearSpecies').textContent = yearSpecies;
    document.getElementById('yearObservations').textContent = yearCount;
    
    const lastYearObs = this.observations.filter(o => new Date(o.date).getFullYear() === this.currentYear - 1);
    const lastYearSpecies = new Set(lastYearObs.map(o => o.bird)).size;
    const diff = yearSpecies - lastYearSpecies;
    const comparisonEl = document.getElementById('yearComparison');
    
    if (diff > 0) {
      comparisonEl.textContent = `+${diff} Arten mehr als ${this.currentYear - 1}`;
      comparisonEl.className = 'year-comparison positive';
    } else if (diff < 0) {
      comparisonEl.textContent = `${diff} Arten weniger als ${this.currentYear - 1}`;
      comparisonEl.className = 'year-comparison negative';
    } else {
      comparisonEl.textContent = `Gleich viele Arten wie ${this.currentYear - 1}`;
      comparisonEl.className = 'year-comparison';
    }
    
    this.renderYearlyChart();
  },
  
  renderYearlyChart() {
    const canvas = document.getElementById('yearlyComparisonChart');
    if (!canvas) return;
    if (this.charts.yearly) this.charts.yearly.destroy();
    
    const monthData = Array(12).fill(0);
    this.observations.forEach(o => {
      const date = new Date(o.date);
      if (date.getFullYear() === this.currentYear) monthData[date.getMonth()]++;
    });
    
    const ctx = canvas.getContext('2d');
    this.charts.yearly = new Chart(ctx, {
      type: 'line',
      data: {
        labels: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
        datasets: [{
          label: 'Beobachtungen ' + this.currentYear,
          data: monthData,
          borderColor: 'rgba(6, 182, 212, 1)',
          backgroundColor: 'rgba(6, 182, 212, 0.1)',
          fill: true,
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#94a3b8' } } },
        scales: {
          y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.04)' } },
          x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
        }
      }
    });
  },
  
  changeYear(direction) {
    this.currentYear += direction;
    this.renderYearlyComparison();
  },
  
  renderHeatmap() {
    const type = document.querySelector('input[name="heatmapType"]:checked')?.value || 'hour';
    this.updateHeatmap(type);
  },
  
  updateHeatmap(type) {
    const canvas = document.getElementById('heatmapCanvas');
    if (!canvas) return;
    if (this.charts.heatmap) this.charts.heatmap.destroy();
    
    let labels, data;
    
    if (type === 'hour') {
      labels = Array.from({length: 24}, (_, i) => `${i}:00`);
      data = Array(24).fill(0);
      this.observations.forEach(o => {
        if (o.timestamp) data[new Date(o.timestamp).getHours()]++;
      });
    } else if (type === 'month') {
      labels = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
      data = Array(12).fill(0);
      this.observations.forEach(o => data[new Date(o.date).getMonth()]++);
    } else {
      labels = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
      data = Array(7).fill(0);
      this.observations.forEach(o => data[new Date(o.date).getDay()]++);
    }
    
    const ctx = canvas.getContext('2d');
    this.charts.heatmap = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Beobachtungen',
          data: data,
          backgroundColor: data.map(val => {
            const max = Math.max(...data);
            const intensity = max > 0 ? val / max : 0;
            return `rgba(6, 182, 212, ${0.2 + intensity * 0.8})`;
          }),
          borderColor: 'rgba(6, 182, 212, 1)',
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.04)' } },
          x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
        }
      }
    });
  },
  
  renderMilestones() {
    const container = document.getElementById('milestonesContainer');
    container.innerHTML = '';
    
    const totalSpecies = new Set(this.observations.map(o => o.bird)).size;
    const totalObs = this.observations.length;
    
    const milestones = [
      { icon: '🥚', title: 'Erste Schritte', desc: '1 Art beobachtet', target: 1, achieved: totalSpecies >= 1 },
      { icon: '🐣', title: 'Anfänger', desc: '10 Arten beobachtet', target: 10, achieved: totalSpecies >= 10 },
      { icon: '🐥', title: 'Fortgeschritten', desc: '25 Arten beobachtet', target: 25, achieved: totalSpecies >= 25 },
      { icon: '🦅', title: 'Experte', desc: '50 Arten beobachtet', target: 50, achieved: totalSpecies >= 50 },
      { icon: '👁️', title: 'Beobachter', desc: '100 Beobachtungen', target: 100, achieved: totalObs >= 100 },
      { icon: '🔭', title: 'Enthusiast', desc: '500 Beobachtungen', target: 500, achieved: totalObs >= 500 },
      { icon: '⭐', title: 'Meister', desc: '100 Arten beobachtet', target: 100, achieved: totalSpecies >= 100 },
      { icon: '🏆', title: 'Legende', desc: '1000 Beobachtungen', target: 1000, achieved: totalObs >= 1000 }
    ];
    
    milestones.forEach(m => {
      const card = document.createElement('div');
      card.className = `milestone-card ${m.achieved ? 'achieved' : ''}`;
      const current = m.desc.includes('Arten') ? totalSpecies : totalObs;
      const progress = Math.min(100, (current / m.target) * 100);
      
      card.innerHTML = `
        <div class="milestone-icon">${m.icon}</div>
        <div class="milestone-info">
          <h4>${m.title}</h4>
          <p>${m.desc}</p>
          <div class="milestone-progress">${current} / ${m.target}</div>
        </div>
        <div class="milestone-badge">${m.achieved ? '✓ Erreicht' : `${progress.toFixed(0)}%`}</div>
      `;
      container.appendChild(card);
    });
    
    const lifelistProgress = Math.min(100, (totalSpecies / 500) * 100);
    document.getElementById('lifelistProgress').style.width = lifelistProgress + '%';
    document.getElementById('lifelistText').textContent = `${totalSpecies} von 500 möglichen Arten in Deutschland (${lifelistProgress.toFixed(1)}%)`;
  }
};

// ==================== TUTORIAL RESET FUNCTION ====================
TutorialManager.reset = function() {
  localStorage.removeItem('birdcount_tutorial_seen');
  this.start();
};

// ==================== INITIALIZE ALL NEW FEATURES ====================
document.addEventListener('DOMContentLoaded', () => {
  TutorialManager.init();
  TooltipManager.init();
  BulkEditManager.init();
});

</script>

<!-- ==================== TUTORIAL OVERLAY ==================== -->
<div id="tutorialOverlay" class="tutorial-overlay" style="display: none;">
  <div class="tutorial-box">
    <div class="tutorial-header">
      <h3 id="tutorialTitle">Willkommen bei BirdCount!</h3>
      <button onclick="TutorialManager.skip()" class="tutorial-close">✕</button>
    </div>
    <div class="tutorial-content">
      <p id="tutorialText"></p>
      <div class="tutorial-image" id="tutorialImage"></div>
    </div>
    <div class="tutorial-footer">
      <span id="tutorialProgress">1 / 5</span>
      <div class="tutorial-buttons">
        <button onclick="TutorialManager.skip()" class="btn ghost">Überspringen</button>
        <button onclick="TutorialManager.prev()" id="tutorialPrev" class="btn ghost">Zurück</button>
        <button onclick="TutorialManager.next()" id="tutorialNext" class="btn">Weiter</button>
      </div>
    </div>
  </div>
</div>

<!-- ==================== TOOLTIP CONTAINER ==================== -->
<div id="tooltipContainer" class="tooltip-container" style="display: none;"></div>

<!-- ==================== BULK EDIT MODAL ==================== -->
<div id="bulkEditModal" class="modal" style="display: none;">
  <div class="modal-content bulk-edit-modal">
    <div class="modal-header">
      <h2>📦 Mehrfachbearbeitung</h2>
      <button onclick="BulkEditManager.close()" class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      <p class="muted"><span id="bulkSelectedCount">0</span> Beobachtungen ausgewählt</p>
      
      <div class="bulk-actions">
        <h3>Aktion wählen:</h3>
        <div class="bulk-action-grid">
          <button onclick="BulkEditManager.changeDate()" class="bulk-action-btn">
            📅<br>Datum ändern
          </button>
          <button onclick="BulkEditManager.changeLocation()" class="bulk-action-btn">
            📍<br>Standort ändern
          </button>
          <button onclick="BulkEditManager.addNote()" class="bulk-action-btn">
            📝<br>Notiz hinzufügen
          </button>
          <button onclick="BulkEditManager.deleteSelected()" class="bulk-action-btn danger">
            🗑️<br>Löschen
          </button>
          <button onclick="BulkEditManager.exportSelected()" class="bulk-action-btn">
            💾<br>Exportieren
          </button>
          <button onclick="BulkEditManager.moveToFolder()" class="bulk-action-btn">
            📁<br>In Ordner verschieben
          </button>
        </div>
      </div>
      
      <div class="selected-list">
        <h3>Ausgewählte Beobachtungen:</h3>
        <div id="bulkSelectedList" class="bulk-selected-list"></div>
      </div>
    </div>
  </div>
</div>

<!-- ==================== ENHANCED STATISTICS MODAL ==================== -->
<div id="enhancedStatsModal" class="modal" style="display: none;">
  <div class="modal-content enhanced-stats-modal">
    <div class="modal-header">
      <h2>📊 Erweiterte Statistiken</h2>
      <button onclick="EnhancedStatsManager.close()" class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      
      <!-- Tab Navigation -->
      <div class="stats-tabs">
        <button class="stats-tab active" onclick="EnhancedStatsManager.showTab('overview')">Übersicht</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('yearly')">Jahresvergleich</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('heatmap')">Heatmap</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('milestones')">Meilensteine</button>
      </div>
      
      <!-- Overview Tab -->
      <div id="statsTabOverview" class="stats-tab-content active">
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-icon">🦅</div>
            <div class="stat-value" id="totalSpecies">-</div>
            <div class="stat-label">Arten gesamt</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">👁️</div>
            <div class="stat-value" id="totalObservations">-</div>
            <div class="stat-label">Beobachtungen</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">📅</div>
            <div class="stat-value" id="thisMonthSpecies">-</div>
            <div class="stat-label">Arten diesen Monat</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">⭐</div>
            <div class="stat-value" id="topBird">-</div>
            <div class="stat-label">Häufigste Art</div>
          </div>
        </div>
        
        <div class="chart-container">
          <h3>Top 10 Arten</h3>
          <canvas id="topSpeciesChart"></canvas>
        </div>
      </div>
      
      <!-- Yearly Comparison Tab -->
      <div id="statsTabYearly" class="stats-tab-content" style="display: none;">
        <div class="year-selector">
          <button onclick="EnhancedStatsManager.changeYear(-1)">◀</button>
          <span id="currentYearDisplay">2024</span>
          <button onclick="EnhancedStatsManager.changeYear(1)">▶</button>
        </div>
        
        <div class="chart-container">
          <canvas id="yearlyComparisonChart"></canvas>
        </div>
        
        <div class="year-stats">
          <div class="year-stat-card">
            <h4 id="yearTitle">2024</h4>
            <p><strong id="yearSpecies">-</strong> Arten</p>
            <p><strong id="yearObservations">-</strong> Beobachtungen</p>
            <p class="year-comparison" id="yearComparison"></p>
          </div>
        </div>
      </div>
      
      <!-- Heatmap Tab -->
      <div id="statsTabHeatmap" class="stats-tab-content" style="display: none;">
        <div class="heatmap-controls">
          <label>
            <input type="radio" name="heatmapType" value="hour" checked onchange="EnhancedStatsManager.updateHeatmap()">
            Nach Tageszeit
          </label>
          <label>
            <input type="radio" name="heatmapType" value="month" onchange="EnhancedStatsManager.updateHeatmap()">
            Nach Monat
          </label>
          <label>
            <input type="radio" name="heatmapType" value="weekday" onchange="EnhancedStatsManager.updateHeatmap()">
            Nach Wochentag
          </label>
        </div>
        
        <div class="heatmap-container">
          <canvas id="heatmapCanvas"></canvas>
        </div>
        
        <div class="heatmap-legend">
          <span>Weniger</span>
          <div class="legend-gradient"></div>
          <span>Mehr</span>
        </div>
      </div>
      
      <!-- Milestones Tab -->
      <div id="statsTabMilestones" class="stats-tab-content" style="display: none;">
        <div class="milestones-container" id="milestonesContainer">
          <!-- Wird dynamisch gefüllt -->
        </div>
        
        <div class="progress-section">
          <h3>Lebenslist-Fortschritt</h3>
          <div class="progress-bar-container">
            <div class="progress-bar" id="lifelistProgress" style="width: 0%"></div>
          </div>
          <p class="progress-text" id="lifelistText">-</p>
        </div>
      </div>
      
    </div>
  </div>
</div>

<!-- Floating Action Button für Quick Add -->
<button class="fab-quick-add" onclick="openQuickAdd()" title="Schnelleingabe (Strg+Q)">
  ⚡
</button>

<!-- === NEUE FEATURES: Modals === -->

<!-- Tutorial Overlay -->
<div id="tutorialOverlay" class="tutorial-overlay" style="display: none;">
  <div class="tutorial-box">
    <div class="tutorial-header">
      <h3 id="tutorialTitle">Willkommen bei BirdCount!</h3>
      <button onclick="TutorialManager.skip()" class="tutorial-close">✕</button>
    </div>
    <div class="tutorial-content">
      <p id="tutorialText"></p>
      <div class="tutorial-image" id="tutorialImage"></div>
    </div>
    <div class="tutorial-footer">
      <span id="tutorialProgress">1 / 6</span>
      <div class="tutorial-buttons">
        <button onclick="TutorialManager.skip()" class="btn ghost">Überspringen</button>
        <button onclick="TutorialManager.prev()" id="tutorialPrev" class="btn ghost">Zurück</button>
        <button onclick="TutorialManager.next()" id="tutorialNext" class="btn">Weiter</button>
      </div>
    </div>
  </div>
</div>

<!-- Tooltip Container -->
<div id="tooltipContainer" class="tooltip-container" style="display: none;"></div>

<!-- Bulk Edit Modal -->
<div id="bulkEditModal" class="modal" style="display: none;">
  <div class="modal-content bulk-edit-modal">
    <div class="modal-header">
      <h2>📦 Mehrfachbearbeitung</h2>
      <button onclick="BulkEditManager.close()" class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      <p class="muted"><span id="bulkSelectedCount">0</span> Beobachtungen ausgewählt</p>
      
      <div class="bulk-actions">
        <h3>Aktion wählen:</h3>
        <div class="bulk-action-grid">
          <button onclick="BulkEditManager.changeDate()" class="bulk-action-btn">
            📅<br>Datum ändern
          </button>
          <button onclick="BulkEditManager.changeLocation()" class="bulk-action-btn">
            📍<br>Standort ändern
          </button>
          <button onclick="BulkEditManager.addNote()" class="bulk-action-btn">
            📝<br>Notiz hinzufügen
          </button>
          <button onclick="BulkEditManager.deleteSelected()" class="bulk-action-btn danger">
            🗑️<br>Löschen
          </button>
          <button onclick="BulkEditManager.exportSelected()" class="bulk-action-btn">
            💾<br>Exportieren
          </button>
          <button onclick="BulkEditManager.moveToFolder()" class="bulk-action-btn">
            📁<br>In Ordner verschieben
          </button>
        </div>
      </div>
      
      <div class="selected-list">
        <h3>Ausgewählte Beobachtungen:</h3>
        <div id="bulkSelectedList" class="bulk-selected-list"></div>
      </div>
    </div>
  </div>
</div>

<!-- Enhanced Statistics Modal -->
<div id="enhancedStatsModal" class="modal" style="display: none;">
  <div class="modal-content enhanced-stats-modal">
    <div class="modal-header">
      <h2>📊 Erweiterte Statistiken</h2>
      <button onclick="EnhancedStatsManager.close()" class="modal-close">✕</button>
    </div>
    <div class="modal-body">
      
      <!-- Tab Navigation -->
      <div class="stats-tabs">
        <button class="stats-tab active" onclick="EnhancedStatsManager.showTab('overview')">Übersicht</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('yearly')">Jahresvergleich</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('heatmap')">Heatmap</button>
        <button class="stats-tab" onclick="EnhancedStatsManager.showTab('milestones')">Meilensteine</button>
      </div>
      
      <!-- Overview Tab -->
      <div id="statsTabOverview" class="stats-tab-content active">
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-icon">🦅</div>
            <div class="stat-value" id="totalSpecies">-</div>
            <div class="stat-label">Arten gesamt</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">👁️</div>
            <div class="stat-value" id="totalObservations">-</div>
            <div class="stat-label">Beobachtungen</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">📅</div>
            <div class="stat-value" id="thisMonthSpecies">-</div>
            <div class="stat-label">Arten diesen Monat</div>
          </div>
          <div class="stat-card">
            <div class="stat-icon">⭐</div>
            <div class="stat-value" id="topBird">-</div>
            <div class="stat-label">Häufigste Art</div>
          </div>
        </div>
        
        <div style="background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border: 1px solid rgba(255,255,255,0.04); border-radius: 12px; padding: 24px;">
          <h3 style="margin: 0 0 20px 0;">Top 10 Arten</h3>
          <canvas id="topSpeciesChart" style="max-height: 400px;"></canvas>
        </div>
      </div>
      
      <!-- Yearly Comparison Tab -->
      <div id="statsTabYearly" class="stats-tab-content" style="display: none;">
        <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 24px;">
          <button onclick="EnhancedStatsManager.changeYear(-1)" class="btn ghost">◀</button>
          <span id="currentYearDisplay" style="font-size: 24px; font-weight: 700; min-width: 100px; text-align: center;">2024</span>
          <button onclick="EnhancedStatsManager.changeYear(1)" class="btn ghost">▶</button>
        </div>
        
        <div style="background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border: 1px solid rgba(255,255,255,0.04); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
          <canvas id="yearlyComparisonChart" style="max-height: 400px;"></canvas>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(min(100%, 250px), 1fr)); gap: 16px;">
          <div style="background: linear-gradient(135deg, rgba(6,182,212,0.06), rgba(124,58,237,0.06)); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 20px;">
            <h4 id="yearTitle" style="margin: 0 0 16px 0;">2024</h4>
            <p style="margin: 8px 0;"><strong id="yearSpecies" style="color: var(--accent); font-size: 20px;">-</strong> Arten</p>
            <p style="margin: 8px 0;"><strong id="yearObservations" style="color: var(--accent); font-size: 20px;">-</strong> Beobachtungen</p>
            <p id="yearComparison" class="muted" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.04);"></p>
          </div>
        </div>
      </div>
      
      <!-- Heatmap Tab -->
      <div id="statsTabHeatmap" class="stats-tab-content" style="display: none;">
        <div style="display: flex; gap: 20px; margin-bottom: 24px; justify-content: center; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 16px; border-radius: 8px; background: var(--glass); border: 1px solid rgba(255,255,255,0.04);">
            <input type="radio" name="heatmapType" value="hour" checked onchange="EnhancedStatsManager.updateHeatmap(this.value)">
            Nach Tageszeit
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 16px; border-radius: 8px; background: var(--glass); border: 1px solid rgba(255,255,255,0.04);">
            <input type="radio" name="heatmapType" value="month" onchange="EnhancedStatsManager.updateHeatmap(this.value)">
            Nach Monat
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 16px; border-radius: 8px; background: var(--glass); border: 1px solid rgba(255,255,255,0.04);">
            <input type="radio" name="heatmapType" value="weekday" onchange="EnhancedStatsManager.updateHeatmap(this.value)">
            Nach Wochentag
          </label>
        </div>
        
        <div style="background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border: 1px solid rgba(255,255,255,0.04); border-radius: 12px; padding: 24px; display: flex; justify-content: center; align-items: center; min-height: 400px;">
          <canvas id="heatmapCanvas" style="max-width: 100%; height: auto;"></canvas>
        </div>
        
        <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-top: 16px; font-size: 13px; color: var(--muted);">
          <span>Weniger</span>
          <div style="width: 200px; height: 20px; border-radius: 10px; background: linear-gradient(90deg, rgba(6,182,212,0.1), rgba(6,182,212,0.3), rgba(6,182,212,0.6), rgba(6,182,212,1)); border: 1px solid rgba(255,255,255,0.1);"></div>
          <span>Mehr</span>
        </div>
      </div>
      
      <!-- Milestones Tab -->
      <div id="statsTabMilestones" class="stats-tab-content" style="display: none;">
        <div id="milestonesContainer"></div>
        
        <div style="background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border: 1px solid rgba(255,255,255,0.04); border-radius: 12px; padding: 24px; margin-top: 24px;">
          <h3 style="margin: 0 0 16px 0;">Lebenslist-Fortschritt</h3>
          <div class="progress-bar-container">
            <div class="progress-bar" id="lifelistProgress" style="width: 0%"></div>
          </div>
          <p id="lifelistText" style="margin-top: 12px; text-align: center; color: var(--soft);"></p>
        </div>
      </div>
      
    </div>
  </div>
</div>

<script>

// Auto-Initialize
setTimeout(() => {
  TutorialManager.init();
  TooltipManager.init();
  BulkEditManager.init();
}, 1000);

// ===== NEUE FUNKTIONALITÄT: Beobachtungs-Details beim Chart-Klick =====

// Globale Variable zum Speichern der Beobachtungen pro Label
window.chartObservationsByLabel = {};

// Funktion zum Anzeigen der Beobachtungen für ein bestimmtes Label
function showObservationsForLabel(labelIndex, chartInstance, isNewSpeciesMode = false) {
  console.log('🔍 showObservationsForLabel aufgerufen mit Index:', labelIndex);
  console.log('📊 Chart Labels:', chartInstance.data.labels);
  console.log('🎯 Erstbeobachtungs-Modus:', isNewSpeciesMode);
  
  const label = chartInstance.data.labels[labelIndex];
  console.log('🏷️ Ausgewähltes Label:', label);
  console.log('📦 Verfügbare Labels in chartObservationsByLabel:', Object.keys(window.chartObservationsByLabel));
  
  const observations = window.chartObservationsByLabel[label] || [];
  console.log('🐦 Gefundene Beobachtungen:', observations.length, observations);
  
  if (observations.length === 0) {
    console.warn('⚠️ Keine Beobachtungen für dieses Label gefunden!');
    alert(`Keine Beobachtungen für "${label}" gefunden.\n\nVerfügbare Labels: ${Object.keys(window.chartObservationsByLabel).join(', ')}`);
    return;
  }
  
  // NEUE STRATEGIE: Entferne altes Modal und erstelle komplett neues
  const oldModal = document.getElementById('chartDetailsModal');
  if (oldModal) {
    oldModal.remove();
  }
  
  // Erstelle Modal-HTML als String
  const modalHTML = `
    <div id="chartDetailsModal" style="
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(2, 6, 23, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 99999;
      padding: 20px;
      box-sizing: border-box;
    ">
      <div style="
        background: var(--card);
        padding: 24px;
        border-radius: 16px;
        max-width: 700px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        position: relative;
        border: 1px solid rgba(6,182,212,0.3);
        box-shadow: 0 20px 60px rgba(6,182,212,0.5);
      " onclick="event.stopPropagation()">
        <button onclick="document.getElementById('chartDetailsModal').remove()" style="
          position: absolute;
          top: 12px;
          right: 12px;
          background: transparent;
          border: none;
          color: var(--muted);
          cursor: pointer;
          font-size: 28px;
          line-height: 1;
          padding: 4px 8px;
          z-index: 1;
        " onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'">×</button>
        
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
          <div style="width: 48px; height: 48px; border-radius: 12px; background: linear-gradient(135deg, var(--accent), var(--accent-2)); display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 6px 18px rgba(6,182,212,0.4);">📊</div>
          <div style="flex: 1;">
            <h3 style="margin: 0; font-size: 20px; color: var(--text); font-weight: 700;">
              ${isNewSpeciesMode ? 'Erstbeobachtungen' : 'Beobachtungen'}: ${label}
            </h3>
            <p style="margin: 4px 0 0 0; font-size: 13px; color: var(--muted);">
              ${observations.length} ${isNewSpeciesMode ? 'neue Art' : 'Beobachtung'}${observations.length !== 1 ? 'en' : ''}
            </p>
          </div>
        </div>
        
        <div id="chartDetailsContent" style="display: flex; flex-direction: column; gap: 10px;"></div>
      </div>
    </div>
  `;
  
  // Füge Modal zum Body hinzu
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  
  const modal = document.getElementById('chartDetailsModal');
  const content = document.getElementById('chartDetailsContent');
  
  console.log('✅ Neues Modal erstellt:', modal);
  
  // Schließe Modal beim Klick auf Overlay
  modal.addEventListener('click', function(e) {
    if (e.target === modal) {
      modal.remove();
    }
  });
  
  // Sortiere Beobachtungen nach Datum (neueste zuerst)
  const sortedObservations = [...observations].sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateB - dateA;
  });
  
  console.log('📝 Erstelle Content für', sortedObservations.length, 'Beobachtungen...');
  
  // Erstelle Beobachtungskarten
  sortedObservations.forEach((obs, index) => {
    const card = document.createElement('div');
    card.style.cssText = `
      background: linear-gradient(135deg, rgba(6,182,212,0.08), rgba(124,58,237,0.04));
      border: 1px solid rgba(6,182,212,0.2);
      border-radius: 10px;
      padding: 14px;
      display: flex;
      gap: 12px;
      align-items: center;
      transition: all 0.2s;
      cursor: pointer;
    `;
    
    card.onmouseover = () => {
      card.style.transform = 'translateY(-2px)';
      card.style.boxShadow = '0 6px 20px rgba(6,182,212,0.3)';
    };
    card.onmouseout = () => {
      card.style.transform = 'translateY(0)';
      card.style.boxShadow = 'none';
    };
    
    const emoji = getBirdEmoji(obs.bird);
    
    // Erstelle Info-Badges
    const badges = [];
    if (obs.userName) badges.push(`<span style="font-size: 11px; color: var(--muted); background: rgba(6,182,212,0.1); padding: 4px 8px; border-radius: 6px; white-space: nowrap;">👤 ${obs.userName}</span>`);
    if (obs.count && obs.count !== '1') badges.push(`<span style="font-size: 11px; color: var(--muted); background: rgba(124,58,237,0.1); padding: 4px 8px; border-radius: 6px; white-space: nowrap;">🔢 ${obs.count}×</span>`);
    if (obs.tickable === true) badges.push(`<span style="font-size: 11px; color: #10b981; background: rgba(16,185,129,0.1); padding: 4px 8px; border-radius: 6px; white-space: nowrap;">✅ Tickbar</span>`);
    if (obs.selffound === true) badges.push(`<span style="font-size: 11px; color: #ef4444; background: rgba(239,68,68,0.1); padding: 4px 8px; border-radius: 6px; white-space: nowrap;">🔍 Selffound</span>`);
    if (isNewSpeciesMode) badges.push(`<span style="font-size: 11px; color: #06b6d4; background: rgba(6,182,212,0.15); padding: 4px 8px; border-radius: 6px; white-space: nowrap;">⭐ Erstsichtung</span>`);
    
    card.innerHTML = `
      <div style="font-size: 32px; flex-shrink: 0;">${emoji}</div>
      <div style="flex: 1; min-width: 0;">
        <div style="font-weight: 600; font-size: 15px; color: var(--text); margin-bottom: 4px;">
          ${obs.bird}
        </div>
        <div style="font-size: 12px; color: var(--muted); display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 6px;">
          <span>📅 ${formatDateForDisplay(obs.date)}</span>
          ${obs.time ? `<span>⏰ ${obs.time}</span>` : ''}
          ${obs.location ? `<span>📍 ${obs.location}</span>` : ''}
        </div>
        ${obs.behavior ? `<div style="font-size: 12px; color: var(--soft); margin-bottom: 4px;">🦅 ${obs.behavior}</div>` : ''}
        ${obs.weather ? `<div style="font-size: 12px; color: var(--soft); margin-bottom: 4px;">🌤️ ${obs.weather}</div>` : ''}
        ${badges.length > 0 ? `<div style="display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px;">${badges.join('')}</div>` : ''}
      </div>
    `;
    
    // Klick führt zur Beobachtungsansicht
    card.onclick = (e) => {
      e.stopPropagation();
      modal.remove();
      showPage('home');
    };
    
    content.appendChild(card);
  });
  
  console.log('✅ Modal sollte jetzt sichtbar sein!');
}

// Legacy-Funktion für Rückwärtskompatibilität
function showFirstSightingsForLabel(labelIndex, chartInstance) {
  showObservationsForLabel(labelIndex, chartInstance, true);
}

// Hilfsfunktion um Vogel-Emoji zu bekommen
function getBirdEmoji(birdName) {
  const emojiMap = {
    'Amsel': '🐦',
    'Blaumeise': '💙',
    'Kohlmeise': '🖤',
    'Rotkehlchen': '🔴',
    'Star': '⭐',
    'Spatz': '🐦',
    'Haussperling': '🏠',
    'Feldsperling': '🌾',
    'Buchfink': '📘',
    'Grünfink': '💚',
    'Elster': '🔲',
    'Eichelhäher': '🌰',
    'Zaunkönig': '👑',
    'Buntspecht': '🔴',
    'Rotmilan': '🪁',
    'Mäusebussard': '🦅',
    'Turmfalke': '🏰'
  };
  return emojiMap[birdName] || '🐦';
}

// MOBILE GRID FIX - Force all grids to single column on mobile
function fixMobileGrids() {
  const isMobile = window.innerWidth <= 700;
  
  if (isMobile) {
    // Find all elements with grid display
    const allElements = document.querySelectorAll('*');
    
    allElements.forEach(el => {
      const style = window.getComputedStyle(el);
      const inlineStyle = el.getAttribute('style') || '';
      
      // Check if element uses CSS Grid
      if (style.display === 'grid' || inlineStyle.includes('display:grid') || inlineStyle.includes('display: grid')) {
        // Force single column by setting the property directly
        el.style.setProperty('grid-template-columns', '1fr', 'important');
      }
    });
    
    console.log('📱 Mobile grid fix applied to', document.querySelectorAll('[style*="grid"]').length, 'elements');
  }
}

// Run on page load
window.addEventListener('DOMContentLoaded', () => {
  fixMobileGrids();
  console.log('📱 Initial mobile grid fix completed');
});

// Run after a short delay to catch dynamically loaded content
setTimeout(fixMobileGrids, 500);
setTimeout(fixMobileGrids, 1000);
setTimeout(fixMobileGrids, 2000);

// Run on resize
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(fixMobileGrids, 250);
});

// Run whenever content changes (use MutationObserver)
const observer = new MutationObserver((mutations) => {
  if (window.innerWidth <= 700) {
    // Only run if grids were added
    let shouldFix = false;
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        if (node.nodeType === 1) { // Element node
          const style = node.getAttribute?.('style') || '';
          if (style.includes('grid')) {
            shouldFix = true;
          }
        }
      });
    });
    
    if (shouldFix) {
      fixMobileGrids();
    }
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});

</script>

<!-- Modal für Erstbeobachtungs-Details -->
<div id="firstSightingsDetailModal" class="modal-overlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(2,6,23,0.9); display: none; align-items: center; justify-content: center; z-index: 10000; padding: 20px;" onclick="if(event.target === this) this.style.display='none'">
  <div style="background: var(--card); padding: 24px; border-radius: 16px; max-width: 700px; width: 90%; max-height: 85vh; overflow-y: auto; position: relative; border: 1px solid rgba(6,182,212,0.3); box-shadow: 0 20px 60px rgba(6,182,212,0.3);" onclick="event.stopPropagation()">
    <button onclick="document.getElementById('firstSightingsDetailModal').style.display='none'" style="position: absolute; top: 12px; right: 12px; background: transparent; border: none; color: var(--muted); cursor: pointer; font-size: 28px; line-height: 1; padding: 4px 8px; transition: all 0.2s; z-index: 1;" onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'">×</button>
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
      <div style="width: 48px; height: 48px; border-radius: 12px; background: linear-gradient(135deg, var(--accent), var(--accent-2)); display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 6px 18px rgba(6,182,212,0.4);">📊</div>
      <div style="flex: 1;">
        <h3 id="firstSightingsDetailTitle" style="margin: 0; font-size: 20px; color: var(--text); font-weight: 700;"></h3>
        <p id="firstSightingsDetailSubtitle" style="margin: 4px 0 0 0; font-size: 13px; color: var(--muted);"></p>
      </div>
    </div>
    <div id="firstSightingsDetailContent" style="display: flex; flex-direction: column; gap: 10px;"></div>
  </div>
</div>

</body>
</html>
